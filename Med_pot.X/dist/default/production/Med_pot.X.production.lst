CCS PCH C Compiler, Version 5.048, 5967               03-nov-16 10:49

               Filename:   C:\Users\MARCOS\Proyecto_final\Med_pot.X\dist\default\production\Med_pot.X.production.lst

               ROM used:   6478 bytes (20%)
                           Largest free fragment is 26286
               RAM used:   94 (5%) at main() level
                           156 (8%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   18B2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   00BC
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #import(file="build/default/production/main.o") 
.................... #import(file="build/default/production/funciones.o") 
.................... /** 
.................... *	\file main.c 
.................... *	\brief Resumen del contenido del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  DATA 50,72
00B0:  DATA 69,6D
00B2:  DATA 65,72
00B4:  DATA 20,70
00B6:  DATA 72,75
00B8:  DATA 65,62
00BA:  DATA 61,00
*
034E:  TBLRD*+
0350:  MOVF   FF5,F
0352:  BZ    036C
0354:  MOVFF  FF6,5E
0358:  MOVFF  FF7,5F
035C:  MOVFF  FF5,6C
0360:  RCALL  02E0
0362:  MOVFF  5E,FF6
0366:  MOVFF  5F,FF7
036A:  BRA    034E
036C:  GOTO   039A (RETURN)
*
056A:  MOVLW  8E
056C:  MOVWF  00
056E:  MOVFF  8D,01
0572:  MOVFF  8C,02
0576:  CLRF   03
0578:  MOVF   01,F
057A:  BNZ   058E
057C:  MOVFF  02,01
0580:  CLRF   02
0582:  MOVLW  08
0584:  SUBWF  00,F
0586:  MOVF   01,F
0588:  BNZ   058E
058A:  CLRF   00
058C:  BRA    059E
058E:  BCF    FD8.0
0590:  BTFSC  01.7
0592:  BRA    059C
0594:  RLCF   02,F
0596:  RLCF   01,F
0598:  DECF   00,F
059A:  BRA    058E
059C:  BCF    01.7
059E:  RETURN 0
05A0:  MOVF   x8C,W
05A2:  BTFSC  FD8.2
05A4:  BRA    0688
05A6:  MOVWF  00
05A8:  MOVF   x90,W
05AA:  BTFSC  FD8.2
05AC:  BRA    0688
05AE:  ADDWF  00,F
05B0:  BNC   05BA
05B2:  MOVLW  81
05B4:  ADDWF  00,F
05B6:  BC    0688
05B8:  BRA    05C2
05BA:  MOVLW  7F
05BC:  SUBWF  00,F
05BE:  BNC   0688
05C0:  BZ    0688
05C2:  MOVFF  8D,94
05C6:  MOVF   x91,W
05C8:  XORWF  x94,F
05CA:  BSF    x8D.7
05CC:  BSF    x91.7
05CE:  MOVF   x8F,W
05D0:  MULWF  x93
05D2:  MOVFF  FF4,96
05D6:  MOVF   x8E,W
05D8:  MULWF  x92
05DA:  MOVFF  FF4,03
05DE:  MOVFF  FF3,95
05E2:  MULWF  x93
05E4:  MOVF   FF3,W
05E6:  ADDWF  x96,F
05E8:  MOVF   FF4,W
05EA:  ADDWFC x95,F
05EC:  MOVLW  00
05EE:  ADDWFC 03,F
05F0:  MOVF   x8F,W
05F2:  MULWF  x92
05F4:  MOVF   FF3,W
05F6:  ADDWF  x96,F
05F8:  MOVF   FF4,W
05FA:  ADDWFC x95,F
05FC:  MOVLW  00
05FE:  CLRF   02
0600:  ADDWFC 03,F
0602:  ADDWFC 02,F
0604:  MOVF   x8D,W
0606:  MULWF  x93
0608:  MOVF   FF3,W
060A:  ADDWF  x95,F
060C:  MOVF   FF4,W
060E:  ADDWFC 03,F
0610:  MOVLW  00
0612:  ADDWFC 02,F
0614:  MOVF   x8D,W
0616:  MULWF  x92
0618:  MOVF   FF3,W
061A:  ADDWF  03,F
061C:  MOVF   FF4,W
061E:  ADDWFC 02,F
0620:  MOVLW  00
0622:  CLRF   01
0624:  ADDWFC 01,F
0626:  MOVF   x8F,W
0628:  MULWF  x91
062A:  MOVF   FF3,W
062C:  ADDWF  x95,F
062E:  MOVF   FF4,W
0630:  ADDWFC 03,F
0632:  MOVLW  00
0634:  ADDWFC 02,F
0636:  ADDWFC 01,F
0638:  MOVF   x8E,W
063A:  MULWF  x91
063C:  MOVF   FF3,W
063E:  ADDWF  03,F
0640:  MOVF   FF4,W
0642:  ADDWFC 02,F
0644:  MOVLW  00
0646:  ADDWFC 01,F
0648:  MOVF   x8D,W
064A:  MULWF  x91
064C:  MOVF   FF3,W
064E:  ADDWF  02,F
0650:  MOVF   FF4,W
0652:  ADDWFC 01,F
0654:  INCF   00,F
0656:  BTFSC  01.7
0658:  BRA    0664
065A:  RLCF   x95,F
065C:  RLCF   03,F
065E:  RLCF   02,F
0660:  RLCF   01,F
0662:  DECF   00,F
0664:  MOVLW  00
0666:  BTFSS  x95.7
0668:  BRA    067E
066A:  INCF   03,F
066C:  ADDWFC 02,F
066E:  ADDWFC 01,F
0670:  MOVF   01,W
0672:  BNZ   067E
0674:  MOVF   02,W
0676:  BNZ   067E
0678:  MOVF   03,W
067A:  BNZ   067E
067C:  INCF   00,F
067E:  BTFSC  x94.7
0680:  BSF    01.7
0682:  BTFSS  x94.7
0684:  BCF    01.7
0686:  BRA    0690
0688:  CLRF   00
068A:  CLRF   01
068C:  CLRF   02
068E:  CLRF   03
0690:  RETURN 0
0692:  MOVF   x70,W
0694:  BTFSC  FD8.2
0696:  BRA    07E2
0698:  MOVWF  x7C
069A:  MOVF   x74,W
069C:  BTFSC  FD8.2
069E:  BRA    07E2
06A0:  SUBWF  x7C,F
06A2:  BNC   06AE
06A4:  MOVLW  7F
06A6:  ADDWF  x7C,F
06A8:  BTFSC  FD8.0
06AA:  BRA    07E2
06AC:  BRA    06BA
06AE:  MOVLW  81
06B0:  SUBWF  x7C,F
06B2:  BTFSS  FD8.0
06B4:  BRA    07E2
06B6:  BTFSC  FD8.2
06B8:  BRA    07E2
06BA:  MOVFF  7C,00
06BE:  CLRF   01
06C0:  CLRF   02
06C2:  CLRF   03
06C4:  CLRF   x7B
06C6:  MOVFF  71,7A
06CA:  BSF    x7A.7
06CC:  MOVFF  72,79
06D0:  MOVFF  73,78
06D4:  MOVLW  19
06D6:  MOVWF  x7C
06D8:  MOVF   x77,W
06DA:  SUBWF  x78,F
06DC:  BC    06F8
06DE:  MOVLW  01
06E0:  SUBWF  x79,F
06E2:  BC    06F8
06E4:  SUBWF  x7A,F
06E6:  BC    06F8
06E8:  SUBWF  x7B,F
06EA:  BC    06F8
06EC:  INCF   x7B,F
06EE:  INCF   x7A,F
06F0:  INCF   x79,F
06F2:  MOVF   x77,W
06F4:  ADDWF  x78,F
06F6:  BRA    0748
06F8:  MOVF   x76,W
06FA:  SUBWF  x79,F
06FC:  BC    0722
06FE:  MOVLW  01
0700:  SUBWF  x7A,F
0702:  BC    0722
0704:  SUBWF  x7B,F
0706:  BC    0722
0708:  INCF   x7B,F
070A:  INCF   x7A,F
070C:  MOVF   x76,W
070E:  ADDWF  x79,F
0710:  MOVF   x77,W
0712:  ADDWF  x78,F
0714:  BNC   0748
0716:  INCF   x79,F
0718:  BNZ   0748
071A:  INCF   x7A,F
071C:  BNZ   0748
071E:  INCF   x7B,F
0720:  BRA    0748
0722:  MOVF   x75,W
0724:  IORLW  80
0726:  SUBWF  x7A,F
0728:  BC    0746
072A:  MOVLW  01
072C:  SUBWF  x7B,F
072E:  BC    0746
0730:  INCF   x7B,F
0732:  MOVF   x75,W
0734:  IORLW  80
0736:  ADDWF  x7A,F
0738:  MOVF   x76,W
073A:  ADDWF  x79,F
073C:  BNC   0710
073E:  INCF   x7A,F
0740:  BNZ   0710
0742:  INCF   x7B,F
0744:  BRA    0710
0746:  BSF    03.0
0748:  DECFSZ x7C,F
074A:  BRA    074E
074C:  BRA    0764
074E:  BCF    FD8.0
0750:  RLCF   x78,F
0752:  RLCF   x79,F
0754:  RLCF   x7A,F
0756:  RLCF   x7B,F
0758:  BCF    FD8.0
075A:  RLCF   03,F
075C:  RLCF   02,F
075E:  RLCF   01,F
0760:  RLCF   x7D,F
0762:  BRA    06D8
0764:  BTFSS  x7D.0
0766:  BRA    0774
0768:  BCF    FD8.0
076A:  RRCF   01,F
076C:  RRCF   02,F
076E:  RRCF   03,F
0770:  RRCF   x7D,F
0772:  BRA    0778
0774:  DECF   00,F
0776:  BZ    07E2
0778:  BTFSC  x7D.7
077A:  BRA    07B8
077C:  BCF    FD8.0
077E:  RLCF   x78,F
0780:  RLCF   x79,F
0782:  RLCF   x7A,F
0784:  RLCF   x7B,F
0786:  MOVF   x77,W
0788:  SUBWF  x78,F
078A:  BC    079A
078C:  MOVLW  01
078E:  SUBWF  x79,F
0790:  BC    079A
0792:  SUBWF  x7A,F
0794:  BC    079A
0796:  SUBWF  x7B,F
0798:  BNC   07CE
079A:  MOVF   x76,W
079C:  SUBWF  x79,F
079E:  BC    07AA
07A0:  MOVLW  01
07A2:  SUBWF  x7A,F
07A4:  BC    07AA
07A6:  SUBWF  x7B,F
07A8:  BNC   07CE
07AA:  MOVF   x75,W
07AC:  IORLW  80
07AE:  SUBWF  x7A,F
07B0:  BC    07B8
07B2:  MOVLW  01
07B4:  SUBWF  x7B,F
07B6:  BNC   07CE
07B8:  INCF   03,F
07BA:  BNZ   07CE
07BC:  INCF   02,F
07BE:  BNZ   07CE
07C0:  INCF   01,F
07C2:  BNZ   07CE
07C4:  INCF   00,F
07C6:  BZ    07E2
07C8:  RRCF   01,F
07CA:  RRCF   02,F
07CC:  RRCF   03,F
07CE:  MOVFF  71,7C
07D2:  MOVF   x75,W
07D4:  XORWF  x7C,F
07D6:  BTFSS  x7C.7
07D8:  BRA    07DE
07DA:  BSF    01.7
07DC:  BRA    07EA
07DE:  BCF    01.7
07E0:  BRA    07EA
07E2:  CLRF   00
07E4:  CLRF   01
07E6:  CLRF   02
07E8:  CLRF   03
07EA:  RETURN 0
07EC:  MOVLW  80
07EE:  BTFSC  FD8.1
07F0:  XORWF  x91,F
07F2:  CLRF   x96
07F4:  CLRF   x97
07F6:  MOVFF  8D,95
07FA:  MOVF   x91,W
07FC:  XORWF  x95,F
07FE:  MOVF   x8C,W
0800:  BTFSC  FD8.2
0802:  BRA    09BC
0804:  MOVWF  x94
0806:  MOVWF  00
0808:  MOVF   x90,W
080A:  BTFSC  FD8.2
080C:  BRA    09CE
080E:  SUBWF  x94,F
0810:  BTFSC  FD8.2
0812:  BRA    0916
0814:  BNC   0890
0816:  MOVFF  91,9A
081A:  BSF    x9A.7
081C:  MOVFF  92,99
0820:  MOVFF  93,98
0824:  CLRF   x97
0826:  BCF    FD8.0
0828:  RRCF   x9A,F
082A:  RRCF   x99,F
082C:  RRCF   x98,F
082E:  RRCF   x97,F
0830:  DECFSZ x94,F
0832:  BRA    0824
0834:  BTFSS  x95.7
0836:  BRA    083E
0838:  BSF    x96.0
083A:  BRA    09F6
083C:  BCF    x96.0
083E:  BCF    x94.0
0840:  BSF    x96.4
0842:  CLRF   FEA
0844:  MOVLW  8F
0846:  MOVWF  FE9
0848:  BRA    0A1C
084A:  BCF    x96.4
084C:  BTFSC  x95.7
084E:  BRA    0864
0850:  BTFSS  x94.0
0852:  BRA    087A
0854:  RRCF   x9A,F
0856:  RRCF   x99,F
0858:  RRCF   x98,F
085A:  RRCF   x97,F
085C:  INCF   00,F
085E:  BTFSC  FD8.2
0860:  BRA    09EC
0862:  BRA    087A
0864:  BTFSC  x9A.7
0866:  BRA    0880
0868:  BCF    FD8.0
086A:  RLCF   x97,F
086C:  RLCF   x98,F
086E:  RLCF   x99,F
0870:  RLCF   x9A,F
0872:  DECF   00,F
0874:  BTFSC  FD8.2
0876:  BRA    09EC
0878:  BRA    0864
087A:  BSF    x96.6
087C:  BRA    0954
087E:  BCF    x96.6
0880:  MOVFF  8D,95
0884:  BTFSS  x8D.7
0886:  BRA    088C
0888:  BSF    x9A.7
088A:  BRA    09DE
088C:  BCF    x9A.7
088E:  BRA    09DE
0890:  MOVFF  90,94
0894:  MOVFF  90,00
0898:  MOVF   x8C,W
089A:  SUBWF  x94,F
089C:  MOVFF  8D,9A
08A0:  BSF    x9A.7
08A2:  MOVFF  8E,99
08A6:  MOVFF  8F,98
08AA:  CLRF   x97
08AC:  BCF    FD8.0
08AE:  RRCF   x9A,F
08B0:  RRCF   x99,F
08B2:  RRCF   x98,F
08B4:  RRCF   x97,F
08B6:  DECFSZ x94,F
08B8:  BRA    08AA
08BA:  BTFSS  x95.7
08BC:  BRA    08C4
08BE:  BSF    x96.1
08C0:  BRA    09F6
08C2:  BCF    x96.1
08C4:  BCF    x94.0
08C6:  BSF    x96.5
08C8:  CLRF   FEA
08CA:  MOVLW  93
08CC:  MOVWF  FE9
08CE:  BRA    0A1C
08D0:  BCF    x96.5
08D2:  BTFSC  x95.7
08D4:  BRA    08EA
08D6:  BTFSS  x94.0
08D8:  BRA    0900
08DA:  RRCF   x9A,F
08DC:  RRCF   x99,F
08DE:  RRCF   x98,F
08E0:  RRCF   x97,F
08E2:  INCF   00,F
08E4:  BTFSC  FD8.2
08E6:  BRA    09EC
08E8:  BRA    0900
08EA:  BTFSC  x9A.7
08EC:  BRA    0906
08EE:  BCF    FD8.0
08F0:  RLCF   x97,F
08F2:  RLCF   x98,F
08F4:  RLCF   x99,F
08F6:  RLCF   x9A,F
08F8:  DECF   00,F
08FA:  BTFSC  FD8.2
08FC:  BRA    09EC
08FE:  BRA    08EA
0900:  BSF    x96.7
0902:  BRA    0954
0904:  BCF    x96.7
0906:  MOVFF  91,95
090A:  BTFSS  x91.7
090C:  BRA    0912
090E:  BSF    x9A.7
0910:  BRA    09DE
0912:  BCF    x9A.7
0914:  BRA    09DE
0916:  MOVFF  91,9A
091A:  BSF    x9A.7
091C:  MOVFF  92,99
0920:  MOVFF  93,98
0924:  BTFSS  x95.7
0926:  BRA    0930
0928:  BCF    x9A.7
092A:  BSF    x96.2
092C:  BRA    09F6
092E:  BCF    x96.2
0930:  CLRF   x97
0932:  BCF    x94.0
0934:  CLRF   FEA
0936:  MOVLW  8F
0938:  MOVWF  FE9
093A:  BRA    0A1C
093C:  BTFSC  x95.7
093E:  BRA    0978
0940:  MOVFF  8D,95
0944:  BTFSS  x94.0
0946:  BRA    0954
0948:  RRCF   x9A,F
094A:  RRCF   x99,F
094C:  RRCF   x98,F
094E:  RRCF   x97,F
0950:  INCF   00,F
0952:  BZ    09EC
0954:  BTFSS  x97.7
0956:  BRA    096E
0958:  INCF   x98,F
095A:  BNZ   096E
095C:  INCF   x99,F
095E:  BNZ   096E
0960:  INCF   x9A,F
0962:  BNZ   096E
0964:  RRCF   x9A,F
0966:  RRCF   x99,F
0968:  RRCF   x98,F
096A:  INCF   00,F
096C:  BZ    09EC
096E:  BTFSC  x96.6
0970:  BRA    087E
0972:  BTFSC  x96.7
0974:  BRA    0904
0976:  BRA    09B0
0978:  MOVLW  80
097A:  XORWF  x9A,F
097C:  BTFSS  x9A.7
097E:  BRA    0988
0980:  BRA    09F6
0982:  MOVFF  91,95
0986:  BRA    099C
0988:  MOVFF  8D,95
098C:  MOVF   x9A,F
098E:  BNZ   099C
0990:  MOVF   x99,F
0992:  BNZ   099C
0994:  MOVF   x98,F
0996:  BNZ   099C
0998:  CLRF   00
099A:  BRA    09DE
099C:  BTFSC  x9A.7
099E:  BRA    09B0
09A0:  BCF    FD8.0
09A2:  RLCF   x97,F
09A4:  RLCF   x98,F
09A6:  RLCF   x99,F
09A8:  RLCF   x9A,F
09AA:  DECFSZ 00,F
09AC:  BRA    099C
09AE:  BRA    09EC
09B0:  BTFSS  x95.7
09B2:  BRA    09B8
09B4:  BSF    x9A.7
09B6:  BRA    09DE
09B8:  BCF    x9A.7
09BA:  BRA    09DE
09BC:  MOVFF  90,00
09C0:  MOVFF  91,9A
09C4:  MOVFF  92,99
09C8:  MOVFF  93,98
09CC:  BRA    09DE
09CE:  MOVFF  8C,00
09D2:  MOVFF  8D,9A
09D6:  MOVFF  8E,99
09DA:  MOVFF  8F,98
09DE:  MOVFF  9A,01
09E2:  MOVFF  99,02
09E6:  MOVFF  98,03
09EA:  BRA    0A54
09EC:  CLRF   00
09EE:  CLRF   01
09F0:  CLRF   02
09F2:  CLRF   03
09F4:  BRA    0A54
09F6:  CLRF   x97
09F8:  COMF   x98,F
09FA:  COMF   x99,F
09FC:  COMF   x9A,F
09FE:  COMF   x97,F
0A00:  INCF   x97,F
0A02:  BNZ   0A0E
0A04:  INCF   x98,F
0A06:  BNZ   0A0E
0A08:  INCF   x99,F
0A0A:  BNZ   0A0E
0A0C:  INCF   x9A,F
0A0E:  BTFSC  x96.0
0A10:  BRA    083C
0A12:  BTFSC  x96.1
0A14:  BRA    08C2
0A16:  BTFSC  x96.2
0A18:  BRA    092E
0A1A:  BRA    0982
0A1C:  MOVF   FEF,W
0A1E:  ADDWF  x98,F
0A20:  BNC   0A2C
0A22:  INCF   x99,F
0A24:  BNZ   0A2C
0A26:  INCF   x9A,F
0A28:  BTFSC  FD8.2
0A2A:  BSF    x94.0
0A2C:  MOVF   FED,F
0A2E:  MOVF   FEF,W
0A30:  ADDWF  x99,F
0A32:  BNC   0A3A
0A34:  INCF   x9A,F
0A36:  BTFSC  FD8.2
0A38:  BSF    x94.0
0A3A:  MOVF   FED,F
0A3C:  MOVF   FEF,W
0A3E:  BTFSC  FEF.7
0A40:  BRA    0A44
0A42:  XORLW  80
0A44:  ADDWF  x9A,F
0A46:  BTFSC  FD8.0
0A48:  BSF    x94.0
0A4A:  BTFSC  x96.4
0A4C:  BRA    084A
0A4E:  BTFSC  x96.5
0A50:  BRA    08D0
0A52:  BRA    093C
0A54:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
*
00EC:  CLRF   FEA
00EE:  MOVLW  6D
00F0:  MOVWF  FE9
00F2:  MOVF   FEF,W
00F4:  BZ    0112
00F6:  MOVLW  0F
00F8:  MOVWF  01
00FA:  CLRF   00
00FC:  DECFSZ 00,F
00FE:  BRA    00FC
0100:  DECFSZ 01,F
0102:  BRA    00FA
0104:  MOVLW  8F
0106:  MOVWF  00
0108:  DECFSZ 00,F
010A:  BRA    0108
010C:  NOP   
010E:  DECFSZ FEF,F
0110:  BRA    00F6
0112:  RETURN 0
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
0114:  MOVLW  08
0116:  MOVWF  01
0118:  MOVLW  11
011A:  MOVWF  00
011C:  DECFSZ 00,F
011E:  BRA    011C
0120:  BCF    F8C.7
0122:  BCF    F95.7
0124:  MOVLW  11
0126:  MOVWF  00
0128:  DECFSZ 00,F
012A:  BRA    0128
012C:  RLCF   x71,F
012E:  BCF    F8C.6
0130:  BTFSC  FD8.0
0132:  BSF    F95.6
0134:  BTFSS  FD8.0
0136:  BCF    F95.6
0138:  BSF    F95.7
013A:  BTFSS  F83.7
013C:  BRA    013A
013E:  DECFSZ 01,F
0140:  BRA    0118
0142:  MOVLW  11
0144:  MOVWF  00
0146:  DECFSZ 00,F
0148:  BRA    0146
014A:  BCF    F8C.7
014C:  BCF    F95.7
014E:  NOP   
0150:  BSF    F95.6
0152:  MOVLW  11
0154:  MOVWF  00
0156:  DECFSZ 00,F
0158:  BRA    0156
015A:  MOVLW  11
015C:  MOVWF  00
015E:  DECFSZ 00,F
0160:  BRA    015E
0162:  BSF    F95.7
0164:  BTFSS  F83.7
0166:  BRA    0164
0168:  CLRF   01
016A:  MOVLW  11
016C:  MOVWF  00
016E:  DECFSZ 00,F
0170:  BRA    016E
0172:  BTFSC  F83.6
0174:  BSF    01.0
0176:  BCF    F8C.7
0178:  BCF    F95.7
017A:  BCF    F8C.6
017C:  BCF    F95.6
017E:  RETURN 0
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
....................         delay_us(20); 
....................         i2c_write(LCD_ADDR); //the slave addresse 
....................         delay_us(20); 
....................         i2c_write(data); 
....................         delay_us(20); 
....................         i2c_stop(); 
....................         delay_us(20); 
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
....................         i2c_send_nibble(data); 
....................         data=data-4;       //toggle EN back to 0 
....................         i2c_send_nibble(data); 
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
....................     lcd_send_byte(0x10); 
....................     delay_ms(2); 
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x30); 
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x20); 
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
....................         lcd_send_byte(0x80); 
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0xC0); 
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x60); 
....................            //clears the display 
....................         lcd_clear(); 
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
....................       case 2:  address= lcd_line_two;     break; 
....................       case 3:  address= lcd_line_three;   break; 
....................       case 4:  address= lcd_line_four;    break; 
....................       default: address= lcd_line_one;     break;  
....................    } 
....................   
....................    address+=x-1; 
....................    data=address&0xF0; 
....................    lcd_send_byte(data); 
....................    data=address&0x0F; 
....................    data=data<<4; 
....................    lcd_send_byte(data); 
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
....................      case '\1': lcd_gotoxy(1,1);  break; 
....................      case '\2': lcd_gotoxy(1,2);  break; 
....................      case '\3': lcd_gotoxy(1,3);  break; 
....................      case '\4': lcd_gotoxy(1,4);  break; 
....................  
....................      default: 
....................         data=in_data&0xF0; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................         data=in_data&0x0F; 
....................         data=data<<4; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................      break; 
....................    } 
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
....................  
.................... const long carga= 0xE8AB; 
.................... extern int contador; 
.................... extern long pulso_timer; 
....................  
.................... void inicializar(); 
....................  
.................... void main() 
*
18B2:  CLRF   FF8
18B4:  BCF    FD0.7
18B6:  BSF    07.7
18B8:  BSF    20.0
18BA:  CLRF   24
18BC:  CLRF   23
18BE:  BSF    20.0
18C0:  BSF    20.0
18C2:  BRA    1902
18C4:  DATA 02,00
18C6:  DATA 19,00
18C8:  DATA 00,02
18CA:  DATA 00,21
18CC:  DATA 00,00
18CE:  DATA 01,00
18D0:  DATA 22,00
18D2:  DATA 01,00
18D4:  DATA 25,00
18D6:  DATA 01,00
18D8:  DATA 25,00
18DA:  DATA 01,0F
18DC:  DATA B4,07
18DE:  DATA 01,00
18E0:  DATA 34,14
18E2:  DATA 01,00
18E4:  DATA 34,14
18E6:  DATA 04,00
18E8:  DATA 51,00
18EA:  DATA 00,00
18EC:  DATA 00,08
18EE:  DATA 40,51
18F0:  DATA 00,08
18F2:  DATA 40,55
18F4:  DATA 00,05
18F6:  DATA 40,59
18F8:  DATA 00,01
18FA:  DATA 00,5D
18FC:  DATA 00,01
18FE:  DATA 00,26
1900:  DATA 00,00
1902:  MOVLW  00
1904:  MOVWF  FF8
1906:  MOVLW  18
1908:  MOVWF  FF7
190A:  MOVLW  C4
190C:  MOVWF  FF6
190E:  TBLRD*+
1910:  MOVF   FF5,W
1912:  MOVWF  00
1914:  XORLW  00
1916:  BZ    193E
1918:  TBLRD*+
191A:  MOVF   FF5,W
191C:  MOVWF  01
191E:  BTFSC  FE8.7
1920:  BRA    192C
1922:  ANDLW  0F
1924:  MOVWF  FEA
1926:  TBLRD*+
1928:  MOVFF  FF5,FE9
192C:  BTFSC  01.6
192E:  TBLRD*+
1930:  BTFSS  01.6
1932:  TBLRD*+
1934:  MOVFF  FF5,FEE
1938:  DCFSNZ 00,F
193A:  BRA    190E
193C:  BRA    1930
193E:  CLRF   FF8
.................... { 
....................  
.................... //declaracion de variables 
.................... //inicializacion de perifericos 
....................  
.................... 	inicializar() ; 
1940:  GOTO   0370
....................      
....................     set_timer1(carga); 
1944:  MOVLW  E8
1946:  MOVWF  FCF
1948:  MOVLW  AB
194A:  MOVWF  FCE
.................... 	while(1) 
.................... 	{ 
....................  
.................... 		maquina_estado(); 
194C:  BRA    11C6
194E:  BRA    194C
....................  
.................... 	} 
.................... } 
....................  
1950:  SLEEP 
.................... void Inicializar(){ 
....................     setup_timer_1( T1_INTERNAL|T1_DIV_BY_2); 
*
0370:  MOVLW  95
0372:  MOVWF  FCD
....................     setup_timer_0(T0_INTERNAL |T0_DIV_32); 
0374:  MOVLW  84
0376:  MOVWF  FD5
....................     set_timer0(0x0000); 
0378:  CLRF   FD7
037A:  CLRF   FD6
....................     set_tris_a(0xE8);// configuracion portA necesaria para la libreria control_ADC 
037C:  MOVLW  E8
037E:  MOVWF  F92
....................     set_tris_b(0xFF); 
0380:  MOVLW  FF
0382:  MOVWF  F93
....................     contador=0; 
0384:  CLRF   22
....................     lcd_init(); 
0386:  BRA    022E
....................     lcd_gotoxy(1,1); 
0388:  MOVLW  01
038A:  MOVWF  x6D
038C:  MOVWF  x6E
038E:  RCALL  028A
....................     printf(LCD_PUTC,"Primer prueba"); 
0390:  MOVLW  AE
0392:  MOVWF  FF6
0394:  MOVLW  00
0396:  MOVWF  FF7
0398:  BRA    034E
....................     lcd_backlight=ON; 
039A:  BSF    20.0
....................     enable_interrupts (INT_TIMER1); 
039C:  BSF    F9D.0
....................     enable_interrupts (GLOBAL); 
039E:  MOVLW  C0
03A0:  IORWF  FF2,F
....................     output_high (PIN_A0); //pone en alto el chipselect del AD7450 
03A2:  BSF    F89.0
....................     output_high (PIN_A1); // pone en alto el chipselect del MAX186 
03A4:  BSF    F89.1
03A6:  GOTO   1944 (RETURN)
.................... } 
....................  
....................  
.................... /** 
.................... *	\file funciones.c 
.................... *	\brief  
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
00CC:  DATA 45,6E
00CE:  DATA 65,72
00D0:  DATA 20,5B
00D2:  DATA 6B,57
00D4:  DATA 68,5D
00D6:  DATA 3D,20
00D8:  DATA 25,66
00DA:  DATA 20,57
00DC:  DATA 00,00
00DE:  DATA 54,3D
00E0:  DATA 25,66
00E2:  DATA 20,20
00E4:  DATA 49,3D
00E6:  DATA 25,66
00E8:  DATA 20,20
00EA:  DATA 00,00
*
0520:  MOVLW  8E
0522:  MOVWF  00
0524:  MOVFF  5F,01
0528:  MOVFF  5E,02
052C:  CLRF   03
052E:  BTFSS  5F.7
0530:  BRA    053C
0532:  COMF   01,F
0534:  COMF   02,F
0536:  INCF   02,F
0538:  BNZ   053C
053A:  INCF   01,F
053C:  MOVF   01,F
053E:  BNZ   0552
0540:  MOVFF  02,01
0544:  CLRF   02
0546:  MOVLW  08
0548:  SUBWF  00,F
054A:  MOVF   01,F
054C:  BNZ   0552
054E:  CLRF   00
0550:  BRA    0566
0552:  BCF    FD8.0
0554:  BTFSC  01.7
0556:  BRA    0560
0558:  RLCF   02,F
055A:  RLCF   01,F
055C:  DECF   00,F
055E:  BRA    0552
0560:  BTFSC  5F.7
0562:  BRA    0566
0564:  BCF    01.7
0566:  GOTO   1208 (RETURN)
*
0A56:  MOVFF  89,90
0A5A:  MOVF   x8D,W
0A5C:  XORWF  x90,F
0A5E:  BTFSS  x90.7
0A60:  BRA    0A6C
0A62:  BCF    FD8.2
0A64:  BCF    FD8.0
0A66:  BTFSC  x89.7
0A68:  BSF    FD8.0
0A6A:  BRA    0ACA
0A6C:  MOVFF  89,90
0A70:  MOVFF  8C,91
0A74:  MOVF   x88,W
0A76:  SUBWF  x91,F
0A78:  BZ    0A86
0A7A:  BTFSS  x90.7
0A7C:  BRA    0ACA
0A7E:  MOVF   FD8,W
0A80:  XORLW  01
0A82:  MOVWF  FD8
0A84:  BRA    0ACA
0A86:  MOVFF  8D,91
0A8A:  MOVF   x89,W
0A8C:  SUBWF  x91,F
0A8E:  BZ    0A9C
0A90:  BTFSS  x90.7
0A92:  BRA    0ACA
0A94:  MOVF   FD8,W
0A96:  XORLW  01
0A98:  MOVWF  FD8
0A9A:  BRA    0ACA
0A9C:  MOVFF  8E,91
0AA0:  MOVF   x8A,W
0AA2:  SUBWF  x91,F
0AA4:  BZ    0AB2
0AA6:  BTFSS  x90.7
0AA8:  BRA    0ACA
0AAA:  MOVF   FD8,W
0AAC:  XORLW  01
0AAE:  MOVWF  FD8
0AB0:  BRA    0ACA
0AB2:  MOVFF  8F,91
0AB6:  MOVF   x8B,W
0AB8:  SUBWF  x91,F
0ABA:  BZ    0AC8
0ABC:  BTFSS  x90.7
0ABE:  BRA    0ACA
0AC0:  MOVF   FD8,W
0AC2:  XORLW  01
0AC4:  MOVWF  FD8
0AC6:  BRA    0ACA
0AC8:  BCF    FD8.0
0ACA:  RETURN 0
*
0BD6:  MOVLW  8E
0BD8:  MOVWF  00
0BDA:  MOVF   x88,W
0BDC:  SUBWF  00,F
0BDE:  MOVFF  89,02
0BE2:  MOVFF  8A,01
0BE6:  BSF    02.7
0BE8:  MOVF   00,F
0BEA:  BZ    0BFE
0BEC:  BCF    FD8.0
0BEE:  MOVF   02,F
0BF0:  BNZ   0BF6
0BF2:  MOVF   01,F
0BF4:  BZ    0BFE
0BF6:  RRCF   02,F
0BF8:  RRCF   01,F
0BFA:  DECFSZ 00,F
0BFC:  BRA    0BEC
0BFE:  BTFSS  x89.7
0C00:  BRA    0C0C
0C02:  COMF   01,F
0C04:  COMF   02,F
0C06:  INCF   01,F
0C08:  BTFSC  FD8.2
0C0A:  INCF   02,F
0C0C:  GOTO   0CBC (RETURN)
*
0F56:  TBLRD*+
0F58:  MOVFF  FF6,5F
0F5C:  MOVFF  FF7,60
0F60:  MOVFF  FF5,6C
0F64:  CALL   02E0
0F68:  MOVFF  5F,FF6
0F6C:  MOVFF  60,FF7
0F70:  DECFSZ 5E,F
0F72:  BRA    0F56
0F74:  RETURN 0
0F76:  MOVF   x6B,W
0F78:  SUBLW  B6
0F7A:  MOVWF  x6B
0F7C:  CLRF   03
0F7E:  MOVFF  6C,6F
0F82:  BSF    x6C.7
0F84:  BCF    FD8.0
0F86:  RRCF   x6C,F
0F88:  RRCF   x6D,F
0F8A:  RRCF   x6E,F
0F8C:  RRCF   03,F
0F8E:  RRCF   02,F
0F90:  RRCF   01,F
0F92:  RRCF   00,F
0F94:  DECFSZ x6B,F
0F96:  BRA    0F84
0F98:  BTFSS  x6F.7
0F9A:  BRA    0FB2
0F9C:  COMF   00,F
0F9E:  COMF   01,F
0FA0:  COMF   02,F
0FA2:  COMF   03,F
0FA4:  INCF   00,F
0FA6:  BTFSC  FD8.2
0FA8:  INCF   01,F
0FAA:  BTFSC  FD8.2
0FAC:  INCF   02,F
0FAE:  BTFSC  FD8.2
0FB0:  INCF   03,F
0FB2:  GOTO   1094 (RETURN)
0FB6:  BTFSC  FD8.1
0FB8:  BRA    0FC0
0FBA:  CLRF   FEA
0FBC:  MOVLW  73
0FBE:  MOVWF  FE9
0FC0:  CLRF   00
0FC2:  CLRF   01
0FC4:  CLRF   02
0FC6:  CLRF   03
0FC8:  CLRF   x73
0FCA:  CLRF   x74
0FCC:  CLRF   x75
0FCE:  CLRF   x76
0FD0:  MOVF   x72,W
0FD2:  IORWF  x71,W
0FD4:  IORWF  x70,W
0FD6:  IORWF  x6F,W
0FD8:  BZ    1032
0FDA:  MOVLW  20
0FDC:  MOVWF  x77
0FDE:  BCF    FD8.0
0FE0:  RLCF   x6B,F
0FE2:  RLCF   x6C,F
0FE4:  RLCF   x6D,F
0FE6:  RLCF   x6E,F
0FE8:  RLCF   x73,F
0FEA:  RLCF   x74,F
0FEC:  RLCF   x75,F
0FEE:  RLCF   x76,F
0FF0:  MOVF   x72,W
0FF2:  SUBWF  x76,W
0FF4:  BNZ   1006
0FF6:  MOVF   x71,W
0FF8:  SUBWF  x75,W
0FFA:  BNZ   1006
0FFC:  MOVF   x70,W
0FFE:  SUBWF  x74,W
1000:  BNZ   1006
1002:  MOVF   x6F,W
1004:  SUBWF  x73,W
1006:  BNC   1026
1008:  MOVF   x6F,W
100A:  SUBWF  x73,F
100C:  MOVF   x70,W
100E:  BTFSS  FD8.0
1010:  INCFSZ x70,W
1012:  SUBWF  x74,F
1014:  MOVF   x71,W
1016:  BTFSS  FD8.0
1018:  INCFSZ x71,W
101A:  SUBWF  x75,F
101C:  MOVF   x72,W
101E:  BTFSS  FD8.0
1020:  INCFSZ x72,W
1022:  SUBWF  x76,F
1024:  BSF    FD8.0
1026:  RLCF   00,F
1028:  RLCF   01,F
102A:  RLCF   02,F
102C:  RLCF   03,F
102E:  DECFSZ x77,F
1030:  BRA    0FDE
1032:  MOVFF  73,FEF
1036:  MOVFF  74,FEC
103A:  MOVFF  75,FEC
103E:  MOVFF  76,FEC
1042:  RETURN 0
1044:  MOVF   FE9,W
1046:  MOVWF  x63
1048:  MOVF   x62,W
104A:  MOVWF  x65
104C:  BZ    1082
104E:  MOVFF  61,8F
1052:  MOVFF  60,8E
1056:  MOVFF  5F,8D
105A:  MOVFF  5E,8C
105E:  CLRF   x93
1060:  CLRF   x92
1062:  MOVLW  20
1064:  MOVWF  x91
1066:  MOVLW  82
1068:  MOVWF  x90
106A:  CALL   05A0
106E:  MOVFF  03,61
1072:  MOVFF  02,60
1076:  MOVFF  01,5F
107A:  MOVFF  00,5E
107E:  DECFSZ x65,F
1080:  BRA    104E
1082:  MOVFF  61,6E
1086:  MOVFF  60,6D
108A:  MOVFF  5F,6C
108E:  MOVFF  5E,6B
1092:  BRA    0F76
1094:  MOVFF  03,61
1098:  MOVFF  02,60
109C:  MOVFF  01,5F
10A0:  MOVFF  00,5E
10A4:  BTFSS  x61.7
10A6:  BRA    10C2
10A8:  DECF   x63,F
10AA:  BSF    x63.5
10AC:  COMF   5E,F
10AE:  COMF   5F,F
10B0:  COMF   x60,F
10B2:  COMF   x61,F
10B4:  INCF   5E,F
10B6:  BTFSC  FD8.2
10B8:  INCF   5F,F
10BA:  BTFSC  FD8.2
10BC:  INCF   x60,F
10BE:  BTFSC  FD8.2
10C0:  INCF   x61,F
10C2:  MOVLW  3B
10C4:  MOVWF  x6A
10C6:  MOVLW  9A
10C8:  MOVWF  x69
10CA:  MOVLW  CA
10CC:  MOVWF  x68
10CE:  CLRF   x67
10D0:  MOVLW  0A
10D2:  MOVWF  x65
10D4:  MOVF   x62,W
10D6:  BTFSC  FD8.2
10D8:  INCF   x63,F
10DA:  BSF    FD8.1
10DC:  CLRF   FEA
10DE:  MOVLW  5E
10E0:  MOVWF  FE9
10E2:  MOVFF  61,6E
10E6:  MOVFF  60,6D
10EA:  MOVFF  5F,6C
10EE:  MOVFF  5E,6B
10F2:  MOVFF  6A,72
10F6:  MOVFF  69,71
10FA:  MOVFF  68,70
10FE:  MOVFF  67,6F
1102:  RCALL  0FB6
1104:  MOVF   01,W
1106:  MOVF   00,F
1108:  BNZ   1128
110A:  INCF   x62,W
110C:  SUBWF  x65,W
110E:  BZ    1128
1110:  MOVF   x63,W
1112:  BZ    112C
1114:  ANDLW  0F
1116:  SUBWF  x65,W
1118:  BZ    111C
111A:  BC    1192
111C:  BTFSC  x63.7
111E:  BRA    1192
1120:  BTFSC  x63.6
1122:  BRA    112C
1124:  MOVLW  20
1126:  BRA    1188
1128:  MOVLW  20
112A:  ANDWF  x63,F
112C:  BTFSS  x63.5
112E:  BRA    114A
1130:  BCF    x63.5
1132:  MOVF   x62,W
1134:  BTFSS  FD8.2
1136:  DECF   x63,F
1138:  MOVF   00,W
113A:  MOVWF  x63
113C:  MOVLW  2D
113E:  MOVWF  x6C
1140:  CALL   02E0
1144:  MOVF   x63,W
1146:  MOVWF  00
1148:  CLRF   x63
114A:  MOVF   x62,W
114C:  SUBWF  x65,W
114E:  BNZ   1166
1150:  MOVF   00,W
1152:  MOVWF  x63
1154:  MOVLW  2E
1156:  MOVWF  x6C
1158:  CALL   02E0
115C:  MOVF   x63,W
115E:  MOVWF  00
1160:  MOVLW  20
1162:  ANDWF  x63,F
1164:  MOVLW  00
1166:  MOVLW  30
1168:  BTFSS  x63.5
116A:  BRA    1188
116C:  BCF    x63.5
116E:  MOVF   x62,W
1170:  BTFSS  FD8.2
1172:  DECF   x63,F
1174:  MOVF   00,W
1176:  MOVWF  x63
1178:  MOVLW  2D
117A:  MOVWF  x6C
117C:  CALL   02E0
1180:  MOVF   x63,W
1182:  MOVWF  00
1184:  CLRF   x63
1186:  MOVLW  30
1188:  ADDWF  00,F
118A:  MOVFF  00,6C
118E:  CALL   02E0
1192:  BCF    FD8.1
1194:  MOVFF  6A,6E
1198:  MOVFF  69,6D
119C:  MOVFF  68,6C
11A0:  MOVFF  67,6B
11A4:  CLRF   x72
11A6:  CLRF   x71
11A8:  CLRF   x70
11AA:  MOVLW  0A
11AC:  MOVWF  x6F
11AE:  RCALL  0FB6
11B0:  MOVFF  03,6A
11B4:  MOVFF  02,69
11B8:  MOVFF  01,68
11BC:  MOVFF  00,67
11C0:  DECFSZ x65,F
11C2:  BRA    10DA
11C4:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
.................... int contador = 0 ;int pulso_timer = 0 ; 
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
0ACC:  MOVFF  65,8B
0AD0:  MOVFF  64,8A
0AD4:  MOVFF  63,89
0AD8:  MOVFF  62,88
0ADC:  CLRF   x8F
0ADE:  CLRF   x8E
0AE0:  CLRF   x8D
0AE2:  CLRF   x8C
0AE4:  RCALL  0A56
0AE6:  BC    0AEA
0AE8:  BNZ   0AF4
....................       return(0.0); 
0AEA:  CLRF   00
0AEC:  CLRF   01
0AEE:  CLRF   02
0AF0:  CLRF   03
0AF2:  BRA    0BD4
....................  
....................    y=x; 
0AF4:  MOVFF  65,69
0AF8:  MOVFF  64,68
0AFC:  MOVFF  63,67
0B00:  MOVFF  62,66
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
0B04:  CLRF   x6F
0B06:  MOVLW  66
0B08:  MOVWF  x6E
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
0B0A:  MOVFF  6E,FE9
0B0E:  MOVFF  6F,FEA
0B12:  MOVF   FEF,W
0B14:  CLRF   x73
0B16:  MOVWF  x72
0B18:  MOVLW  7F
0B1A:  ADDWF  x72,F
0B1C:  MOVLW  00
0B1E:  ADDWFC x73,F
0B20:  BCF    FD8.0
0B22:  RRCF   x73,W
0B24:  RRCF   x72,W
0B26:  MOVFF  6F,FEA
0B2A:  MOVFF  6E,FE9
0B2E:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0B30:  MOVFF  69,6D
0B34:  MOVFF  68,6C
0B38:  MOVFF  67,6B
0B3C:  MOVFF  66,6A
....................       y+=(x/y); 
0B40:  MOVFF  65,73
0B44:  MOVFF  64,72
0B48:  MOVFF  63,71
0B4C:  MOVFF  62,70
0B50:  MOVFF  69,77
0B54:  MOVFF  68,76
0B58:  MOVFF  67,75
0B5C:  MOVFF  66,74
0B60:  RCALL  0692
0B62:  BCF    FD8.1
0B64:  MOVFF  69,8F
0B68:  MOVFF  68,8E
0B6C:  MOVFF  67,8D
0B70:  MOVFF  66,8C
0B74:  MOVFF  03,93
0B78:  MOVFF  02,92
0B7C:  MOVFF  01,91
0B80:  MOVFF  00,90
0B84:  RCALL  07EC
0B86:  MOVFF  03,69
0B8A:  MOVFF  02,68
0B8E:  MOVFF  01,67
0B92:  MOVFF  00,66
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
0B96:  MOVFF  6E,FE9
0B9A:  MOVFF  6F,FEA
0B9E:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
0BA0:  MOVFF  6D,8B
0BA4:  MOVFF  6C,8A
0BA8:  MOVFF  6B,89
0BAC:  MOVFF  6A,88
0BB0:  MOVFF  69,8F
0BB4:  MOVFF  68,8E
0BB8:  MOVFF  67,8D
0BBC:  MOVFF  66,8C
0BC0:  RCALL  0A56
0BC2:  BNZ   0B30
....................  
....................    return(res); 
0BC4:  MOVFF  6A,00
0BC8:  MOVFF  6B,01
0BCC:  MOVFF  6C,02
0BD0:  MOVFF  6D,03
0BD4:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
0C10:  CLRF   x6D
0C12:  CLRF   x6C
0C14:  CLRF   x6B
0C16:  MOVLW  7F
0C18:  MOVWF  x6A
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
0C1A:  MOVLW  7E
0C1C:  MOVWF  x74
0C1E:  MOVLW  80
0C20:  MOVWF  x75
0C22:  CLRF   x76
0C24:  CLRF   x77
0C26:  MOVLW  7A
0C28:  MOVWF  x78
0C2A:  MOVLW  2A
0C2C:  MOVWF  x79
0C2E:  MOVLW  AA
0C30:  MOVWF  x7A
0C32:  MOVLW  A3
0C34:  MOVWF  x7B
0C36:  MOVLW  75
0C38:  MOVWF  x7C
0C3A:  MOVLW  B6
0C3C:  MOVWF  x7D
0C3E:  MOVLW  09
0C40:  MOVWF  x7E
0C42:  MOVLW  B4
0C44:  MOVWF  x7F
0C46:  MOVLW  6F
0C48:  MOVWF  x80
0C4A:  MOVLW  4F
0C4C:  MOVWF  x81
0C4E:  MOVLW  B6
0C50:  MOVWF  x82
0C52:  MOVLW  AA
0C54:  MOVWF  x83
0C56:  MOVLW  69
0C58:  MOVWF  x84
0C5A:  MOVLW  8B
0C5C:  MOVWF  x85
0C5E:  MOVLW  F6
0C60:  MOVWF  x86
0C62:  MOVLW  E8
0C64:  MOVWF  x87
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0C66:  MOVFF  61,8B
0C6A:  MOVFF  60,8A
0C6E:  MOVFF  5F,89
0C72:  MOVFF  5E,88
0C76:  CLRF   x8F
0C78:  CLRF   x8E
0C7A:  CLRF   x8D
0C7C:  CLRF   x8C
0C7E:  RCALL  0A56
0C80:  BNC   0C88
0C82:  MOVF   5F,W
0C84:  XORLW  80
0C86:  MOVWF  5F
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0C88:  MOVFF  61,8F
0C8C:  MOVFF  60,8E
0C90:  MOVFF  5F,8D
0C94:  MOVFF  5E,8C
0C98:  MOVLW  83
0C9A:  MOVWF  x93
0C9C:  MOVLW  F9
0C9E:  MOVWF  x92
0CA0:  MOVLW  22
0CA2:  MOVWF  x91
0CA4:  MOVLW  7E
0CA6:  MOVWF  x90
0CA8:  RCALL  05A0
0CAA:  MOVFF  03,8B
0CAE:  MOVFF  02,8A
0CB2:  MOVFF  01,89
0CB6:  MOVFF  00,88
0CBA:  BRA    0BD6
0CBC:  MOVFF  01,6E
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0CC0:  MOVFF  61,8F
0CC4:  MOVFF  60,8E
0CC8:  MOVFF  5F,8D
0CCC:  MOVFF  5E,8C
0CD0:  MOVLW  83
0CD2:  MOVWF  x93
0CD4:  MOVLW  F9
0CD6:  MOVWF  x92
0CD8:  MOVLW  22
0CDA:  MOVWF  x91
0CDC:  MOVLW  7E
0CDE:  MOVWF  x90
0CE0:  RCALL  05A0
0CE2:  MOVFF  03,8B
0CE6:  MOVFF  02,8A
0CEA:  MOVFF  01,89
0CEE:  MOVFF  00,88
0CF2:  CLRF   x8D
0CF4:  MOVFF  6E,8C
0CF8:  RCALL  056A
0CFA:  BSF    FD8.1
0CFC:  MOVFF  8B,8F
0D00:  MOVFF  8A,8E
0D04:  MOVFF  89,8D
0D08:  MOVFF  88,8C
0D0C:  MOVFF  03,93
0D10:  MOVFF  02,92
0D14:  MOVFF  01,91
0D18:  MOVFF  00,90
0D1C:  RCALL  07EC
0D1E:  MOVFF  03,73
0D22:  MOVFF  02,72
0D26:  MOVFF  01,71
0D2A:  MOVFF  00,70
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0D2E:  MOVLW  03
0D30:  ANDWF  x6E,F
....................  
....................    if (quad == 0 || quad == 2) 
0D32:  MOVF   x6E,F
0D34:  BZ    0D3C
0D36:  MOVF   x6E,W
0D38:  SUBLW  02
0D3A:  BNZ   0D70
....................       t = frac * PI_DIV_BY_TWO; 
0D3C:  MOVFF  73,8F
0D40:  MOVFF  72,8E
0D44:  MOVFF  71,8D
0D48:  MOVFF  70,8C
0D4C:  MOVLW  DB
0D4E:  MOVWF  x93
0D50:  MOVLW  0F
0D52:  MOVWF  x92
0D54:  MOVLW  49
0D56:  MOVWF  x91
0D58:  MOVLW  7F
0D5A:  MOVWF  x90
0D5C:  RCALL  05A0
0D5E:  MOVFF  03,69
0D62:  MOVFF  02,68
0D66:  MOVFF  01,67
0D6A:  MOVFF  00,66
0D6E:  BRA    0E3A
....................    else if (quad == 1) 
0D70:  DECFSZ x6E,W
0D72:  BRA    0DD8
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0D74:  BSF    FD8.1
0D76:  CLRF   x8F
0D78:  CLRF   x8E
0D7A:  CLRF   x8D
0D7C:  MOVLW  7F
0D7E:  MOVWF  x8C
0D80:  MOVFF  73,93
0D84:  MOVFF  72,92
0D88:  MOVFF  71,91
0D8C:  MOVFF  70,90
0D90:  RCALL  07EC
0D92:  MOVFF  03,8B
0D96:  MOVFF  02,8A
0D9A:  MOVFF  01,89
0D9E:  MOVFF  00,88
0DA2:  MOVFF  03,8F
0DA6:  MOVFF  02,8E
0DAA:  MOVFF  01,8D
0DAE:  MOVFF  00,8C
0DB2:  MOVLW  DB
0DB4:  MOVWF  x93
0DB6:  MOVLW  0F
0DB8:  MOVWF  x92
0DBA:  MOVLW  49
0DBC:  MOVWF  x91
0DBE:  MOVLW  7F
0DC0:  MOVWF  x90
0DC2:  CALL   05A0
0DC6:  MOVFF  03,69
0DCA:  MOVFF  02,68
0DCE:  MOVFF  01,67
0DD2:  MOVFF  00,66
0DD6:  BRA    0E3A
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0DD8:  BSF    FD8.1
0DDA:  MOVFF  73,8F
0DDE:  MOVFF  72,8E
0DE2:  MOVFF  71,8D
0DE6:  MOVFF  70,8C
0DEA:  CLRF   x93
0DEC:  CLRF   x92
0DEE:  CLRF   x91
0DF0:  MOVLW  7F
0DF2:  MOVWF  x90
0DF4:  RCALL  07EC
0DF6:  MOVFF  03,8B
0DFA:  MOVFF  02,8A
0DFE:  MOVFF  01,89
0E02:  MOVFF  00,88
0E06:  MOVFF  03,8F
0E0A:  MOVFF  02,8E
0E0E:  MOVFF  01,8D
0E12:  MOVFF  00,8C
0E16:  MOVLW  DB
0E18:  MOVWF  x93
0E1A:  MOVLW  0F
0E1C:  MOVWF  x92
0E1E:  MOVLW  49
0E20:  MOVWF  x91
0E22:  MOVLW  7F
0E24:  MOVWF  x90
0E26:  CALL   05A0
0E2A:  MOVFF  03,69
0E2E:  MOVFF  02,68
0E32:  MOVFF  01,67
0E36:  MOVFF  00,66
....................  
....................    y = 1.0; 
0E3A:  CLRF   x65
0E3C:  CLRF   x64
0E3E:  CLRF   x63
0E40:  MOVLW  7F
0E42:  MOVWF  x62
....................    t = t * t; 
0E44:  MOVFF  69,8F
0E48:  MOVFF  68,8E
0E4C:  MOVFF  67,8D
0E50:  MOVFF  66,8C
0E54:  MOVFF  69,93
0E58:  MOVFF  68,92
0E5C:  MOVFF  67,91
0E60:  MOVFF  66,90
0E64:  CALL   05A0
0E68:  MOVFF  03,69
0E6C:  MOVFF  02,68
0E70:  MOVFF  01,67
0E74:  MOVFF  00,66
....................    for (i = 0; i <= 4; i++) 
0E78:  CLRF   x6F
0E7A:  MOVF   x6F,W
0E7C:  SUBLW  04
0E7E:  BNC   0F32
....................    { 
....................       t2 = t2 * t; 
0E80:  MOVFF  6D,8F
0E84:  MOVFF  6C,8E
0E88:  MOVFF  6B,8D
0E8C:  MOVFF  6A,8C
0E90:  MOVFF  69,93
0E94:  MOVFF  68,92
0E98:  MOVFF  67,91
0E9C:  MOVFF  66,90
0EA0:  CALL   05A0
0EA4:  MOVFF  03,6D
0EA8:  MOVFF  02,6C
0EAC:  MOVFF  01,6B
0EB0:  MOVFF  00,6A
....................       y = y + p[i] * t2; 
0EB4:  MOVF   x6F,W
0EB6:  MULLW  04
0EB8:  MOVF   FF3,W
0EBA:  CLRF   03
0EBC:  ADDLW  74
0EBE:  MOVWF  FE9
0EC0:  MOVLW  00
0EC2:  ADDWFC 03,W
0EC4:  MOVWF  FEA
0EC6:  MOVFF  FEF,8C
0ECA:  MOVFF  FEC,8D
0ECE:  MOVFF  FEC,8E
0ED2:  MOVFF  FEC,8F
0ED6:  MOVFF  6D,93
0EDA:  MOVFF  6C,92
0EDE:  MOVFF  6B,91
0EE2:  MOVFF  6A,90
0EE6:  CALL   05A0
0EEA:  MOVFF  FEA,89
0EEE:  MOVFF  FE9,88
0EF2:  BCF    FD8.1
0EF4:  MOVFF  65,8F
0EF8:  MOVFF  64,8E
0EFC:  MOVFF  63,8D
0F00:  MOVFF  62,8C
0F04:  MOVFF  03,93
0F08:  MOVFF  02,92
0F0C:  MOVFF  01,91
0F10:  MOVFF  00,90
0F14:  RCALL  07EC
0F16:  MOVFF  89,FEA
0F1A:  MOVFF  88,FE9
0F1E:  MOVFF  03,65
0F22:  MOVFF  02,64
0F26:  MOVFF  01,63
0F2A:  MOVFF  00,62
0F2E:  INCF   x6F,F
0F30:  BRA    0E7A
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
0F32:  MOVF   x6E,W
0F34:  SUBLW  02
0F36:  BZ    0F3C
0F38:  DECFSZ x6E,W
0F3A:  BRA    0F42
....................       y = -y;  // correct sign 
0F3C:  MOVF   x63,W
0F3E:  XORLW  80
0F40:  MOVWF  x63
....................  
....................    return (y); 
0F42:  MOVFF  62,00
0F46:  MOVFF  63,01
0F4A:  MOVFF  64,02
0F4E:  MOVFF  65,03
0F52:  GOTO   15D2 (RETURN)
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
*
0180:  BSF    F95.6
0182:  MOVLW  11
0184:  MOVWF  00
0186:  DECFSZ 00,F
0188:  BRA    0186
018A:  BSF    F95.7
018C:  MOVLW  11
018E:  MOVWF  00
0190:  DECFSZ 00,F
0192:  BRA    0190
0194:  BCF    F8C.6
0196:  BCF    F95.6
0198:  MOVLW  11
019A:  MOVWF  00
019C:  DECFSZ 00,F
019E:  BRA    019C
01A0:  BCF    F8C.7
01A2:  BCF    F95.7
....................         delay_us(20); 
01A4:  MOVLW  4F
01A6:  MOVWF  00
01A8:  DECFSZ 00,F
01AA:  BRA    01A8
01AC:  BRA    01AE
....................         i2c_write(LCD_ADDR); //the slave addresse 
01AE:  MOVLW  4E
01B0:  MOVWF  x71
01B2:  RCALL  0114
....................         delay_us(20); 
01B4:  MOVLW  4F
01B6:  MOVWF  00
01B8:  DECFSZ 00,F
01BA:  BRA    01B8
01BC:  BRA    01BE
....................         i2c_write(data); 
01BE:  MOVFF  70,71
01C2:  RCALL  0114
....................         delay_us(20); 
01C4:  MOVLW  4F
01C6:  MOVWF  00
01C8:  DECFSZ 00,F
01CA:  BRA    01C8
01CC:  BRA    01CE
....................         i2c_stop(); 
01CE:  BCF    F95.6
01D0:  NOP   
01D2:  BSF    F95.7
01D4:  BTFSS  F83.7
01D6:  BRA    01D4
01D8:  MOVLW  11
01DA:  MOVWF  00
01DC:  DECFSZ 00,F
01DE:  BRA    01DC
01E0:  BRA    01E2
01E2:  NOP   
01E4:  BSF    F95.6
01E6:  MOVLW  11
01E8:  MOVWF  00
01EA:  DECFSZ 00,F
01EC:  BRA    01EA
....................         delay_us(20); 
01EE:  MOVLW  4F
01F0:  MOVWF  00
01F2:  DECFSZ 00,F
01F4:  BRA    01F2
01F6:  BRA    01F8
01F8:  RETURN 0
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
01FA:  BTFSS  20.0
01FC:  BRA    0208
01FE:  MOVF   x6F,W
0200:  IORLW  04
0202:  IORLW  08
0204:  MOVWF  x6F
0206:  BRA    020A
0208:  BSF    x6F.2
....................         i2c_send_nibble(data); 
020A:  MOVFF  6F,70
020E:  RCALL  0180
....................         data=data-4;       //toggle EN back to 0 
0210:  MOVLW  04
0212:  SUBWF  x6F,F
....................         i2c_send_nibble(data); 
0214:  MOVFF  6F,70
0218:  RCALL  0180
021A:  RETURN 0
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
021C:  CLRF   x6F
021E:  RCALL  01FA
....................     lcd_send_byte(0x10); 
0220:  MOVLW  10
0222:  MOVWF  x6F
0224:  RCALL  01FA
....................     delay_ms(2); 
0226:  MOVLW  02
0228:  MOVWF  x6D
022A:  RCALL  00EC
022C:  RETURN 0
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
022E:  MOVLW  C8
0230:  MOVWF  x6D
0232:  RCALL  00EC
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
0234:  CLRF   x6F
0236:  RCALL  01FA
....................         lcd_send_byte(0x10); 
0238:  MOVLW  10
023A:  MOVWF  x6F
023C:  RCALL  01FA
....................         lcd_send_byte(0x00); 
023E:  CLRF   x6F
0240:  RCALL  01FA
....................         lcd_send_byte(0x00); 
0242:  CLRF   x6F
0244:  RCALL  01FA
....................         lcd_send_byte(0x10); 
0246:  MOVLW  10
0248:  MOVWF  x6F
024A:  RCALL  01FA
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
024C:  MOVLW  30
024E:  MOVWF  x6F
0250:  RCALL  01FA
....................         lcd_send_byte(0x30); 
0252:  MOVLW  30
0254:  MOVWF  x6F
0256:  RCALL  01FA
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
0258:  MOVLW  30
025A:  MOVWF  x6F
025C:  RCALL  01FA
....................         lcd_send_byte(0x20); 
025E:  MOVLW  20
0260:  MOVWF  x6F
0262:  RCALL  01FA
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
0264:  MOVLW  20
0266:  MOVWF  x6F
0268:  RCALL  01FA
....................         lcd_send_byte(0x80); 
026A:  MOVLW  80
026C:  MOVWF  x6F
026E:  RCALL  01FA
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
0270:  CLRF   x6F
0272:  RCALL  01FA
....................         lcd_send_byte(0xC0); 
0274:  MOVLW  C0
0276:  MOVWF  x6F
0278:  RCALL  01FA
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
027A:  CLRF   x6F
027C:  RCALL  01FA
....................         lcd_send_byte(0x60); 
027E:  MOVLW  60
0280:  MOVWF  x6F
0282:  RCALL  01FA
....................            //clears the display 
....................         lcd_clear(); 
0284:  RCALL  021C
0286:  GOTO   0388 (RETURN)
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
028A:  MOVF   x6E,W
028C:  XORLW  01
028E:  BZ    029E
0290:  XORLW  03
0292:  BZ    02A4
0294:  XORLW  01
0296:  BZ    02AA
0298:  XORLW  07
029A:  BZ    02B0
029C:  BRA    02B6
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
029E:  MOVLW  80
02A0:  MOVWF  1F
02A2:  BRA    02BA
....................       case 2:  address= lcd_line_two;     break; 
02A4:  MOVLW  C0
02A6:  MOVWF  1F
02A8:  BRA    02BA
....................       case 3:  address= lcd_line_three;   break; 
02AA:  MOVLW  94
02AC:  MOVWF  1F
02AE:  BRA    02BA
....................       case 4:  address= lcd_line_four;    break; 
02B0:  MOVLW  D4
02B2:  MOVWF  1F
02B4:  BRA    02BA
....................       default: address= lcd_line_one;     break;  
02B6:  MOVLW  80
02B8:  MOVWF  1F
....................    } 
....................   
....................    address+=x-1; 
02BA:  MOVLW  01
02BC:  SUBWF  x6D,W
02BE:  ADDWF  1F,F
....................    data=address&0xF0; 
02C0:  MOVF   1F,W
02C2:  ANDLW  F0
02C4:  MOVWF  26
....................    lcd_send_byte(data); 
02C6:  MOVFF  26,6F
02CA:  RCALL  01FA
....................    data=address&0x0F; 
02CC:  MOVF   1F,W
02CE:  ANDLW  0F
02D0:  MOVWF  26
....................    data=data<<4; 
02D2:  SWAPF  26,F
02D4:  MOVLW  F0
02D6:  ANDWF  26,F
....................    lcd_send_byte(data); 
02D8:  MOVFF  26,6F
02DC:  RCALL  01FA
02DE:  RETURN 0
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
02E0:  MOVF   x6C,W
02E2:  XORLW  0C
02E4:  BZ    02F8
02E6:  XORLW  0D
02E8:  BZ    02FC
02EA:  XORLW  03
02EC:  BZ    0306
02EE:  XORLW  01
02F0:  BZ    0312
02F2:  XORLW  07
02F4:  BZ    031E
02F6:  BRA    032A
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
02F8:  RCALL  021C
02FA:  BRA    034C
....................      case '\1': lcd_gotoxy(1,1);  break; 
02FC:  MOVLW  01
02FE:  MOVWF  x6D
0300:  MOVWF  x6E
0302:  RCALL  028A
0304:  BRA    034C
....................      case '\2': lcd_gotoxy(1,2);  break; 
0306:  MOVLW  01
0308:  MOVWF  x6D
030A:  MOVLW  02
030C:  MOVWF  x6E
030E:  RCALL  028A
0310:  BRA    034C
....................      case '\3': lcd_gotoxy(1,3);  break; 
0312:  MOVLW  01
0314:  MOVWF  x6D
0316:  MOVLW  03
0318:  MOVWF  x6E
031A:  RCALL  028A
031C:  BRA    034C
....................      case '\4': lcd_gotoxy(1,4);  break; 
031E:  MOVLW  01
0320:  MOVWF  x6D
0322:  MOVLW  04
0324:  MOVWF  x6E
0326:  RCALL  028A
0328:  BRA    034C
....................  
....................      default: 
....................         data=in_data&0xF0; 
032A:  MOVF   x6C,W
032C:  ANDLW  F0
032E:  MOVWF  x6D
....................         data=data|RS; //set RS pin to 1 
0330:  BSF    x6D.0
....................         lcd_send_byte(data); 
0332:  MOVFF  6D,6F
0336:  RCALL  01FA
....................         data=in_data&0x0F; 
0338:  MOVF   x6C,W
033A:  ANDLW  0F
033C:  MOVWF  x6D
....................         data=data<<4; 
033E:  SWAPF  x6D,F
0340:  MOVLW  F0
0342:  ANDWF  x6D,F
....................         data=data|RS; //set RS pin to 1 
0344:  BSF    x6D.0
....................         lcd_send_byte(data); 
0346:  MOVFF  6D,6F
034A:  RCALL  01FA
....................      break; 
....................    } 
034C:  RETURN 0
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #include <Control_ADCs.h> 
.................... /*  
....................  * File:   MAX191.h 
....................  * Author: MARCOS 
....................  * 
....................  * Created on 23 de septiembre de 2016, 08:14 
....................  */ 
....................  
.................... #ifndef Control_ADCs_H 
.................... #define Control_ADCs_H 
....................  
.................... #define ADC_CSCorriente PIN_A0  // salida 
.................... #define ADC_CSTension PIN_A1 // salida 
.................... #define ADC_SCLK PIN_A2 // salida clock tension 
.................... #define ADC_SCLKcorr PIN_B1 
.................... #define ADC_DOUT PIN_B0  // entrada, por aqui ingresa la info del MAX186 
.................... #define ADC_DIN PIN_A4 //salida, se envia la informacion al MAX186 
.................... #define ADC_SSTRB PIN_A5//entrada 
.................... #define ADC_SDATA PIN_A3//entrada SDATA en AD7450 
....................  
.................... //control AD7450 
.................... signed long leer_Tension(){ 
*
03AA:  CLRF   5F
03AC:  CLRF   5E
....................     signed long dato=0,dato_t; 
....................     int i; 
....................     output_low (ADC_CSTension); 
03AE:  BCF    F92.1
03B0:  BCF    F89.1
....................     delay_us(1); 
03B2:  MOVLW  03
03B4:  MOVWF  00
03B6:  DECFSZ 00,F
03B8:  BRA    03B6
03BA:  BRA    03BC
....................     output_low (ADC_SCLK); 
03BC:  BCF    F92.2
03BE:  BCF    F89.2
....................     delay_us(1); 
03C0:  MOVLW  03
03C2:  MOVWF  00
03C4:  DECFSZ 00,F
03C6:  BRA    03C4
03C8:  BRA    03CA
....................     output_high (ADC_SCLK); 
03CA:  BCF    F92.2
03CC:  BSF    F89.2
....................     delay_us(1); 
03CE:  MOVLW  03
03D0:  MOVWF  00
03D2:  DECFSZ 00,F
03D4:  BRA    03D2
03D6:  BRA    03D8
....................      
....................         for(i=0;i<15;i++){ 
03D8:  CLRF   x62
03DA:  MOVF   x62,W
03DC:  SUBLW  0E
03DE:  BNC   0410
....................           shift_left(&dato,2,input(ADC_SDATA)); 
03E0:  BSF    F92.3
03E2:  BTFSC  F80.3
03E4:  BRA    03EA
03E6:  BCF    FD8.0
03E8:  BRA    03EC
03EA:  BSF    FD8.0
03EC:  RLCF   5E,F
03EE:  RLCF   5F,F
....................           output_low(ADC_SCLK); 
03F0:  BCF    F92.2
03F2:  BCF    F89.2
....................           delay_us(1);  
03F4:  MOVLW  03
03F6:  MOVWF  00
03F8:  DECFSZ 00,F
03FA:  BRA    03F8
03FC:  BRA    03FE
....................           output_high(ADC_SCLK);  
03FE:  BCF    F92.2
0400:  BSF    F89.2
....................           delay_us(1); 
0402:  MOVLW  03
0404:  MOVWF  00
0406:  DECFSZ 00,F
0408:  BRA    0406
040A:  BRA    040C
040C:  INCF   x62,F
040E:  BRA    03DA
....................         } 
....................  
....................        // output_high (ADC_SCLK); 
....................        // delay_us(1); 
....................         output_high (ADC_CSTension); 
0410:  BCF    F92.1
0412:  BSF    F89.1
....................          
....................        dato_t=(dato&0x0800); 
0414:  CLRF   x60
0416:  MOVF   5F,W
0418:  ANDLW  08
041A:  MOVWF  x61
....................          
....................       if (dato_t==0x0800){ 
041C:  MOVF   x60,F
041E:  BNZ   043A
0420:  MOVF   x61,W
0422:  SUBLW  08
0424:  BNZ   043A
....................             dato=-2048+(dato&0xF7FF); 
0426:  MOVFF  5E,00
042A:  MOVF   5F,W
042C:  ANDLW  F7
042E:  MOVWF  03
0430:  MOVFF  5E,5E
0434:  MOVLW  F8
0436:  ADDWF  03,W
0438:  MOVWF  5F
....................       } 
....................     return(dato); 
043A:  MOVFF  5E,01
043E:  MOVFF  5F,02
0442:  GOTO   11E8 (RETURN)
.................... } 
....................  
.................... //control MAX186 
.................... long leer_Corriente(){ 
0446:  CLRF   5F
0448:  CLRF   5E
044A:  MOVLW  8E
044C:  MOVWF  x60
....................     long dato=0; 
....................     BYTE config= 0b10001110; 
....................     int i; 
....................     output_low (ADC_CSCorriente); 
044E:  BCF    F92.0
0450:  BCF    F89.0
....................     output_low (ADC_DIN); 
0452:  BCF    F92.4
0454:  BCF    F89.4
....................     delay_us(1); 
0456:  MOVLW  03
0458:  MOVWF  00
045A:  DECFSZ 00,F
045C:  BRA    045A
045E:  BRA    0460
....................      
....................     for(i=0; i<8; i++) { 
0460:  CLRF   x61
0462:  MOVF   x61,W
0464:  SUBLW  07
0466:  BNC   0496
....................       output_bit(ADC_DIN, shift_left(&config,1,0)); 
0468:  BCF    FD8.0
046A:  RLCF   x60,F
046C:  BC    0472
046E:  BCF    F89.4
0470:  BRA    0474
0472:  BSF    F89.4
0474:  BCF    F92.4
....................       output_high(ADC_SCLKcorr); 
0476:  BCF    F93.1
0478:  BSF    F8A.1
....................       delay_us(1); 
047A:  MOVLW  03
047C:  MOVWF  00
047E:  DECFSZ 00,F
0480:  BRA    047E
0482:  BRA    0484
....................       output_low(ADC_SCLKcorr);	 
0484:  BCF    F93.1
0486:  BCF    F8A.1
....................       delay_us(1); 
0488:  MOVLW  03
048A:  MOVWF  00
048C:  DECFSZ 00,F
048E:  BRA    048C
0490:  BRA    0492
0492:  INCF   x61,F
0494:  BRA    0462
....................    } 
....................  
....................     output_high(ADC_CSCorriente); 
0496:  BCF    F92.0
0498:  BSF    F89.0
....................      
....................     while(input(ADC_SSTRB)=='0');    
....................          
....................         output_low (ADC_CSCorriente); 
049A:  BCF    F92.0
049C:  BCF    F89.0
....................         output_high (ADC_SCLKcorr); 
049E:  BCF    F93.1
04A0:  BSF    F8A.1
....................         delay_us(1); 
04A2:  MOVLW  03
04A4:  MOVWF  00
04A6:  DECFSZ 00,F
04A8:  BRA    04A6
04AA:  BRA    04AC
....................         output_low (ADC_SCLKcorr); 
04AC:  BCF    F93.1
04AE:  BCF    F8A.1
....................         delay_us(1); 
04B0:  MOVLW  03
04B2:  MOVWF  00
04B4:  DECFSZ 00,F
04B6:  BRA    04B4
04B8:  BRA    04BA
....................          
....................         for(i=0;i<15;i++){ 
04BA:  CLRF   x61
04BC:  MOVF   x61,W
04BE:  SUBLW  0E
04C0:  BNC   04F2
....................           output_high(ADC_SCLKcorr); 
04C2:  BCF    F93.1
04C4:  BSF    F8A.1
....................           delay_us(1); 
04C6:  MOVLW  03
04C8:  MOVWF  00
04CA:  DECFSZ 00,F
04CC:  BRA    04CA
04CE:  BRA    04D0
....................           shift_left(&dato,2,input(ADC_DOUT));  
04D0:  BSF    F93.0
04D2:  BTFSC  F81.0
04D4:  BRA    04DA
04D6:  BCF    FD8.0
04D8:  BRA    04DC
04DA:  BSF    FD8.0
04DC:  RLCF   5E,F
04DE:  RLCF   5F,F
....................           output_low(ADC_SCLKcorr); 
04E0:  BCF    F93.1
04E2:  BCF    F8A.1
....................           delay_us(1); 
04E4:  MOVLW  03
04E6:  MOVWF  00
04E8:  DECFSZ 00,F
04EA:  BRA    04E8
04EC:  BRA    04EE
04EE:  INCF   x61,F
04F0:  BRA    04BC
....................         } 
....................   
....................          
....................         output_high (ADC_CSCorriente); 
04F2:  BCF    F92.0
04F4:  BSF    F89.0
....................      
....................        
....................     dato= (dato>>3)& 0x0FFF; 
04F6:  RRCF   5F,W
04F8:  MOVWF  x63
04FA:  RRCF   5E,W
04FC:  MOVWF  x62
04FE:  RRCF   x63,F
0500:  RRCF   x62,F
0502:  RRCF   x63,F
0504:  RRCF   x62,F
0506:  MOVLW  1F
0508:  ANDWF  x63,F
050A:  MOVFF  62,5E
050E:  MOVF   x63,W
0510:  ANDLW  0F
0512:  MOVWF  5F
....................     return(dato); 
0514:  MOVFF  5E,01
0518:  MOVFF  5F,02
051C:  GOTO   11F4 (RETURN)
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //Implementacion Switch-Case 
....................  
.................... /** 
.................... *	\fn void maquina_estado() 
.................... *	\brief Implementacion Switch-Case 
.................... *	\details  
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
....................  **/ 
.................... signed long punto1; 
.................... long punto2; 
.................... int16 tiempo_potencia; 
.................... BYTE pos_V,pos_I,pos_V_A,pos_I_A; 
.................... int control_V; 
.................... int control_I; 
.................... int desfase; 
.................... int puntos=20;//puntos por periodo 
.................... float tension, corriente, tension_RMS,corriente_RMS, t_desfase, potencia_ins,angulo; 
.................... float Energia_Wms=0, Energia_Wh=0, Energia_kWh=0; 
....................  
.................... const long carga= 0xE8AB; 
....................  
.................... #INT_TIMER1               // interrupcion para demora de 1 ms 
.................... void interrtimer_1(){ 
....................     set_timer1(carga);   // interrupcion cada 1 ms 
*
00BC:  MOVLW  E8
00BE:  MOVWF  FCF
00C0:  MOVLW  AB
00C2:  MOVWF  FCE
....................     pulso_timer++; 
00C4:  INCF   25,F
....................  
00C6:  BCF    F9E.0
00C8:  GOTO   0060
....................    } 
....................  
.................... void maquina_estado() 
.................... { 
.................... 		static int estado = PUNTO_TENS_CORR; 
....................  
.................... 		switch(estado) 
*
11C6:  MOVF   5D,W
11C8:  XORLW  00
11CA:  BZ    11E4
11CC:  XORLW  01
11CE:  BZ    123C
11D0:  XORLW  03
11D2:  BTFSC  FD8.2
11D4:  BRA    13B6
11D6:  XORLW  01
11D8:  BTFSC  FD8.2
11DA:  BRA    1488
11DC:  XORLW  07
11DE:  BTFSC  FD8.2
11E0:  BRA    17C2
11E2:  BRA    18AC
.................... 		{ 
.................... 			case PUNTO_TENS_CORR: 
....................                 punto1= leer_Tension(); 
11E4:  GOTO   03AA
11E8:  MOVFF  02,28
11EC:  MOVFF  01,27
....................                 punto2= leer_Corriente(); // comprobar si funciona con el tiempo de demora de la lectura del externo 
11F0:  GOTO   0446
11F4:  MOVFF  02,2A
11F8:  MOVFF  01,29
....................                 // convierte los valores de long a float 
....................                 tension=punto1; 
11FC:  MOVFF  28,5F
1200:  MOVFF  27,5E
1204:  GOTO   0520
1208:  MOVFF  03,38
120C:  MOVFF  02,37
1210:  MOVFF  01,36
1214:  MOVFF  00,35
....................                 corriente=punto2; 
1218:  MOVFF  2A,8D
121C:  MOVFF  29,8C
1220:  CALL   056A
1224:  MOVFF  03,3C
1228:  MOVFF  02,3B
122C:  MOVFF  01,3A
1230:  MOVFF  00,39
....................                 contador++; 
1234:  INCF   22,F
.................... 					estado = CONVERSION_DESFASE; 
1236:  MOVLW  01
1238:  MOVWF  5D
....................  
.................... 				break; 
123A:  BRA    18AE
.................... 			 
.................... 			case CONVERSION_DESFASE: 
....................                 tension= (tension)*2.5/2048; 
123C:  MOVFF  38,8F
1240:  MOVFF  37,8E
1244:  MOVFF  36,8D
1248:  MOVFF  35,8C
124C:  CLRF   x93
124E:  CLRF   x92
1250:  MOVLW  20
1252:  MOVWF  x91
1254:  MOVLW  80
1256:  MOVWF  x90
1258:  CALL   05A0
125C:  MOVFF  03,61
1260:  MOVFF  02,60
1264:  MOVFF  01,5F
1268:  MOVFF  00,5E
126C:  MOVFF  03,73
1270:  MOVFF  02,72
1274:  MOVFF  01,71
1278:  MOVFF  00,70
127C:  CLRF   x77
127E:  CLRF   x76
1280:  CLRF   x75
1282:  MOVLW  8A
1284:  MOVWF  x74
1286:  CALL   0692
128A:  MOVFF  03,38
128E:  MOVFF  02,37
1292:  MOVFF  01,36
1296:  MOVFF  00,35
....................                 corriente= (corriente)/1000-2.510; 
129A:  MOVFF  3C,73
129E:  MOVFF  3B,72
12A2:  MOVFF  3A,71
12A6:  MOVFF  39,70
12AA:  CLRF   x77
12AC:  CLRF   x76
12AE:  MOVLW  7A
12B0:  MOVWF  x75
12B2:  MOVLW  88
12B4:  MOVWF  x74
12B6:  CALL   0692
12BA:  MOVFF  03,61
12BE:  MOVFF  02,60
12C2:  MOVFF  01,5F
12C6:  MOVFF  00,5E
12CA:  BSF    FD8.1
12CC:  MOVFF  03,8F
12D0:  MOVFF  02,8E
12D4:  MOVFF  01,8D
12D8:  MOVFF  00,8C
12DC:  MOVLW  D7
12DE:  MOVWF  x93
12E0:  MOVLW  A3
12E2:  MOVWF  x92
12E4:  MOVLW  20
12E6:  MOVWF  x91
12E8:  MOVLW  80
12EA:  MOVWF  x90
12EC:  CALL   07EC
12F0:  MOVFF  03,3C
12F4:  MOVFF  02,3B
12F8:  MOVFF  01,3A
12FC:  MOVFF  00,39
....................                 //se convierte a la tension y corriente real 
....................                 tension= tension*155.57; // conversion con 2 V igual a 311.13 V 
1300:  MOVFF  38,8F
1304:  MOVFF  37,8E
1308:  MOVFF  36,8D
130C:  MOVFF  35,8C
1310:  MOVLW  EC
1312:  MOVWF  x93
1314:  MOVLW  91
1316:  MOVWF  x92
1318:  MOVLW  1B
131A:  MOVWF  x91
131C:  MOVLW  86
131E:  MOVWF  x90
1320:  CALL   05A0
1324:  MOVFF  03,38
1328:  MOVFF  02,37
132C:  MOVFF  01,36
1330:  MOVFF  00,35
....................                 corriente= corriente*12; // 2.5 V es igual a +30 A (recordar que el sensor mide ±30A) 
1334:  MOVFF  3C,8F
1338:  MOVFF  3B,8E
133C:  MOVFF  3A,8D
1340:  MOVFF  39,8C
1344:  CLRF   x93
1346:  CLRF   x92
1348:  MOVLW  40
134A:  MOVWF  x91
134C:  MOVLW  82
134E:  MOVWF  x90
1350:  CALL   05A0
1354:  MOVFF  03,3C
1358:  MOVFF  02,3B
135C:  MOVFF  01,3A
1360:  MOVFF  00,39
....................                  
....................                 // Analisis del punto POSITVO O NEGATIVO 
....................                 // valor positivo estado=0-- valor negativo estado=1 
....................                  
....................                 //TENSION 
....................                 #asm 
....................                 clrf &pos_V; 
1364:  CLRF   2D
....................                 btfsc (&tension + 0x01), 7; 
1366:  BTFSC  36.7
....................                 bsf &pos_V,0; 
1368:  BSF    2D.0
....................                 #endasm 
.................... 				 
....................                 //CORRIENTE 
....................                 #asm 
....................                 clrf &pos_I; 
136A:  CLRF   2E
....................                 btfsc (&corriente + 0x01), 7; // comprueba signo en un bit de los 4 byte del float 
136C:  BTFSC  3A.7
....................                 bsf &pos_I,0; 
136E:  BSF    2E.0
....................                 #endasm 
....................  
....................                  
....................                  
.................... 				 
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contador distinto de cero) 
....................                 if (pos_V==1 && contador>=2 && pos_V_A==0 && desfase!=1){  
1370:  DECFSZ 2D,W
1372:  BRA    138C
1374:  MOVF   22,W
1376:  SUBLW  01
1378:  BC    138C
137A:  MOVF   2F,F
137C:  BNZ   138C
137E:  DECFSZ 33,W
1380:  BRA    1384
1382:  BRA    138C
....................                  control_V= contador; // tiempo en el que cruzó la tension  
1384:  MOVFF  22,31
....................                  desfase=1; 
1388:  MOVLW  01
138A:  MOVWF  33
....................                 } 
....................                  
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_I==1 && contador>=2 && pos_I_A==0 && desfase!=2){ 
138C:  DECFSZ 2E,W
138E:  BRA    13A8
1390:  MOVF   22,W
1392:  SUBLW  01
1394:  BC    13A8
1396:  MOVF   30,F
1398:  BNZ   13A8
139A:  MOVF   33,W
139C:  SUBLW  02
139E:  BZ    13A8
....................                      
....................                  control_I= contador; // tiempo en el que cruzó la corriente 
13A0:  MOVFF  22,32
....................                  desfase=2; 
13A4:  MOVLW  02
13A6:  MOVWF  33
....................                 } 
....................                 // guarda el signo de los puntos anteriores 
....................                 pos_V_A=pos_V; 
13A8:  MOVFF  2D,2F
....................                 pos_I_A=pos_I; 
13AC:  MOVFF  2E,30
....................                  
....................                  
.................... 					estado = TENS_CORR_RMS; 
13B0:  MOVLW  02
13B2:  MOVWF  5D
.................... 		 
.................... 				 
....................  
.................... 				break; 
13B4:  BRA    18AE
.................... //---------------------------------------------------------------------------------------------------- 
....................                  
.................... 			case TENS_CORR_RMS: 
.................... 			 
.................... 				if((contador<30)&& (pulso_timer==1)) 
13B6:  MOVF   22,W
13B8:  SUBLW  1D
13BA:  BNC   1486
13BC:  DECFSZ 25,W
13BE:  BRA    1486
.................... 				{ 
.................... 					tension_RMS=tension_RMS+ tension * tension;       //calcula tension eficaz 
13C0:  MOVFF  38,8F
13C4:  MOVFF  37,8E
13C8:  MOVFF  36,8D
13CC:  MOVFF  35,8C
13D0:  MOVFF  38,93
13D4:  MOVFF  37,92
13D8:  MOVFF  36,91
13DC:  MOVFF  35,90
13E0:  CALL   05A0
13E4:  BCF    FD8.1
13E6:  MOVFF  40,8F
13EA:  MOVFF  3F,8E
13EE:  MOVFF  3E,8D
13F2:  MOVFF  3D,8C
13F6:  MOVFF  03,93
13FA:  MOVFF  02,92
13FE:  MOVFF  01,91
1402:  MOVFF  00,90
1406:  CALL   07EC
140A:  MOVFF  03,40
140E:  MOVFF  02,3F
1412:  MOVFF  01,3E
1416:  MOVFF  00,3D
....................                     corriente_RMS= corriente_RMS+ corriente * corriente; // calcula corriente eficaz 
141A:  MOVFF  3C,8F
141E:  MOVFF  3B,8E
1422:  MOVFF  3A,8D
1426:  MOVFF  39,8C
142A:  MOVFF  3C,93
142E:  MOVFF  3B,92
1432:  MOVFF  3A,91
1436:  MOVFF  39,90
143A:  CALL   05A0
143E:  BCF    FD8.1
1440:  MOVFF  44,8F
1444:  MOVFF  43,8E
1448:  MOVFF  42,8D
144C:  MOVFF  41,8C
1450:  MOVFF  03,93
1454:  MOVFF  02,92
1458:  MOVFF  01,91
145C:  MOVFF  00,90
1460:  CALL   07EC
1464:  MOVFF  03,44
1468:  MOVFF  02,43
146C:  MOVFF  01,42
1470:  MOVFF  00,41
....................                     pulso_timer=0; 
1474:  CLRF   25
....................                      
.................... 					estado = PUNTO_TENS_CORR; 
1476:  CLRF   5D
....................                      
....................                     if((contador== 29)){ 
1478:  MOVF   22,W
147A:  SUBLW  1D
147C:  BNZ   1486
.................... 					disable_interrupts(INT_TIMER1);// deshabilita la interrupcion para no entrar al timer 
147E:  BCF    F9D.0
....................                     contador=0; //se reinicia el contador, para comenzar nuevamente  
1480:  CLRF   22
.................... 					estado = CALCULO_POT_ENER; 
1482:  MOVLW  03
1484:  MOVWF  5D
.................... 				} 
.................... 				} 
.................... 				 
....................  
.................... 				break; 
1486:  BRA    18AE
....................                  
.................... //--------------------------------------------------------------------------------------------------------------------                 
.................... 			 
.................... 			case CALCULO_POT_ENER: // falta calculo de energia 
....................                 //calcula las raices para completar el calculo RMS 
.................... 				tension_RMS= sqrt(tension_RMS/30); 
1488:  MOVFF  40,73
148C:  MOVFF  3F,72
1490:  MOVFF  3E,71
1494:  MOVFF  3D,70
1498:  CLRF   x77
149A:  CLRF   x76
149C:  MOVLW  70
149E:  MOVWF  x75
14A0:  MOVLW  83
14A2:  MOVWF  x74
14A4:  CALL   0692
14A8:  MOVFF  03,61
14AC:  MOVFF  02,60
14B0:  MOVFF  01,5F
14B4:  MOVFF  00,5E
14B8:  MOVFF  03,65
14BC:  MOVFF  02,64
14C0:  MOVFF  01,63
14C4:  MOVFF  00,62
14C8:  CALL   0ACC
14CC:  MOVFF  03,40
14D0:  MOVFF  02,3F
14D4:  MOVFF  01,3E
14D8:  MOVFF  00,3D
....................                 corriente_RMS= sqrt(corriente_RMS/30); 
14DC:  MOVFF  44,73
14E0:  MOVFF  43,72
14E4:  MOVFF  42,71
14E8:  MOVFF  41,70
14EC:  CLRF   x77
14EE:  CLRF   x76
14F0:  MOVLW  70
14F2:  MOVWF  x75
14F4:  MOVLW  83
14F6:  MOVWF  x74
14F8:  CALL   0692
14FC:  MOVFF  03,61
1500:  MOVFF  02,60
1504:  MOVFF  01,5F
1508:  MOVFF  00,5E
150C:  MOVFF  03,65
1510:  MOVFF  02,64
1514:  MOVFF  01,63
1518:  MOVFF  00,62
151C:  CALL   0ACC
1520:  MOVFF  03,44
1524:  MOVFF  02,43
1528:  MOVFF  01,42
152C:  MOVFF  00,41
....................                  
....................                 // se controla si se pudo calcular desfase en el estado anterior  
....................                 // se realiza las diferencia de cruce por cero y se convierte de tiempo a radianes 
....................                 angulo=0; 
1530:  CLRF   50
1532:  CLRF   4F
1534:  CLRF   4E
1536:  CLRF   4D
....................                 if (desfase==2){ 
1538:  MOVF   33,W
153A:  SUBLW  02
153C:  BNZ   15BE
....................                     t_desfase= (control_I-control_V); 
153E:  MOVF   31,W
1540:  SUBWF  32,W
1542:  CLRF   x8D
1544:  MOVWF  x8C
1546:  CALL   056A
154A:  MOVFF  03,48
154E:  MOVFF  02,47
1552:  MOVFF  01,46
1556:  MOVFF  00,45
....................                     angulo= (t_desfase*pi)/10;      // angulo de desfase en radianes. 20 puntos por periodo 
155A:  MOVFF  48,8F
155E:  MOVFF  47,8E
1562:  MOVFF  46,8D
1566:  MOVFF  45,8C
156A:  MOVLW  DB
156C:  MOVWF  x93
156E:  MOVLW  0F
1570:  MOVWF  x92
1572:  MOVLW  49
1574:  MOVWF  x91
1576:  MOVLW  80
1578:  MOVWF  x90
157A:  CALL   05A0
157E:  MOVFF  03,61
1582:  MOVFF  02,60
1586:  MOVFF  01,5F
158A:  MOVFF  00,5E
158E:  MOVFF  03,73
1592:  MOVFF  02,72
1596:  MOVFF  01,71
159A:  MOVFF  00,70
159E:  CLRF   x77
15A0:  CLRF   x76
15A2:  MOVLW  20
15A4:  MOVWF  x75
15A6:  MOVLW  82
15A8:  MOVWF  x74
15AA:  CALL   0692
15AE:  MOVFF  03,50
15B2:  MOVFF  02,4F
15B6:  MOVFF  01,4E
15BA:  MOVFF  00,4D
....................                    /*  lcd_gotoxy(1,1); 
....................                      printf(LCD_PUTC,"desfase= %f       ",t_desfase); 
....................                      lcd_gotoxy(1,2); 
....................                      printf(LCD_PUTC,"angulo=%f        ",angulo); 
....................                      delay_ms(1000);*/ 
....................                 }                 
....................                  
....................                 angulo=cos(angulo); 
15BE:  MOVFF  50,61
15C2:  MOVFF  4F,60
15C6:  MOVFF  4E,5F
15CA:  MOVFF  4D,5E
15CE:  GOTO   0C10
15D2:  MOVFF  03,50
15D6:  MOVFF  02,4F
15DA:  MOVFF  01,4E
15DE:  MOVFF  00,4D
....................                // calculo de potencia  
....................                 potencia_ins= tension_RMS*corriente_RMS*angulo; 
15E2:  MOVFF  40,8F
15E6:  MOVFF  3F,8E
15EA:  MOVFF  3E,8D
15EE:  MOVFF  3D,8C
15F2:  MOVFF  44,93
15F6:  MOVFF  43,92
15FA:  MOVFF  42,91
15FE:  MOVFF  41,90
1602:  CALL   05A0
1606:  MOVFF  03,61
160A:  MOVFF  02,60
160E:  MOVFF  01,5F
1612:  MOVFF  00,5E
1616:  MOVFF  03,8F
161A:  MOVFF  02,8E
161E:  MOVFF  01,8D
1622:  MOVFF  00,8C
1626:  MOVFF  50,93
162A:  MOVFF  4F,92
162E:  MOVFF  4E,91
1632:  MOVFF  4D,90
1636:  CALL   05A0
163A:  MOVFF  03,4C
163E:  MOVFF  02,4B
1642:  MOVFF  01,4A
1646:  MOVFF  00,49
....................                 //se limpian las variables para la próxima etapa de muestreo 
....................                 control_V=0;       
164A:  CLRF   31
....................                 control_I=0; 
164C:  CLRF   32
....................                 angulo=0; 
164E:  CLRF   50
1650:  CLRF   4F
1652:  CLRF   4E
1654:  CLRF   4D
....................                 desfase=0;  
1656:  CLRF   33
....................                  
....................                 //Calculo de Energia 
....................                 tiempo_potencia=65536 - get_timer0();    //variable para calcular energia segun tiempo de potencia 
1658:  MOVF   FD6,W
165A:  XORLW  FF
165C:  ADDLW  01
165E:  MOVWF  2B
1660:  MOVLW  00
1662:  SUBFWB FD7,W
1664:  MOVWF  2C
....................                 Energia_Wms=Energia_Wms+potencia_ins*tiempo_potencia/37500000;             //Energia en Watt por milisegundo 
1666:  MOVFF  2C,8D
166A:  MOVFF  2B,8C
166E:  CALL   056A
1672:  MOVFF  4C,8F
1676:  MOVFF  4B,8E
167A:  MOVFF  4A,8D
167E:  MOVFF  49,8C
1682:  MOVFF  03,93
1686:  MOVFF  02,92
168A:  MOVFF  01,91
168E:  MOVFF  00,90
1692:  CALL   05A0
1696:  MOVFF  03,61
169A:  MOVFF  02,60
169E:  MOVFF  01,5F
16A2:  MOVFF  00,5E
16A6:  MOVFF  03,73
16AA:  MOVFF  02,72
16AE:  MOVFF  01,71
16B2:  MOVFF  00,70
16B6:  MOVLW  18
16B8:  MOVWF  x77
16BA:  MOVLW  0D
16BC:  MOVWF  x76
16BE:  MOVLW  0F
16C0:  MOVWF  x75
16C2:  MOVLW  98
16C4:  MOVWF  x74
16C6:  CALL   0692
16CA:  BCF    FD8.1
16CC:  MOVFF  54,8F
16D0:  MOVFF  53,8E
16D4:  MOVFF  52,8D
16D8:  MOVFF  51,8C
16DC:  MOVFF  03,93
16E0:  MOVFF  02,92
16E4:  MOVFF  01,91
16E8:  MOVFF  00,90
16EC:  CALL   07EC
16F0:  MOVFF  03,54
16F4:  MOVFF  02,53
16F8:  MOVFF  01,52
16FC:  MOVFF  00,51
....................                  
....................                 if(Energia_Wms>=3600000){ 
1700:  CLRF   x8B
1702:  MOVLW  BA
1704:  MOVWF  x8A
1706:  MOVLW  5B
1708:  MOVWF  x89
170A:  MOVLW  94
170C:  MOVWF  x88
170E:  MOVFF  54,8F
1712:  MOVFF  53,8E
1716:  MOVFF  52,8D
171A:  MOVFF  51,8C
171E:  CALL   0A56
1722:  BC    1726
1724:  BNZ   175E
....................                     Energia_Wh=Energia_Wh+1;  // rekacion watt ms a watt hora 
1726:  BCF    FD8.1
1728:  MOVFF  58,8F
172C:  MOVFF  57,8E
1730:  MOVFF  56,8D
1734:  MOVFF  55,8C
1738:  CLRF   x93
173A:  CLRF   x92
173C:  CLRF   x91
173E:  MOVLW  7F
1740:  MOVWF  x90
1742:  CALL   07EC
1746:  MOVFF  03,58
174A:  MOVFF  02,57
174E:  MOVFF  01,56
1752:  MOVFF  00,55
....................                     Energia_Wms=0;                 
1756:  CLRF   54
1758:  CLRF   53
175A:  CLRF   52
175C:  CLRF   51
....................                 } 
....................                  
....................                 if (Energia_Wh==1000){ 
175E:  MOVFF  58,8B
1762:  MOVFF  57,8A
1766:  MOVFF  56,89
176A:  MOVFF  55,88
176E:  CLRF   x8F
1770:  CLRF   x8E
1772:  MOVLW  7A
1774:  MOVWF  x8D
1776:  MOVLW  88
1778:  MOVWF  x8C
177A:  CALL   0A56
177E:  BNZ   17B8
....................                     Energia_kWh=Energia_kWh+1; 
1780:  BCF    FD8.1
1782:  MOVFF  5C,8F
1786:  MOVFF  5B,8E
178A:  MOVFF  5A,8D
178E:  MOVFF  59,8C
1792:  CLRF   x93
1794:  CLRF   x92
1796:  CLRF   x91
1798:  MOVLW  7F
179A:  MOVWF  x90
179C:  CALL   07EC
17A0:  MOVFF  03,5C
17A4:  MOVFF  02,5B
17A8:  MOVFF  01,5A
17AC:  MOVFF  00,59
....................                     Energia_Wh=0; 
17B0:  CLRF   58
17B2:  CLRF   57
17B4:  CLRF   56
17B6:  CLRF   55
....................                 } 
....................                  
....................                  
....................                  
....................                 // Se reinicia timer 0 nuevamente, para volver a calcular energia 
....................                 set_timer0(0x0000); 
17B8:  CLRF   FD7
17BA:  CLRF   FD6
....................                  
.................... 					estado = MOSTRAR_DATOS; 
17BC:  MOVLW  04
17BE:  MOVWF  5D
.................... 				break; 
17C0:  BRA    18AE
....................                  
.................... //------------------------------------------------------------------------------------- 
....................                  
.................... 			case MOSTRAR_DATOS: 
....................                 //este estado solo muestra los datos en la pantalla LCD 
....................                 lcd_gotoxy(1,1); 
17C2:  MOVLW  01
17C4:  MOVWF  x6D
17C6:  MOVWF  x6E
17C8:  CALL   028A
....................                 printf(LCD_PUTC,"Ener [kWh]= \%f W",potencia_ins); 
17CC:  MOVLW  CC
17CE:  MOVWF  FF6
17D0:  MOVLW  00
17D2:  MOVWF  FF7
17D4:  MOVLW  0C
17D6:  MOVWF  5E
17D8:  CALL   0F56
17DC:  MOVLW  89
17DE:  MOVWF  FE9
17E0:  MOVFF  4C,61
17E4:  MOVFF  4B,60
17E8:  MOVFF  4A,5F
17EC:  MOVFF  49,5E
17F0:  MOVLW  02
17F2:  MOVWF  x62
17F4:  RCALL  1044
17F6:  MOVLW  20
17F8:  MOVWF  x6C
17FA:  CALL   02E0
17FE:  MOVLW  57
1800:  MOVWF  x6C
1802:  CALL   02E0
....................                 lcd_gotoxy(1,2); 
1806:  MOVLW  01
1808:  MOVWF  x6D
180A:  MOVLW  02
180C:  MOVWF  x6E
180E:  CALL   028A
....................                 printf (LCD_PUTC, "T=\%f  I=\%f  ",tension_RMS,corriente_RMS); 
1812:  MOVLW  54
1814:  MOVWF  x6C
1816:  CALL   02E0
181A:  MOVLW  3D
181C:  MOVWF  x6C
181E:  CALL   02E0
1822:  MOVLW  89
1824:  MOVWF  FE9
1826:  MOVFF  40,61
182A:  MOVFF  3F,60
182E:  MOVFF  3E,5F
1832:  MOVFF  3D,5E
1836:  MOVLW  02
1838:  MOVWF  x62
183A:  RCALL  1044
183C:  MOVLW  E2
183E:  MOVWF  FF6
1840:  MOVLW  00
1842:  MOVWF  FF7
1844:  MOVLW  04
1846:  MOVWF  5E
1848:  CALL   0F56
184C:  MOVLW  89
184E:  MOVWF  FE9
1850:  MOVFF  44,61
1854:  MOVFF  43,60
1858:  MOVFF  42,5F
185C:  MOVFF  41,5E
1860:  MOVLW  02
1862:  MOVWF  x62
1864:  CALL   1044
1868:  MOVLW  20
186A:  MOVWF  x6C
186C:  CALL   02E0
1870:  MOVLW  20
1872:  MOVWF  x6C
1874:  CALL   02E0
....................                 delay_ms(1000); 
1878:  MOVLW  04
187A:  MOVWF  5E
187C:  MOVLW  FA
187E:  MOVWF  x6D
1880:  CALL   00EC
1884:  DECFSZ 5E,F
1886:  BRA    187C
....................                 enable_interrupts(INT_TIMER1); 
1888:  BSF    F9D.0
....................                 enable_interrupts(GLOBAL); 
188A:  MOVLW  C0
188C:  IORWF  FF2,F
....................                 pulso_timer=0; 
188E:  CLRF   25
....................                 set_timer1(carga);    
1890:  MOVLW  E8
1892:  MOVWF  FCF
1894:  MOVLW  AB
1896:  MOVWF  FCE
.................... 				//reinicia todo 
....................                 corriente_RMS=0; 
1898:  CLRF   44
189A:  CLRF   43
189C:  CLRF   42
189E:  CLRF   41
....................                 tension_RMS=0; 
18A0:  CLRF   40
18A2:  CLRF   3F
18A4:  CLRF   3E
18A6:  CLRF   3D
....................                  
.................... 				estado = PUNTO_TENS_CORR; 
18A8:  CLRF   5D
.................... 		 
....................  
.................... 				break; 
18AA:  BRA    18AE
.................... 			 
.................... 			default: estado = PUNTO_TENS_CORR; 
18AC:  CLRF   5D
.................... 		} 
18AE:  GOTO   194E (RETURN)
....................  
....................  
.................... } 
....................  
.................... //Funciones asociadas a los eventos 
....................  
.................... /** 
.................... *	\fn int -(void) 
.................... *	\brief Resumen 
.................... *	\details Detalles 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 4C07   PLL12 CPUDIV1 NOUSBDIV HS FCMEN NOIESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
