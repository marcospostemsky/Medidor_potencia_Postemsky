CCS PCH C Compiler, Version 5.048, 5967               05-oct-16 11:21

               Filename:   C:\Users\MARCOS\Proyecto_final\Med_pot.X\dist\default\production\Med_pot.X.production.lst

               ROM used:   5680 bytes (17%)
                           Largest free fragment is 27084
               RAM used:   79 (4%) at main() level
                           145 (7%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   15F2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   00BC
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #import(file="build/default/production/main.o") 
.................... #import(file="build/default/production/funciones.o") 
.................... /** 
.................... *	\file main.c 
.................... *	\brief Resumen del contenido del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  DATA 50,72
00B0:  DATA 69,6D
00B2:  DATA 65,72
00B4:  DATA 20,70
00B6:  DATA 72,75
00B8:  DATA 65,62
00BA:  DATA 61,00
*
0360:  TBLRD*+
0362:  MOVF   FF5,F
0364:  BZ    037E
0366:  MOVFF  FF6,4F
036A:  MOVFF  FF7,50
036E:  MOVFF  FF5,5D
0372:  RCALL  02F2
0374:  MOVFF  4F,FF6
0378:  MOVFF  50,FF7
037C:  BRA    0360
037E:  GOTO   03B6 (RETURN)
*
042A:  MOVLW  8E
042C:  MOVWF  00
042E:  MOVFF  82,01
0432:  MOVFF  81,02
0436:  CLRF   03
0438:  MOVF   01,F
043A:  BNZ   044E
043C:  MOVFF  02,01
0440:  CLRF   02
0442:  MOVLW  08
0444:  SUBWF  00,F
0446:  MOVF   01,F
0448:  BNZ   044E
044A:  CLRF   00
044C:  BRA    045E
044E:  BCF    FD8.0
0450:  BTFSC  01.7
0452:  BRA    045C
0454:  RLCF   02,F
0456:  RLCF   01,F
0458:  DECF   00,F
045A:  BRA    044E
045C:  BCF    01.7
045E:  RETURN 0
0460:  MOVF   x61,W
0462:  BTFSC  FD8.2
0464:  BRA    05B0
0466:  MOVWF  x6D
0468:  MOVF   x65,W
046A:  BTFSC  FD8.2
046C:  BRA    05B0
046E:  SUBWF  x6D,F
0470:  BNC   047C
0472:  MOVLW  7F
0474:  ADDWF  x6D,F
0476:  BTFSC  FD8.0
0478:  BRA    05B0
047A:  BRA    0488
047C:  MOVLW  81
047E:  SUBWF  x6D,F
0480:  BTFSS  FD8.0
0482:  BRA    05B0
0484:  BTFSC  FD8.2
0486:  BRA    05B0
0488:  MOVFF  6D,00
048C:  CLRF   01
048E:  CLRF   02
0490:  CLRF   03
0492:  CLRF   x6C
0494:  MOVFF  62,6B
0498:  BSF    x6B.7
049A:  MOVFF  63,6A
049E:  MOVFF  64,69
04A2:  MOVLW  19
04A4:  MOVWF  x6D
04A6:  MOVF   x68,W
04A8:  SUBWF  x69,F
04AA:  BC    04C6
04AC:  MOVLW  01
04AE:  SUBWF  x6A,F
04B0:  BC    04C6
04B2:  SUBWF  x6B,F
04B4:  BC    04C6
04B6:  SUBWF  x6C,F
04B8:  BC    04C6
04BA:  INCF   x6C,F
04BC:  INCF   x6B,F
04BE:  INCF   x6A,F
04C0:  MOVF   x68,W
04C2:  ADDWF  x69,F
04C4:  BRA    0516
04C6:  MOVF   x67,W
04C8:  SUBWF  x6A,F
04CA:  BC    04F0
04CC:  MOVLW  01
04CE:  SUBWF  x6B,F
04D0:  BC    04F0
04D2:  SUBWF  x6C,F
04D4:  BC    04F0
04D6:  INCF   x6C,F
04D8:  INCF   x6B,F
04DA:  MOVF   x67,W
04DC:  ADDWF  x6A,F
04DE:  MOVF   x68,W
04E0:  ADDWF  x69,F
04E2:  BNC   0516
04E4:  INCF   x6A,F
04E6:  BNZ   0516
04E8:  INCF   x6B,F
04EA:  BNZ   0516
04EC:  INCF   x6C,F
04EE:  BRA    0516
04F0:  MOVF   x66,W
04F2:  IORLW  80
04F4:  SUBWF  x6B,F
04F6:  BC    0514
04F8:  MOVLW  01
04FA:  SUBWF  x6C,F
04FC:  BC    0514
04FE:  INCF   x6C,F
0500:  MOVF   x66,W
0502:  IORLW  80
0504:  ADDWF  x6B,F
0506:  MOVF   x67,W
0508:  ADDWF  x6A,F
050A:  BNC   04DE
050C:  INCF   x6B,F
050E:  BNZ   04DE
0510:  INCF   x6C,F
0512:  BRA    04DE
0514:  BSF    03.0
0516:  DECFSZ x6D,F
0518:  BRA    051C
051A:  BRA    0532
051C:  BCF    FD8.0
051E:  RLCF   x69,F
0520:  RLCF   x6A,F
0522:  RLCF   x6B,F
0524:  RLCF   x6C,F
0526:  BCF    FD8.0
0528:  RLCF   03,F
052A:  RLCF   02,F
052C:  RLCF   01,F
052E:  RLCF   x6E,F
0530:  BRA    04A6
0532:  BTFSS  x6E.0
0534:  BRA    0542
0536:  BCF    FD8.0
0538:  RRCF   01,F
053A:  RRCF   02,F
053C:  RRCF   03,F
053E:  RRCF   x6E,F
0540:  BRA    0546
0542:  DECF   00,F
0544:  BZ    05B0
0546:  BTFSC  x6E.7
0548:  BRA    0586
054A:  BCF    FD8.0
054C:  RLCF   x69,F
054E:  RLCF   x6A,F
0550:  RLCF   x6B,F
0552:  RLCF   x6C,F
0554:  MOVF   x68,W
0556:  SUBWF  x69,F
0558:  BC    0568
055A:  MOVLW  01
055C:  SUBWF  x6A,F
055E:  BC    0568
0560:  SUBWF  x6B,F
0562:  BC    0568
0564:  SUBWF  x6C,F
0566:  BNC   059C
0568:  MOVF   x67,W
056A:  SUBWF  x6A,F
056C:  BC    0578
056E:  MOVLW  01
0570:  SUBWF  x6B,F
0572:  BC    0578
0574:  SUBWF  x6C,F
0576:  BNC   059C
0578:  MOVF   x66,W
057A:  IORLW  80
057C:  SUBWF  x6B,F
057E:  BC    0586
0580:  MOVLW  01
0582:  SUBWF  x6C,F
0584:  BNC   059C
0586:  INCF   03,F
0588:  BNZ   059C
058A:  INCF   02,F
058C:  BNZ   059C
058E:  INCF   01,F
0590:  BNZ   059C
0592:  INCF   00,F
0594:  BZ    05B0
0596:  RRCF   01,F
0598:  RRCF   02,F
059A:  RRCF   03,F
059C:  MOVFF  62,6D
05A0:  MOVF   x66,W
05A2:  XORWF  x6D,F
05A4:  BTFSS  x6D.7
05A6:  BRA    05AC
05A8:  BSF    01.7
05AA:  BRA    05B8
05AC:  BCF    01.7
05AE:  BRA    05B8
05B0:  CLRF   00
05B2:  CLRF   01
05B4:  CLRF   02
05B6:  CLRF   03
05B8:  RETURN 0
05BA:  MOVLW  80
05BC:  BTFSC  FD8.1
05BE:  XORWF  x86,F
05C0:  CLRF   x8B
05C2:  CLRF   x8C
05C4:  MOVFF  82,8A
05C8:  MOVF   x86,W
05CA:  XORWF  x8A,F
05CC:  MOVF   x81,W
05CE:  BTFSC  FD8.2
05D0:  BRA    078A
05D2:  MOVWF  x89
05D4:  MOVWF  00
05D6:  MOVF   x85,W
05D8:  BTFSC  FD8.2
05DA:  BRA    079C
05DC:  SUBWF  x89,F
05DE:  BTFSC  FD8.2
05E0:  BRA    06E4
05E2:  BNC   065E
05E4:  MOVFF  86,8F
05E8:  BSF    x8F.7
05EA:  MOVFF  87,8E
05EE:  MOVFF  88,8D
05F2:  CLRF   x8C
05F4:  BCF    FD8.0
05F6:  RRCF   x8F,F
05F8:  RRCF   x8E,F
05FA:  RRCF   x8D,F
05FC:  RRCF   x8C,F
05FE:  DECFSZ x89,F
0600:  BRA    05F2
0602:  BTFSS  x8A.7
0604:  BRA    060C
0606:  BSF    x8B.0
0608:  BRA    07C4
060A:  BCF    x8B.0
060C:  BCF    x89.0
060E:  BSF    x8B.4
0610:  CLRF   FEA
0612:  MOVLW  84
0614:  MOVWF  FE9
0616:  BRA    07EA
0618:  BCF    x8B.4
061A:  BTFSC  x8A.7
061C:  BRA    0632
061E:  BTFSS  x89.0
0620:  BRA    0648
0622:  RRCF   x8F,F
0624:  RRCF   x8E,F
0626:  RRCF   x8D,F
0628:  RRCF   x8C,F
062A:  INCF   00,F
062C:  BTFSC  FD8.2
062E:  BRA    07BA
0630:  BRA    0648
0632:  BTFSC  x8F.7
0634:  BRA    064E
0636:  BCF    FD8.0
0638:  RLCF   x8C,F
063A:  RLCF   x8D,F
063C:  RLCF   x8E,F
063E:  RLCF   x8F,F
0640:  DECF   00,F
0642:  BTFSC  FD8.2
0644:  BRA    07BA
0646:  BRA    0632
0648:  BSF    x8B.6
064A:  BRA    0722
064C:  BCF    x8B.6
064E:  MOVFF  82,8A
0652:  BTFSS  x82.7
0654:  BRA    065A
0656:  BSF    x8F.7
0658:  BRA    07AC
065A:  BCF    x8F.7
065C:  BRA    07AC
065E:  MOVFF  85,89
0662:  MOVFF  85,00
0666:  MOVF   x81,W
0668:  SUBWF  x89,F
066A:  MOVFF  82,8F
066E:  BSF    x8F.7
0670:  MOVFF  83,8E
0674:  MOVFF  84,8D
0678:  CLRF   x8C
067A:  BCF    FD8.0
067C:  RRCF   x8F,F
067E:  RRCF   x8E,F
0680:  RRCF   x8D,F
0682:  RRCF   x8C,F
0684:  DECFSZ x89,F
0686:  BRA    0678
0688:  BTFSS  x8A.7
068A:  BRA    0692
068C:  BSF    x8B.1
068E:  BRA    07C4
0690:  BCF    x8B.1
0692:  BCF    x89.0
0694:  BSF    x8B.5
0696:  CLRF   FEA
0698:  MOVLW  88
069A:  MOVWF  FE9
069C:  BRA    07EA
069E:  BCF    x8B.5
06A0:  BTFSC  x8A.7
06A2:  BRA    06B8
06A4:  BTFSS  x89.0
06A6:  BRA    06CE
06A8:  RRCF   x8F,F
06AA:  RRCF   x8E,F
06AC:  RRCF   x8D,F
06AE:  RRCF   x8C,F
06B0:  INCF   00,F
06B2:  BTFSC  FD8.2
06B4:  BRA    07BA
06B6:  BRA    06CE
06B8:  BTFSC  x8F.7
06BA:  BRA    06D4
06BC:  BCF    FD8.0
06BE:  RLCF   x8C,F
06C0:  RLCF   x8D,F
06C2:  RLCF   x8E,F
06C4:  RLCF   x8F,F
06C6:  DECF   00,F
06C8:  BTFSC  FD8.2
06CA:  BRA    07BA
06CC:  BRA    06B8
06CE:  BSF    x8B.7
06D0:  BRA    0722
06D2:  BCF    x8B.7
06D4:  MOVFF  86,8A
06D8:  BTFSS  x86.7
06DA:  BRA    06E0
06DC:  BSF    x8F.7
06DE:  BRA    07AC
06E0:  BCF    x8F.7
06E2:  BRA    07AC
06E4:  MOVFF  86,8F
06E8:  BSF    x8F.7
06EA:  MOVFF  87,8E
06EE:  MOVFF  88,8D
06F2:  BTFSS  x8A.7
06F4:  BRA    06FE
06F6:  BCF    x8F.7
06F8:  BSF    x8B.2
06FA:  BRA    07C4
06FC:  BCF    x8B.2
06FE:  CLRF   x8C
0700:  BCF    x89.0
0702:  CLRF   FEA
0704:  MOVLW  84
0706:  MOVWF  FE9
0708:  BRA    07EA
070A:  BTFSC  x8A.7
070C:  BRA    0746
070E:  MOVFF  82,8A
0712:  BTFSS  x89.0
0714:  BRA    0722
0716:  RRCF   x8F,F
0718:  RRCF   x8E,F
071A:  RRCF   x8D,F
071C:  RRCF   x8C,F
071E:  INCF   00,F
0720:  BZ    07BA
0722:  BTFSS  x8C.7
0724:  BRA    073C
0726:  INCF   x8D,F
0728:  BNZ   073C
072A:  INCF   x8E,F
072C:  BNZ   073C
072E:  INCF   x8F,F
0730:  BNZ   073C
0732:  RRCF   x8F,F
0734:  RRCF   x8E,F
0736:  RRCF   x8D,F
0738:  INCF   00,F
073A:  BZ    07BA
073C:  BTFSC  x8B.6
073E:  BRA    064C
0740:  BTFSC  x8B.7
0742:  BRA    06D2
0744:  BRA    077E
0746:  MOVLW  80
0748:  XORWF  x8F,F
074A:  BTFSS  x8F.7
074C:  BRA    0756
074E:  BRA    07C4
0750:  MOVFF  86,8A
0754:  BRA    076A
0756:  MOVFF  82,8A
075A:  MOVF   x8F,F
075C:  BNZ   076A
075E:  MOVF   x8E,F
0760:  BNZ   076A
0762:  MOVF   x8D,F
0764:  BNZ   076A
0766:  CLRF   00
0768:  BRA    07AC
076A:  BTFSC  x8F.7
076C:  BRA    077E
076E:  BCF    FD8.0
0770:  RLCF   x8C,F
0772:  RLCF   x8D,F
0774:  RLCF   x8E,F
0776:  RLCF   x8F,F
0778:  DECFSZ 00,F
077A:  BRA    076A
077C:  BRA    07BA
077E:  BTFSS  x8A.7
0780:  BRA    0786
0782:  BSF    x8F.7
0784:  BRA    07AC
0786:  BCF    x8F.7
0788:  BRA    07AC
078A:  MOVFF  85,00
078E:  MOVFF  86,8F
0792:  MOVFF  87,8E
0796:  MOVFF  88,8D
079A:  BRA    07AC
079C:  MOVFF  81,00
07A0:  MOVFF  82,8F
07A4:  MOVFF  83,8E
07A8:  MOVFF  84,8D
07AC:  MOVFF  8F,01
07B0:  MOVFF  8E,02
07B4:  MOVFF  8D,03
07B8:  BRA    0822
07BA:  CLRF   00
07BC:  CLRF   01
07BE:  CLRF   02
07C0:  CLRF   03
07C2:  BRA    0822
07C4:  CLRF   x8C
07C6:  COMF   x8D,F
07C8:  COMF   x8E,F
07CA:  COMF   x8F,F
07CC:  COMF   x8C,F
07CE:  INCF   x8C,F
07D0:  BNZ   07DC
07D2:  INCF   x8D,F
07D4:  BNZ   07DC
07D6:  INCF   x8E,F
07D8:  BNZ   07DC
07DA:  INCF   x8F,F
07DC:  BTFSC  x8B.0
07DE:  BRA    060A
07E0:  BTFSC  x8B.1
07E2:  BRA    0690
07E4:  BTFSC  x8B.2
07E6:  BRA    06FC
07E8:  BRA    0750
07EA:  MOVF   FEF,W
07EC:  ADDWF  x8D,F
07EE:  BNC   07FA
07F0:  INCF   x8E,F
07F2:  BNZ   07FA
07F4:  INCF   x8F,F
07F6:  BTFSC  FD8.2
07F8:  BSF    x89.0
07FA:  MOVF   FED,F
07FC:  MOVF   FEF,W
07FE:  ADDWF  x8E,F
0800:  BNC   0808
0802:  INCF   x8F,F
0804:  BTFSC  FD8.2
0806:  BSF    x89.0
0808:  MOVF   FED,F
080A:  MOVF   FEF,W
080C:  BTFSC  FEF.7
080E:  BRA    0812
0810:  XORLW  80
0812:  ADDWF  x8F,F
0814:  BTFSC  FD8.0
0816:  BSF    x89.0
0818:  BTFSC  x8B.4
081A:  BRA    0618
081C:  BTFSC  x8B.5
081E:  BRA    069E
0820:  BRA    070A
0822:  RETURN 0
0824:  MOVF   x81,W
0826:  BTFSC  FD8.2
0828:  BRA    090C
082A:  MOVWF  00
082C:  MOVF   x85,W
082E:  BTFSC  FD8.2
0830:  BRA    090C
0832:  ADDWF  00,F
0834:  BNC   083E
0836:  MOVLW  81
0838:  ADDWF  00,F
083A:  BC    090C
083C:  BRA    0846
083E:  MOVLW  7F
0840:  SUBWF  00,F
0842:  BNC   090C
0844:  BZ    090C
0846:  MOVFF  82,89
084A:  MOVF   x86,W
084C:  XORWF  x89,F
084E:  BSF    x82.7
0850:  BSF    x86.7
0852:  MOVF   x84,W
0854:  MULWF  x88
0856:  MOVFF  FF4,8B
085A:  MOVF   x83,W
085C:  MULWF  x87
085E:  MOVFF  FF4,03
0862:  MOVFF  FF3,8A
0866:  MULWF  x88
0868:  MOVF   FF3,W
086A:  ADDWF  x8B,F
086C:  MOVF   FF4,W
086E:  ADDWFC x8A,F
0870:  MOVLW  00
0872:  ADDWFC 03,F
0874:  MOVF   x84,W
0876:  MULWF  x87
0878:  MOVF   FF3,W
087A:  ADDWF  x8B,F
087C:  MOVF   FF4,W
087E:  ADDWFC x8A,F
0880:  MOVLW  00
0882:  CLRF   02
0884:  ADDWFC 03,F
0886:  ADDWFC 02,F
0888:  MOVF   x82,W
088A:  MULWF  x88
088C:  MOVF   FF3,W
088E:  ADDWF  x8A,F
0890:  MOVF   FF4,W
0892:  ADDWFC 03,F
0894:  MOVLW  00
0896:  ADDWFC 02,F
0898:  MOVF   x82,W
089A:  MULWF  x87
089C:  MOVF   FF3,W
089E:  ADDWF  03,F
08A0:  MOVF   FF4,W
08A2:  ADDWFC 02,F
08A4:  MOVLW  00
08A6:  CLRF   01
08A8:  ADDWFC 01,F
08AA:  MOVF   x84,W
08AC:  MULWF  x86
08AE:  MOVF   FF3,W
08B0:  ADDWF  x8A,F
08B2:  MOVF   FF4,W
08B4:  ADDWFC 03,F
08B6:  MOVLW  00
08B8:  ADDWFC 02,F
08BA:  ADDWFC 01,F
08BC:  MOVF   x83,W
08BE:  MULWF  x86
08C0:  MOVF   FF3,W
08C2:  ADDWF  03,F
08C4:  MOVF   FF4,W
08C6:  ADDWFC 02,F
08C8:  MOVLW  00
08CA:  ADDWFC 01,F
08CC:  MOVF   x82,W
08CE:  MULWF  x86
08D0:  MOVF   FF3,W
08D2:  ADDWF  02,F
08D4:  MOVF   FF4,W
08D6:  ADDWFC 01,F
08D8:  INCF   00,F
08DA:  BTFSC  01.7
08DC:  BRA    08E8
08DE:  RLCF   x8A,F
08E0:  RLCF   03,F
08E2:  RLCF   02,F
08E4:  RLCF   01,F
08E6:  DECF   00,F
08E8:  MOVLW  00
08EA:  BTFSS  x8A.7
08EC:  BRA    0902
08EE:  INCF   03,F
08F0:  ADDWFC 02,F
08F2:  ADDWFC 01,F
08F4:  MOVF   01,W
08F6:  BNZ   0902
08F8:  MOVF   02,W
08FA:  BNZ   0902
08FC:  MOVF   03,W
08FE:  BNZ   0902
0900:  INCF   00,F
0902:  BTFSC  x89.7
0904:  BSF    01.7
0906:  BTFSS  x89.7
0908:  BCF    01.7
090A:  BRA    0914
090C:  CLRF   00
090E:  CLRF   01
0910:  CLRF   02
0912:  CLRF   03
0914:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=12 Mhz, crystal= 12 MHz)   // Selecciona la velocidad del oscilador interno 
*
00FE:  CLRF   FEA
0100:  MOVLW  5E
0102:  MOVWF  FE9
0104:  MOVF   FEF,W
0106:  BZ    0124
0108:  MOVLW  03
010A:  MOVWF  01
010C:  CLRF   00
010E:  DECFSZ 00,F
0110:  BRA    010E
0112:  DECFSZ 01,F
0114:  BRA    010C
0116:  MOVLW  E3
0118:  MOVWF  00
011A:  DECFSZ 00,F
011C:  BRA    011A
011E:  NOP   
0120:  DECFSZ FEF,F
0122:  BRA    0108
0124:  RETURN 0
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
0126:  MOVLW  08
0128:  MOVWF  01
012A:  MOVLW  02
012C:  MOVWF  00
012E:  DECFSZ 00,F
0130:  BRA    012E
0132:  BCF    F8C.7
0134:  BCF    F95.7
0136:  MOVLW  02
0138:  MOVWF  00
013A:  DECFSZ 00,F
013C:  BRA    013A
013E:  RLCF   x62,F
0140:  BCF    F8C.6
0142:  BTFSC  FD8.0
0144:  BSF    F95.6
0146:  BTFSS  FD8.0
0148:  BCF    F95.6
014A:  BSF    F95.7
014C:  BTFSS  F83.7
014E:  BRA    014C
0150:  DECFSZ 01,F
0152:  BRA    012A
0154:  MOVLW  02
0156:  MOVWF  00
0158:  DECFSZ 00,F
015A:  BRA    0158
015C:  BCF    F8C.7
015E:  BCF    F95.7
0160:  NOP   
0162:  BSF    F95.6
0164:  MOVLW  02
0166:  MOVWF  00
0168:  DECFSZ 00,F
016A:  BRA    0168
016C:  MOVLW  02
016E:  MOVWF  00
0170:  DECFSZ 00,F
0172:  BRA    0170
0174:  BSF    F95.7
0176:  BTFSS  F83.7
0178:  BRA    0176
017A:  CLRF   01
017C:  MOVLW  02
017E:  MOVWF  00
0180:  DECFSZ 00,F
0182:  BRA    0180
0184:  BTFSC  F83.6
0186:  BSF    01.0
0188:  BCF    F8C.7
018A:  BCF    F95.7
018C:  BCF    F8C.6
018E:  BCF    F95.6
0190:  RETURN 0
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
*
1614:  CLRF   26
1616:  MOVF   FC1,W
1618:  ANDLW  C0
161A:  IORLW  0F
161C:  MOVWF  FC1
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
*
1602:  CLRF   19
1604:  CLRF   1A
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
....................         delay_us(20); 
....................         i2c_write(LCD_ADDR); //the slave addresse 
....................         delay_us(20); 
....................         i2c_write(data); 
....................         delay_us(20); 
....................         i2c_stop(); 
....................         delay_us(20); 
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
....................         i2c_send_nibble(data); 
....................         data=data-4;       //toggle EN back to 0 
....................         i2c_send_nibble(data); 
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
....................     lcd_send_byte(0x10); 
....................     delay_ms(2); 
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x30); 
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x20); 
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
....................         lcd_send_byte(0x80); 
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0xC0); 
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x60); 
....................            //clears the display 
....................         lcd_clear(); 
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
1606:  CLRF   21
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
....................       case 2:  address= lcd_line_two;     break; 
....................       case 3:  address= lcd_line_three;   break; 
....................       case 4:  address= lcd_line_four;    break; 
....................       default: address= lcd_line_one;     break;  
....................    } 
....................   
....................    address+=x-1; 
....................    data=address&0xF0; 
....................    lcd_send_byte(data); 
....................    data=address&0x0F; 
....................    data=data<<4; 
....................    lcd_send_byte(data); 
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
....................      case '\1': lcd_gotoxy(1,1);  break; 
....................      case '\2': lcd_gotoxy(1,2);  break; 
....................      case '\3': lcd_gotoxy(1,3);  break; 
....................      case '\4': lcd_gotoxy(1,4);  break; 
....................  
....................      default: 
....................         data=in_data&0xF0; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................         data=in_data&0x0F; 
....................         data=data<<4; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................      break; 
....................    } 
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
....................  
.................... const long carga= 0xF485; 
.................... extern int contador; 
.................... extern long pulso_timer; 
....................  
.................... void inicializar(); 
....................  
.................... void main() 
*
15F2:  CLRF   FF8
15F4:  BCF    FD0.7
15F6:  BSF    07.7
15F8:  BSF    20.0
15FA:  CLRF   24
15FC:  CLRF   23
15FE:  BSF    20.0
1600:  BSF    20.0
*
1608:  CLRF   22
160A:  CLRF   25
160C:  BSF    20.0
160E:  CLRF   4E
1610:  CLRF   24
1612:  CLRF   23
*
161E:  MOVLW  07
1620:  MOVWF  FB4
.................... { 
....................  
.................... //declaracion de variables 
.................... //inicializacion de perifericos 
....................  
.................... 	inicializar() ; 
1622:  GOTO   0382
....................  
....................     set_timer0(carga); 
1626:  MOVLW  F4
1628:  MOVWF  FD7
162A:  MOVLW  85
162C:  MOVWF  FD6
.................... 	while(1) 
.................... 	{ 
....................  
.................... 		maquina_estado(); 
162E:  BRA    109E
1630:  BRA    162E
....................  
.................... 	} 
.................... } 
....................  
1632:  SLEEP 
.................... void Inicializar(){ 
....................  
....................     setup_adc_ports(AN0);                                   //Canal 0 analgico 
*
0382:  MOVF   FC1,W
0384:  ANDLW  C0
0386:  IORLW  0E
0388:  MOVWF  FC1
....................     setup_adc(ADC_CLOCK_DIV_16);    
038A:  MOVF   FC0,W
038C:  ANDLW  C0
038E:  IORLW  05
0390:  MOVWF  FC0
0392:  BCF    FC0.7
0394:  BSF    FC2.0
....................     setup_timer_0( RTCC_INTERNAL | T0_DIV_2); 
0396:  MOVLW  80
0398:  MOVWF  FD5
....................     set_tris_a(0xF9); 
039A:  MOVLW  F9
039C:  MOVWF  F92
....................     contador=1; 
039E:  MOVLW  01
03A0:  MOVWF  22
....................     lcd_init(); 
03A2:  BRA    0240
....................     lcd_gotoxy(1,1); 
03A4:  MOVLW  01
03A6:  MOVWF  5E
03A8:  MOVWF  5F
03AA:  RCALL  029C
....................     printf(LCD_PUTC,"Primer prueba"); 
03AC:  MOVLW  AE
03AE:  MOVWF  FF6
03B0:  MOVLW  00
03B2:  MOVWF  FF7
03B4:  BRA    0360
....................     lcd_backlight=ON; 
03B6:  BSF    20.0
....................     enable_interrupts (INT_RTCC); 
03B8:  BSF    FF2.5
....................     enable_interrupts (GLOBAL); 
03BA:  MOVLW  C0
03BC:  IORWF  FF2,F
03BE:  GOTO   1626 (RETURN)
....................      
.................... } 
....................  
....................  
.................... /** 
.................... *	\file funciones.c 
.................... *	\brief  
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
00CC:  DATA 53,65
00CE:  DATA 20,6D
00D0:  DATA 69,64
00D2:  DATA 69,6F
00D4:  DATA 20,64
00D6:  DATA 65,73
00D8:  DATA 66,61
00DA:  DATA 73,65
00DC:  DATA 00,00
00DE:  DATA 50,6F
00E0:  DATA 74,65
00E2:  DATA 6E,63
00E4:  DATA 69,61
00E6:  DATA 3D,20
00E8:  DATA 25,66
00EA:  DATA 20,57
00EC:  DATA 00,00
00EE:  DATA 54,3D
00F0:  DATA 25,66
00F2:  DATA 20,56
00F4:  DATA 20,20
00F6:  DATA 49,3D
00F8:  DATA 25,66
00FA:  DATA 20,41
00FC:  DATA 00,00
*
0916:  MOVFF  7E,85
091A:  MOVF   x82,W
091C:  XORWF  x85,F
091E:  BTFSS  x85.7
0920:  BRA    092C
0922:  BCF    FD8.2
0924:  BCF    FD8.0
0926:  BTFSC  x7E.7
0928:  BSF    FD8.0
092A:  BRA    098A
092C:  MOVFF  7E,85
0930:  MOVFF  81,86
0934:  MOVF   x7D,W
0936:  SUBWF  x86,F
0938:  BZ    0946
093A:  BTFSS  x85.7
093C:  BRA    098A
093E:  MOVF   FD8,W
0940:  XORLW  01
0942:  MOVWF  FD8
0944:  BRA    098A
0946:  MOVFF  82,86
094A:  MOVF   x7E,W
094C:  SUBWF  x86,F
094E:  BZ    095C
0950:  BTFSS  x85.7
0952:  BRA    098A
0954:  MOVF   FD8,W
0956:  XORLW  01
0958:  MOVWF  FD8
095A:  BRA    098A
095C:  MOVFF  83,86
0960:  MOVF   x7F,W
0962:  SUBWF  x86,F
0964:  BZ    0972
0966:  BTFSS  x85.7
0968:  BRA    098A
096A:  MOVF   FD8,W
096C:  XORLW  01
096E:  MOVWF  FD8
0970:  BRA    098A
0972:  MOVFF  84,86
0976:  MOVF   x80,W
0978:  SUBWF  x86,F
097A:  BZ    0988
097C:  BTFSS  x85.7
097E:  BRA    098A
0980:  MOVF   FD8,W
0982:  XORLW  01
0984:  MOVWF  FD8
0986:  BRA    098A
0988:  BCF    FD8.0
098A:  RETURN 0
*
0A96:  TBLRD*+
0A98:  MOVF   FF5,F
0A9A:  BZ    0AB4
0A9C:  MOVFF  FF6,4F
0AA0:  MOVFF  FF7,50
0AA4:  MOVFF  FF5,5D
0AA8:  RCALL  02F2
0AAA:  MOVFF  4F,FF6
0AAE:  MOVFF  50,FF7
0AB2:  BRA    0A96
0AB4:  GOTO   147E (RETURN)
0AB8:  MOVLW  8E
0ABA:  MOVWF  00
0ABC:  MOVF   x7D,W
0ABE:  SUBWF  00,F
0AC0:  MOVFF  7E,02
0AC4:  MOVFF  7F,01
0AC8:  BSF    02.7
0ACA:  MOVF   00,F
0ACC:  BZ    0AE0
0ACE:  BCF    FD8.0
0AD0:  MOVF   02,F
0AD2:  BNZ   0AD8
0AD4:  MOVF   01,F
0AD6:  BZ    0AE0
0AD8:  RRCF   02,F
0ADA:  RRCF   01,F
0ADC:  DECFSZ 00,F
0ADE:  BRA    0ACE
0AE0:  BTFSS  x7E.7
0AE2:  BRA    0AEE
0AE4:  COMF   01,F
0AE6:  COMF   02,F
0AE8:  INCF   01,F
0AEA:  BTFSC  FD8.2
0AEC:  INCF   02,F
0AEE:  GOTO   0B9E (RETURN)
*
0E30:  TBLRD*+
0E32:  MOVFF  FF6,50
0E36:  MOVFF  FF7,51
0E3A:  MOVFF  FF5,5D
0E3E:  CALL   02F2
0E42:  MOVFF  50,FF6
0E46:  MOVFF  51,FF7
0E4A:  DECFSZ 4F,F
0E4C:  BRA    0E30
0E4E:  RETURN 0
0E50:  MOVF   5C,W
0E52:  SUBLW  B6
0E54:  MOVWF  5C
0E56:  CLRF   03
0E58:  MOVFF  5D,60
0E5C:  BSF    5D.7
0E5E:  BCF    FD8.0
0E60:  RRCF   5D,F
0E62:  RRCF   5E,F
0E64:  RRCF   5F,F
0E66:  RRCF   03,F
0E68:  RRCF   02,F
0E6A:  RRCF   01,F
0E6C:  RRCF   00,F
0E6E:  DECFSZ 5C,F
0E70:  BRA    0E5E
0E72:  BTFSS  x60.7
0E74:  BRA    0E8C
0E76:  COMF   00,F
0E78:  COMF   01,F
0E7A:  COMF   02,F
0E7C:  COMF   03,F
0E7E:  INCF   00,F
0E80:  BTFSC  FD8.2
0E82:  INCF   01,F
0E84:  BTFSC  FD8.2
0E86:  INCF   02,F
0E88:  BTFSC  FD8.2
0E8A:  INCF   03,F
0E8C:  GOTO   0F6C (RETURN)
0E90:  BTFSC  FD8.1
0E92:  BRA    0E9A
0E94:  CLRF   FEA
0E96:  MOVLW  64
0E98:  MOVWF  FE9
0E9A:  CLRF   00
0E9C:  CLRF   01
0E9E:  CLRF   02
0EA0:  CLRF   03
0EA2:  CLRF   x64
0EA4:  CLRF   x65
0EA6:  CLRF   x66
0EA8:  CLRF   x67
0EAA:  MOVF   x63,W
0EAC:  IORWF  x62,W
0EAE:  IORWF  x61,W
0EB0:  IORWF  x60,W
0EB2:  BZ    0F0C
0EB4:  MOVLW  20
0EB6:  MOVWF  x68
0EB8:  BCF    FD8.0
0EBA:  RLCF   5C,F
0EBC:  RLCF   5D,F
0EBE:  RLCF   5E,F
0EC0:  RLCF   5F,F
0EC2:  RLCF   x64,F
0EC4:  RLCF   x65,F
0EC6:  RLCF   x66,F
0EC8:  RLCF   x67,F
0ECA:  MOVF   x63,W
0ECC:  SUBWF  x67,W
0ECE:  BNZ   0EE0
0ED0:  MOVF   x62,W
0ED2:  SUBWF  x66,W
0ED4:  BNZ   0EE0
0ED6:  MOVF   x61,W
0ED8:  SUBWF  x65,W
0EDA:  BNZ   0EE0
0EDC:  MOVF   x60,W
0EDE:  SUBWF  x64,W
0EE0:  BNC   0F00
0EE2:  MOVF   x60,W
0EE4:  SUBWF  x64,F
0EE6:  MOVF   x61,W
0EE8:  BTFSS  FD8.0
0EEA:  INCFSZ x61,W
0EEC:  SUBWF  x65,F
0EEE:  MOVF   x62,W
0EF0:  BTFSS  FD8.0
0EF2:  INCFSZ x62,W
0EF4:  SUBWF  x66,F
0EF6:  MOVF   x63,W
0EF8:  BTFSS  FD8.0
0EFA:  INCFSZ x63,W
0EFC:  SUBWF  x67,F
0EFE:  BSF    FD8.0
0F00:  RLCF   00,F
0F02:  RLCF   01,F
0F04:  RLCF   02,F
0F06:  RLCF   03,F
0F08:  DECFSZ x68,F
0F0A:  BRA    0EB8
0F0C:  MOVFF  64,FEF
0F10:  MOVFF  65,FEC
0F14:  MOVFF  66,FEC
0F18:  MOVFF  67,FEC
0F1C:  RETURN 0
0F1E:  MOVF   FE9,W
0F20:  MOVWF  54
0F22:  MOVF   53,W
0F24:  MOVWF  56
0F26:  BZ    0F5A
0F28:  MOVFF  52,84
0F2C:  MOVFF  51,83
0F30:  MOVFF  50,82
0F34:  MOVFF  4F,81
0F38:  CLRF   x88
0F3A:  CLRF   x87
0F3C:  MOVLW  20
0F3E:  MOVWF  x86
0F40:  MOVLW  82
0F42:  MOVWF  x85
0F44:  RCALL  0824
0F46:  MOVFF  03,52
0F4A:  MOVFF  02,51
0F4E:  MOVFF  01,50
0F52:  MOVFF  00,4F
0F56:  DECFSZ 56,F
0F58:  BRA    0F28
0F5A:  MOVFF  52,5F
0F5E:  MOVFF  51,5E
0F62:  MOVFF  50,5D
0F66:  MOVFF  4F,5C
0F6A:  BRA    0E50
0F6C:  MOVFF  03,52
0F70:  MOVFF  02,51
0F74:  MOVFF  01,50
0F78:  MOVFF  00,4F
0F7C:  BTFSS  52.7
0F7E:  BRA    0F9A
0F80:  DECF   54,F
0F82:  BSF    54.5
0F84:  COMF   4F,F
0F86:  COMF   50,F
0F88:  COMF   51,F
0F8A:  COMF   52,F
0F8C:  INCF   4F,F
0F8E:  BTFSC  FD8.2
0F90:  INCF   50,F
0F92:  BTFSC  FD8.2
0F94:  INCF   51,F
0F96:  BTFSC  FD8.2
0F98:  INCF   52,F
0F9A:  MOVLW  3B
0F9C:  MOVWF  5B
0F9E:  MOVLW  9A
0FA0:  MOVWF  5A
0FA2:  MOVLW  CA
0FA4:  MOVWF  59
0FA6:  CLRF   58
0FA8:  MOVLW  0A
0FAA:  MOVWF  56
0FAC:  MOVF   53,W
0FAE:  BTFSC  FD8.2
0FB0:  INCF   54,F
0FB2:  BSF    FD8.1
0FB4:  CLRF   FEA
0FB6:  MOVLW  4F
0FB8:  MOVWF  FE9
0FBA:  MOVFF  52,5F
0FBE:  MOVFF  51,5E
0FC2:  MOVFF  50,5D
0FC6:  MOVFF  4F,5C
0FCA:  MOVFF  5B,63
0FCE:  MOVFF  5A,62
0FD2:  MOVFF  59,61
0FD6:  MOVFF  58,60
0FDA:  RCALL  0E90
0FDC:  MOVF   01,W
0FDE:  MOVF   00,F
0FE0:  BNZ   1000
0FE2:  INCF   53,W
0FE4:  SUBWF  56,W
0FE6:  BZ    1000
0FE8:  MOVF   54,W
0FEA:  BZ    1004
0FEC:  ANDLW  0F
0FEE:  SUBWF  56,W
0FF0:  BZ    0FF4
0FF2:  BC    106A
0FF4:  BTFSC  54.7
0FF6:  BRA    106A
0FF8:  BTFSC  54.6
0FFA:  BRA    1004
0FFC:  MOVLW  20
0FFE:  BRA    1060
1000:  MOVLW  20
1002:  ANDWF  54,F
1004:  BTFSS  54.5
1006:  BRA    1022
1008:  BCF    54.5
100A:  MOVF   53,W
100C:  BTFSS  FD8.2
100E:  DECF   54,F
1010:  MOVF   00,W
1012:  MOVWF  54
1014:  MOVLW  2D
1016:  MOVWF  5D
1018:  CALL   02F2
101C:  MOVF   54,W
101E:  MOVWF  00
1020:  CLRF   54
1022:  MOVF   53,W
1024:  SUBWF  56,W
1026:  BNZ   103E
1028:  MOVF   00,W
102A:  MOVWF  54
102C:  MOVLW  2E
102E:  MOVWF  5D
1030:  CALL   02F2
1034:  MOVF   54,W
1036:  MOVWF  00
1038:  MOVLW  20
103A:  ANDWF  54,F
103C:  MOVLW  00
103E:  MOVLW  30
1040:  BTFSS  54.5
1042:  BRA    1060
1044:  BCF    54.5
1046:  MOVF   53,W
1048:  BTFSS  FD8.2
104A:  DECF   54,F
104C:  MOVF   00,W
104E:  MOVWF  54
1050:  MOVLW  2D
1052:  MOVWF  5D
1054:  CALL   02F2
1058:  MOVF   54,W
105A:  MOVWF  00
105C:  CLRF   54
105E:  MOVLW  30
1060:  ADDWF  00,F
1062:  MOVFF  00,5D
1066:  CALL   02F2
106A:  BCF    FD8.1
106C:  MOVFF  5B,5F
1070:  MOVFF  5A,5E
1074:  MOVFF  59,5D
1078:  MOVFF  58,5C
107C:  CLRF   x63
107E:  CLRF   x62
1080:  CLRF   x61
1082:  MOVLW  0A
1084:  MOVWF  x60
1086:  RCALL  0E90
1088:  MOVFF  03,5B
108C:  MOVFF  02,5A
1090:  MOVFF  01,59
1094:  MOVFF  00,58
1098:  DECFSZ 56,F
109A:  BRA    0FB2
109C:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=12 Mhz, crystal= 12 MHz)   // Selecciona la velocidad del oscilador interno 
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
.................... int contador = 0 ;int pulso_timer = 0 ; 
.................... #include "funciones.h"  
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
*
0192:  BSF    F95.6
0194:  MOVLW  02
0196:  MOVWF  00
0198:  DECFSZ 00,F
019A:  BRA    0198
019C:  BSF    F95.7
019E:  MOVLW  02
01A0:  MOVWF  00
01A2:  DECFSZ 00,F
01A4:  BRA    01A2
01A6:  BCF    F8C.6
01A8:  BCF    F95.6
01AA:  MOVLW  02
01AC:  MOVWF  00
01AE:  DECFSZ 00,F
01B0:  BRA    01AE
01B2:  BCF    F8C.7
01B4:  BCF    F95.7
....................         delay_us(20); 
01B6:  MOVLW  13
01B8:  MOVWF  00
01BA:  DECFSZ 00,F
01BC:  BRA    01BA
01BE:  BRA    01C0
....................         i2c_write(LCD_ADDR); //the slave addresse 
01C0:  MOVLW  4E
01C2:  MOVWF  x62
01C4:  RCALL  0126
....................         delay_us(20); 
01C6:  MOVLW  13
01C8:  MOVWF  00
01CA:  DECFSZ 00,F
01CC:  BRA    01CA
01CE:  BRA    01D0
....................         i2c_write(data); 
01D0:  MOVFF  61,62
01D4:  RCALL  0126
....................         delay_us(20); 
01D6:  MOVLW  13
01D8:  MOVWF  00
01DA:  DECFSZ 00,F
01DC:  BRA    01DA
01DE:  BRA    01E0
....................         i2c_stop(); 
01E0:  BCF    F95.6
01E2:  NOP   
01E4:  BSF    F95.7
01E6:  BTFSS  F83.7
01E8:  BRA    01E6
01EA:  MOVLW  02
01EC:  MOVWF  00
01EE:  DECFSZ 00,F
01F0:  BRA    01EE
01F2:  BRA    01F4
01F4:  NOP   
01F6:  BSF    F95.6
01F8:  MOVLW  02
01FA:  MOVWF  00
01FC:  DECFSZ 00,F
01FE:  BRA    01FC
....................         delay_us(20); 
0200:  MOVLW  13
0202:  MOVWF  00
0204:  DECFSZ 00,F
0206:  BRA    0204
0208:  BRA    020A
020A:  RETURN 0
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
020C:  BTFSS  20.0
020E:  BRA    021A
0210:  MOVF   x60,W
0212:  IORLW  04
0214:  IORLW  08
0216:  MOVWF  x60
0218:  BRA    021C
021A:  BSF    x60.2
....................         i2c_send_nibble(data); 
021C:  MOVFF  60,61
0220:  RCALL  0192
....................         data=data-4;       //toggle EN back to 0 
0222:  MOVLW  04
0224:  SUBWF  x60,F
....................         i2c_send_nibble(data); 
0226:  MOVFF  60,61
022A:  RCALL  0192
022C:  RETURN 0
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
022E:  CLRF   x60
0230:  RCALL  020C
....................     lcd_send_byte(0x10); 
0232:  MOVLW  10
0234:  MOVWF  x60
0236:  RCALL  020C
....................     delay_ms(2); 
0238:  MOVLW  02
023A:  MOVWF  5E
023C:  RCALL  00FE
023E:  RETURN 0
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
0240:  MOVLW  C8
0242:  MOVWF  5E
0244:  RCALL  00FE
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
0246:  CLRF   x60
0248:  RCALL  020C
....................         lcd_send_byte(0x10); 
024A:  MOVLW  10
024C:  MOVWF  x60
024E:  RCALL  020C
....................         lcd_send_byte(0x00); 
0250:  CLRF   x60
0252:  RCALL  020C
....................         lcd_send_byte(0x00); 
0254:  CLRF   x60
0256:  RCALL  020C
....................         lcd_send_byte(0x10); 
0258:  MOVLW  10
025A:  MOVWF  x60
025C:  RCALL  020C
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
025E:  MOVLW  30
0260:  MOVWF  x60
0262:  RCALL  020C
....................         lcd_send_byte(0x30); 
0264:  MOVLW  30
0266:  MOVWF  x60
0268:  RCALL  020C
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
026A:  MOVLW  30
026C:  MOVWF  x60
026E:  RCALL  020C
....................         lcd_send_byte(0x20); 
0270:  MOVLW  20
0272:  MOVWF  x60
0274:  RCALL  020C
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
0276:  MOVLW  20
0278:  MOVWF  x60
027A:  RCALL  020C
....................         lcd_send_byte(0x80); 
027C:  MOVLW  80
027E:  MOVWF  x60
0280:  RCALL  020C
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
0282:  CLRF   x60
0284:  RCALL  020C
....................         lcd_send_byte(0xC0); 
0286:  MOVLW  C0
0288:  MOVWF  x60
028A:  RCALL  020C
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
028C:  CLRF   x60
028E:  RCALL  020C
....................         lcd_send_byte(0x60); 
0290:  MOVLW  60
0292:  MOVWF  x60
0294:  RCALL  020C
....................            //clears the display 
....................         lcd_clear(); 
0296:  RCALL  022E
0298:  GOTO   03A4 (RETURN)
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
029C:  MOVF   5F,W
029E:  XORLW  01
02A0:  BZ    02B0
02A2:  XORLW  03
02A4:  BZ    02B6
02A6:  XORLW  01
02A8:  BZ    02BC
02AA:  XORLW  07
02AC:  BZ    02C2
02AE:  BRA    02C8
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
02B0:  MOVLW  80
02B2:  MOVWF  1F
02B4:  BRA    02CC
....................       case 2:  address= lcd_line_two;     break; 
02B6:  MOVLW  C0
02B8:  MOVWF  1F
02BA:  BRA    02CC
....................       case 3:  address= lcd_line_three;   break; 
02BC:  MOVLW  94
02BE:  MOVWF  1F
02C0:  BRA    02CC
....................       case 4:  address= lcd_line_four;    break; 
02C2:  MOVLW  D4
02C4:  MOVWF  1F
02C6:  BRA    02CC
....................       default: address= lcd_line_one;     break;  
02C8:  MOVLW  80
02CA:  MOVWF  1F
....................    } 
....................   
....................    address+=x-1; 
02CC:  MOVLW  01
02CE:  SUBWF  5E,W
02D0:  ADDWF  1F,F
....................    data=address&0xF0; 
02D2:  MOVF   1F,W
02D4:  ANDLW  F0
02D6:  MOVWF  26
....................    lcd_send_byte(data); 
02D8:  MOVFF  26,60
02DC:  RCALL  020C
....................    data=address&0x0F; 
02DE:  MOVF   1F,W
02E0:  ANDLW  0F
02E2:  MOVWF  26
....................    data=data<<4; 
02E4:  SWAPF  26,F
02E6:  MOVLW  F0
02E8:  ANDWF  26,F
....................    lcd_send_byte(data); 
02EA:  MOVFF  26,60
02EE:  RCALL  020C
02F0:  RETURN 0
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
02F2:  MOVF   5D,W
02F4:  XORLW  0C
02F6:  BZ    030A
02F8:  XORLW  0D
02FA:  BZ    030E
02FC:  XORLW  03
02FE:  BZ    0318
0300:  XORLW  01
0302:  BZ    0324
0304:  XORLW  07
0306:  BZ    0330
0308:  BRA    033C
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
030A:  RCALL  022E
030C:  BRA    035E
....................      case '\1': lcd_gotoxy(1,1);  break; 
030E:  MOVLW  01
0310:  MOVWF  5E
0312:  MOVWF  5F
0314:  RCALL  029C
0316:  BRA    035E
....................      case '\2': lcd_gotoxy(1,2);  break; 
0318:  MOVLW  01
031A:  MOVWF  5E
031C:  MOVLW  02
031E:  MOVWF  5F
0320:  RCALL  029C
0322:  BRA    035E
....................      case '\3': lcd_gotoxy(1,3);  break; 
0324:  MOVLW  01
0326:  MOVWF  5E
0328:  MOVLW  03
032A:  MOVWF  5F
032C:  RCALL  029C
032E:  BRA    035E
....................      case '\4': lcd_gotoxy(1,4);  break; 
0330:  MOVLW  01
0332:  MOVWF  5E
0334:  MOVLW  04
0336:  MOVWF  5F
0338:  RCALL  029C
033A:  BRA    035E
....................  
....................      default: 
....................         data=in_data&0xF0; 
033C:  MOVF   5D,W
033E:  ANDLW  F0
0340:  MOVWF  5E
....................         data=data|RS; //set RS pin to 1 
0342:  BSF    5E.0
....................         lcd_send_byte(data); 
0344:  MOVFF  5E,60
0348:  RCALL  020C
....................         data=in_data&0x0F; 
034A:  MOVF   5D,W
034C:  ANDLW  0F
034E:  MOVWF  5E
....................         data=data<<4; 
0350:  SWAPF  5E,F
0352:  MOVLW  F0
0354:  ANDWF  5E,F
....................         data=data|RS; //set RS pin to 1 
0356:  BSF    5E.0
....................         lcd_send_byte(data); 
0358:  MOVFF  5E,60
035C:  RCALL  020C
....................      break; 
....................    } 
035E:  RETURN 0
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
098C:  MOVFF  56,80
0990:  MOVFF  55,7F
0994:  MOVFF  54,7E
0998:  MOVFF  53,7D
099C:  CLRF   x84
099E:  CLRF   x83
09A0:  CLRF   x82
09A2:  CLRF   x81
09A4:  RCALL  0916
09A6:  BC    09AA
09A8:  BNZ   09B4
....................       return(0.0); 
09AA:  CLRF   00
09AC:  CLRF   01
09AE:  CLRF   02
09B0:  CLRF   03
09B2:  BRA    0A94
....................  
....................    y=x; 
09B4:  MOVFF  56,5A
09B8:  MOVFF  55,59
09BC:  MOVFF  54,58
09C0:  MOVFF  53,57
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
09C4:  CLRF   x60
09C6:  MOVLW  57
09C8:  MOVWF  5F
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
09CA:  MOVFF  5F,FE9
09CE:  MOVFF  60,FEA
09D2:  MOVF   FEF,W
09D4:  CLRF   x64
09D6:  MOVWF  x63
09D8:  MOVLW  7F
09DA:  ADDWF  x63,F
09DC:  MOVLW  00
09DE:  ADDWFC x64,F
09E0:  BCF    FD8.0
09E2:  RRCF   x64,W
09E4:  RRCF   x63,W
09E6:  MOVFF  60,FEA
09EA:  MOVFF  5F,FE9
09EE:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
09F0:  MOVFF  5A,5E
09F4:  MOVFF  59,5D
09F8:  MOVFF  58,5C
09FC:  MOVFF  57,5B
....................       y+=(x/y); 
0A00:  MOVFF  56,64
0A04:  MOVFF  55,63
0A08:  MOVFF  54,62
0A0C:  MOVFF  53,61
0A10:  MOVFF  5A,68
0A14:  MOVFF  59,67
0A18:  MOVFF  58,66
0A1C:  MOVFF  57,65
0A20:  RCALL  0460
0A22:  BCF    FD8.1
0A24:  MOVFF  5A,84
0A28:  MOVFF  59,83
0A2C:  MOVFF  58,82
0A30:  MOVFF  57,81
0A34:  MOVFF  03,88
0A38:  MOVFF  02,87
0A3C:  MOVFF  01,86
0A40:  MOVFF  00,85
0A44:  RCALL  05BA
0A46:  MOVFF  03,5A
0A4A:  MOVFF  02,59
0A4E:  MOVFF  01,58
0A52:  MOVFF  00,57
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
0A56:  MOVFF  5F,FE9
0A5A:  MOVFF  60,FEA
0A5E:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
0A60:  MOVFF  5E,80
0A64:  MOVFF  5D,7F
0A68:  MOVFF  5C,7E
0A6C:  MOVFF  5B,7D
0A70:  MOVFF  5A,84
0A74:  MOVFF  59,83
0A78:  MOVFF  58,82
0A7C:  MOVFF  57,81
0A80:  RCALL  0916
0A82:  BNZ   09F0
....................  
....................    return(res); 
0A84:  MOVFF  5B,00
0A88:  MOVFF  5C,01
0A8C:  MOVFF  5D,02
0A90:  MOVFF  5E,03
0A94:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
0AF2:  CLRF   x62
0AF4:  CLRF   x61
0AF6:  CLRF   x60
0AF8:  MOVLW  7F
0AFA:  MOVWF  5F
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
0AFC:  MOVLW  7E
0AFE:  MOVWF  x69
0B00:  MOVLW  80
0B02:  MOVWF  x6A
0B04:  CLRF   x6B
0B06:  CLRF   x6C
0B08:  MOVLW  7A
0B0A:  MOVWF  x6D
0B0C:  MOVLW  2A
0B0E:  MOVWF  x6E
0B10:  MOVLW  AA
0B12:  MOVWF  x6F
0B14:  MOVLW  A3
0B16:  MOVWF  x70
0B18:  MOVLW  75
0B1A:  MOVWF  x71
0B1C:  MOVLW  B6
0B1E:  MOVWF  x72
0B20:  MOVLW  09
0B22:  MOVWF  x73
0B24:  MOVLW  B4
0B26:  MOVWF  x74
0B28:  MOVLW  6F
0B2A:  MOVWF  x75
0B2C:  MOVLW  4F
0B2E:  MOVWF  x76
0B30:  MOVLW  B6
0B32:  MOVWF  x77
0B34:  MOVLW  AA
0B36:  MOVWF  x78
0B38:  MOVLW  69
0B3A:  MOVWF  x79
0B3C:  MOVLW  8B
0B3E:  MOVWF  x7A
0B40:  MOVLW  F6
0B42:  MOVWF  x7B
0B44:  MOVLW  E8
0B46:  MOVWF  x7C
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0B48:  MOVFF  56,80
0B4C:  MOVFF  55,7F
0B50:  MOVFF  54,7E
0B54:  MOVFF  53,7D
0B58:  CLRF   x84
0B5A:  CLRF   x83
0B5C:  CLRF   x82
0B5E:  CLRF   x81
0B60:  RCALL  0916
0B62:  BNC   0B6A
0B64:  MOVF   54,W
0B66:  XORLW  80
0B68:  MOVWF  54
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0B6A:  MOVFF  56,84
0B6E:  MOVFF  55,83
0B72:  MOVFF  54,82
0B76:  MOVFF  53,81
0B7A:  MOVLW  83
0B7C:  MOVWF  x88
0B7E:  MOVLW  F9
0B80:  MOVWF  x87
0B82:  MOVLW  22
0B84:  MOVWF  x86
0B86:  MOVLW  7E
0B88:  MOVWF  x85
0B8A:  RCALL  0824
0B8C:  MOVFF  03,80
0B90:  MOVFF  02,7F
0B94:  MOVFF  01,7E
0B98:  MOVFF  00,7D
0B9C:  BRA    0AB8
0B9E:  MOVFF  01,63
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0BA2:  MOVFF  56,84
0BA6:  MOVFF  55,83
0BAA:  MOVFF  54,82
0BAE:  MOVFF  53,81
0BB2:  MOVLW  83
0BB4:  MOVWF  x88
0BB6:  MOVLW  F9
0BB8:  MOVWF  x87
0BBA:  MOVLW  22
0BBC:  MOVWF  x86
0BBE:  MOVLW  7E
0BC0:  MOVWF  x85
0BC2:  RCALL  0824
0BC4:  MOVFF  03,80
0BC8:  MOVFF  02,7F
0BCC:  MOVFF  01,7E
0BD0:  MOVFF  00,7D
0BD4:  CLRF   x82
0BD6:  MOVFF  63,81
0BDA:  RCALL  042A
0BDC:  BSF    FD8.1
0BDE:  MOVFF  80,84
0BE2:  MOVFF  7F,83
0BE6:  MOVFF  7E,82
0BEA:  MOVFF  7D,81
0BEE:  MOVFF  03,88
0BF2:  MOVFF  02,87
0BF6:  MOVFF  01,86
0BFA:  MOVFF  00,85
0BFE:  RCALL  05BA
0C00:  MOVFF  03,68
0C04:  MOVFF  02,67
0C08:  MOVFF  01,66
0C0C:  MOVFF  00,65
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0C10:  MOVLW  03
0C12:  ANDWF  x63,F
....................  
....................    if (quad == 0 || quad == 2) 
0C14:  MOVF   x63,F
0C16:  BZ    0C1E
0C18:  MOVF   x63,W
0C1A:  SUBLW  02
0C1C:  BNZ   0C52
....................       t = frac * PI_DIV_BY_TWO; 
0C1E:  MOVFF  68,84
0C22:  MOVFF  67,83
0C26:  MOVFF  66,82
0C2A:  MOVFF  65,81
0C2E:  MOVLW  DB
0C30:  MOVWF  x88
0C32:  MOVLW  0F
0C34:  MOVWF  x87
0C36:  MOVLW  49
0C38:  MOVWF  x86
0C3A:  MOVLW  7F
0C3C:  MOVWF  x85
0C3E:  RCALL  0824
0C40:  MOVFF  03,5E
0C44:  MOVFF  02,5D
0C48:  MOVFF  01,5C
0C4C:  MOVFF  00,5B
0C50:  BRA    0D18
....................    else if (quad == 1) 
0C52:  DECFSZ x63,W
0C54:  BRA    0CB8
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0C56:  BSF    FD8.1
0C58:  CLRF   x84
0C5A:  CLRF   x83
0C5C:  CLRF   x82
0C5E:  MOVLW  7F
0C60:  MOVWF  x81
0C62:  MOVFF  68,88
0C66:  MOVFF  67,87
0C6A:  MOVFF  66,86
0C6E:  MOVFF  65,85
0C72:  RCALL  05BA
0C74:  MOVFF  03,80
0C78:  MOVFF  02,7F
0C7C:  MOVFF  01,7E
0C80:  MOVFF  00,7D
0C84:  MOVFF  03,84
0C88:  MOVFF  02,83
0C8C:  MOVFF  01,82
0C90:  MOVFF  00,81
0C94:  MOVLW  DB
0C96:  MOVWF  x88
0C98:  MOVLW  0F
0C9A:  MOVWF  x87
0C9C:  MOVLW  49
0C9E:  MOVWF  x86
0CA0:  MOVLW  7F
0CA2:  MOVWF  x85
0CA4:  RCALL  0824
0CA6:  MOVFF  03,5E
0CAA:  MOVFF  02,5D
0CAE:  MOVFF  01,5C
0CB2:  MOVFF  00,5B
0CB6:  BRA    0D18
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0CB8:  BSF    FD8.1
0CBA:  MOVFF  68,84
0CBE:  MOVFF  67,83
0CC2:  MOVFF  66,82
0CC6:  MOVFF  65,81
0CCA:  CLRF   x88
0CCC:  CLRF   x87
0CCE:  CLRF   x86
0CD0:  MOVLW  7F
0CD2:  MOVWF  x85
0CD4:  RCALL  05BA
0CD6:  MOVFF  03,80
0CDA:  MOVFF  02,7F
0CDE:  MOVFF  01,7E
0CE2:  MOVFF  00,7D
0CE6:  MOVFF  03,84
0CEA:  MOVFF  02,83
0CEE:  MOVFF  01,82
0CF2:  MOVFF  00,81
0CF6:  MOVLW  DB
0CF8:  MOVWF  x88
0CFA:  MOVLW  0F
0CFC:  MOVWF  x87
0CFE:  MOVLW  49
0D00:  MOVWF  x86
0D02:  MOVLW  7F
0D04:  MOVWF  x85
0D06:  RCALL  0824
0D08:  MOVFF  03,5E
0D0C:  MOVFF  02,5D
0D10:  MOVFF  01,5C
0D14:  MOVFF  00,5B
....................  
....................    y = 1.0; 
0D18:  CLRF   5A
0D1A:  CLRF   59
0D1C:  CLRF   58
0D1E:  MOVLW  7F
0D20:  MOVWF  57
....................    t = t * t; 
0D22:  MOVFF  5E,84
0D26:  MOVFF  5D,83
0D2A:  MOVFF  5C,82
0D2E:  MOVFF  5B,81
0D32:  MOVFF  5E,88
0D36:  MOVFF  5D,87
0D3A:  MOVFF  5C,86
0D3E:  MOVFF  5B,85
0D42:  RCALL  0824
0D44:  MOVFF  03,5E
0D48:  MOVFF  02,5D
0D4C:  MOVFF  01,5C
0D50:  MOVFF  00,5B
....................    for (i = 0; i <= 4; i++) 
0D54:  CLRF   x64
0D56:  MOVF   x64,W
0D58:  SUBLW  04
0D5A:  BNC   0E0C
....................    { 
....................       t2 = t2 * t; 
0D5C:  MOVFF  62,84
0D60:  MOVFF  61,83
0D64:  MOVFF  60,82
0D68:  MOVFF  5F,81
0D6C:  MOVFF  5E,88
0D70:  MOVFF  5D,87
0D74:  MOVFF  5C,86
0D78:  MOVFF  5B,85
0D7C:  RCALL  0824
0D7E:  MOVFF  03,62
0D82:  MOVFF  02,61
0D86:  MOVFF  01,60
0D8A:  MOVFF  00,5F
....................       y = y + p[i] * t2; 
0D8E:  MOVF   x64,W
0D90:  MULLW  04
0D92:  MOVF   FF3,W
0D94:  CLRF   03
0D96:  ADDLW  69
0D98:  MOVWF  FE9
0D9A:  MOVLW  00
0D9C:  ADDWFC 03,W
0D9E:  MOVWF  FEA
0DA0:  MOVFF  FEF,81
0DA4:  MOVFF  FEC,82
0DA8:  MOVFF  FEC,83
0DAC:  MOVFF  FEC,84
0DB0:  MOVFF  62,88
0DB4:  MOVFF  61,87
0DB8:  MOVFF  60,86
0DBC:  MOVFF  5F,85
0DC0:  RCALL  0824
0DC2:  MOVFF  FEA,7E
0DC6:  MOVFF  FE9,7D
0DCA:  BCF    FD8.1
0DCC:  MOVFF  5A,84
0DD0:  MOVFF  59,83
0DD4:  MOVFF  58,82
0DD8:  MOVFF  57,81
0DDC:  MOVFF  03,88
0DE0:  MOVFF  02,87
0DE4:  MOVFF  01,86
0DE8:  MOVFF  00,85
0DEC:  CALL   05BA
0DF0:  MOVFF  7E,FEA
0DF4:  MOVFF  7D,FE9
0DF8:  MOVFF  03,5A
0DFC:  MOVFF  02,59
0E00:  MOVFF  01,58
0E04:  MOVFF  00,57
0E08:  INCF   x64,F
0E0A:  BRA    0D56
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
0E0C:  MOVF   x63,W
0E0E:  SUBLW  02
0E10:  BZ    0E16
0E12:  DECFSZ x63,W
0E14:  BRA    0E1C
....................       y = -y;  // correct sign 
0E16:  MOVF   58,W
0E18:  XORLW  80
0E1A:  MOVWF  58
....................  
....................    return (y); 
0E1C:  MOVFF  57,00
0E20:  MOVFF  58,01
0E24:  MOVFF  59,02
0E28:  MOVFF  5A,03
0E2C:  GOTO   14D6 (RETURN)
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <MAX191.h> 
.................... /*  
....................  * File:   MAX191.h 
....................  * Author: MARCOS 
....................  * 
....................  * Created on 23 de septiembre de 2016, 08:14 
....................  */ 
....................  
.................... #ifndef MAX192_H 
.................... #define MAX192_H 
....................  
.................... #define ADC_CS1 PIN_A1 
.................... #define ADC_SCLK PIN_A2 
.................... #define ADC_DOUT PIN_A3 
....................  
.................... unsigned long leer_ADC(ADC){ 
....................     unsigned long dato; 
....................     int i; 
....................     output_low (ADC_SCLK); 
*
03C2:  BCF    F92.2
03C4:  BCF    F89.2
....................     output_low (ADC_CS1); 
03C6:  BCF    F92.1
03C8:  BCF    F89.1
....................      
....................      
....................     if (ADC==2){ 
03CA:  MOVF   4F,W
03CC:  SUBLW  02
03CE:  BNZ   0404
....................          
....................         output_low (ADC_CS1); // modo CPOL = 0, CPHA = 0 
03D0:  BCF    F92.1
03D2:  BCF    F89.1
....................         delay_us(1); 
03D4:  BRA    03D6
03D6:  NOP   
....................          
....................         for(i=0;i<16;i++){ 
03D8:  CLRF   52
03DA:  MOVF   52,W
03DC:  SUBLW  0F
03DE:  BNC   03FC
....................           output_high(ADC_SCLK); 
03E0:  BCF    F92.2
03E2:  BSF    F89.2
....................           shift_left(&dato,2,input(ADC_DOUT));  
03E4:  BSF    F92.3
03E6:  BTFSC  F80.3
03E8:  BRA    03EE
03EA:  BCF    FD8.0
03EC:  BRA    03F0
03EE:  BSF    FD8.0
03F0:  RLCF   50,F
03F2:  RLCF   51,F
....................           output_low(ADC_SCLK);  
03F4:  BCF    F92.2
03F6:  BCF    F89.2
03F8:  INCF   52,F
03FA:  BRA    03DA
....................         } 
....................   
....................         output_low (ADC_SCLK); 
03FC:  BCF    F92.2
03FE:  BCF    F89.2
....................         output_high (ADC_CS1); 
0400:  BCF    F92.1
0402:  BSF    F89.1
....................     } 
....................  
....................     dato= (dato>>2)& 0x0FFF; 
0404:  RRCF   51,W
0406:  MOVWF  54
0408:  RRCF   50,W
040A:  MOVWF  53
040C:  RRCF   54,F
040E:  RRCF   53,F
0410:  MOVLW  3F
0412:  ANDWF  54,F
0414:  MOVFF  53,50
0418:  MOVF   54,W
041A:  ANDLW  0F
041C:  MOVWF  51
....................     return(dato); 
041E:  MOVFF  50,01
0422:  MOVFF  51,02
0426:  GOTO   10D0 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //Implementacion Switch-Case 
....................  
.................... /** 
.................... *	\fn void maquina_estado() 
.................... *	\brief Implementacion Switch-Case 
.................... *	\details  
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
....................  **/ 
.................... unsigned long punto1, punto2; 
.................... int8 pos_V,pos_I,pos_V_A,pos_I_A; 
.................... int control_V, control_I; 
.................... int desfase; 
.................... float tension, corriente, tension_RMS,corriente_RMS, t_desfase, potencia_ins,angulo; 
....................  
.................... const long carga= 0xF485; 
....................  
.................... #INT_RTCC                // interrupcion para demora de 500 us 
.................... void interrtimer_0(){ 
....................     set_timer0(carga);   // interrupcion cada 500 us 
*
00BC:  MOVLW  F4
00BE:  MOVWF  FD7
00C0:  MOVLW  85
00C2:  MOVWF  FD6
....................     pulso_timer++; 
00C4:  INCF   25,F
....................  
00C6:  BCF    FF2.2
00C8:  GOTO   0060
....................    } 
....................  
.................... void maquina_estado() 
.................... { 
.................... 		static int estado = PUNTO_TENS_CORR; 
....................  
.................... 		switch(estado) 
*
109E:  MOVF   4E,W
10A0:  XORLW  00
10A2:  BZ    10BC
10A4:  XORLW  01
10A6:  BZ    1124
10A8:  XORLW  03
10AA:  BTFSC  FD8.2
10AC:  BRA    1264
10AE:  XORLW  01
10B0:  BTFSC  FD8.2
10B2:  BRA    133A
10B4:  XORLW  07
10B6:  BTFSC  FD8.2
10B8:  BRA    151E
10BA:  BRA    15EC
.................... 		{ 
.................... 			case PUNTO_TENS_CORR: 
....................                set_adc_channel(0);           //Habilitacin canal 
10BC:  MOVLW  00
10BE:  MOVWF  01
10C0:  MOVF   FC2,W
10C2:  ANDLW  C3
10C4:  IORWF  01,W
10C6:  MOVWF  FC2
....................                 punto1= leer_ADC(2); 
10C8:  MOVLW  02
10CA:  MOVWF  4F
10CC:  GOTO   03C2
10D0:  MOVFF  02,28
10D4:  MOVFF  01,27
....................                 punto2= read_adc(); // comprobar si funciona con el tiempo de demora de la lectura del externo 
10D8:  BSF    FC2.1
10DA:  BTFSC  FC2.1
10DC:  BRA    10DA
10DE:  CLRF   2A
10E0:  MOVFF  FC4,29
....................                 // convierte los valores de long a float 
....................                 tension=punto1; 
10E4:  MOVFF  28,82
10E8:  MOVFF  27,81
10EC:  CALL   042A
10F0:  MOVFF  03,35
10F4:  MOVFF  02,34
10F8:  MOVFF  01,33
10FC:  MOVFF  00,32
....................                 corriente=punto2; 
1100:  MOVFF  2A,82
1104:  MOVFF  29,81
1108:  CALL   042A
110C:  MOVFF  03,39
1110:  MOVFF  02,38
1114:  MOVFF  01,37
1118:  MOVFF  00,36
....................                 contador++; 
111C:  INCF   22,F
.................... 					estado = CONVERSION_DESFASE; 
111E:  MOVLW  01
1120:  MOVWF  4E
.................... 		 
.................... 				 
....................  
.................... 				break; 
1122:  BRA    15EE
.................... 			 
.................... 			case CONVERSION_DESFASE: 
....................                 tension= (tension)/1000-2.54; 
1124:  MOVFF  35,64
1128:  MOVFF  34,63
112C:  MOVFF  33,62
1130:  MOVFF  32,61
1134:  CLRF   x68
1136:  CLRF   x67
1138:  MOVLW  7A
113A:  MOVWF  x66
113C:  MOVLW  88
113E:  MOVWF  x65
1140:  CALL   0460
1144:  MOVFF  03,52
1148:  MOVFF  02,51
114C:  MOVFF  01,50
1150:  MOVFF  00,4F
1154:  BSF    FD8.1
1156:  MOVFF  03,84
115A:  MOVFF  02,83
115E:  MOVFF  01,82
1162:  MOVFF  00,81
1166:  MOVLW  5C
1168:  MOVWF  x88
116A:  MOVLW  8F
116C:  MOVWF  x87
116E:  MOVLW  22
1170:  MOVWF  x86
1172:  MOVLW  80
1174:  MOVWF  x85
1176:  CALL   05BA
117A:  MOVFF  03,35
117E:  MOVFF  02,34
1182:  MOVFF  01,33
1186:  MOVFF  00,32
....................                 corriente= (corriente*5)/1024-2.5; 
118A:  MOVFF  39,84
118E:  MOVFF  38,83
1192:  MOVFF  37,82
1196:  MOVFF  36,81
119A:  CLRF   x88
119C:  CLRF   x87
119E:  MOVLW  20
11A0:  MOVWF  x86
11A2:  MOVLW  81
11A4:  MOVWF  x85
11A6:  CALL   0824
11AA:  MOVFF  03,52
11AE:  MOVFF  02,51
11B2:  MOVFF  01,50
11B6:  MOVFF  00,4F
11BA:  MOVFF  03,64
11BE:  MOVFF  02,63
11C2:  MOVFF  01,62
11C6:  MOVFF  00,61
11CA:  CLRF   x68
11CC:  CLRF   x67
11CE:  CLRF   x66
11D0:  MOVLW  89
11D2:  MOVWF  x65
11D4:  CALL   0460
11D8:  MOVFF  03,52
11DC:  MOVFF  02,51
11E0:  MOVFF  01,50
11E4:  MOVFF  00,4F
11E8:  BSF    FD8.1
11EA:  MOVFF  03,84
11EE:  MOVFF  02,83
11F2:  MOVFF  01,82
11F6:  MOVFF  00,81
11FA:  CLRF   x88
11FC:  CLRF   x87
11FE:  MOVLW  20
1200:  MOVWF  x86
1202:  MOVLW  80
1204:  MOVWF  x85
1206:  CALL   05BA
120A:  MOVFF  03,39
120E:  MOVFF  02,38
1212:  MOVFF  01,37
1216:  MOVFF  00,36
....................                  
....................                 // Analisis del punto POSITVO O NEGATIVO 
....................                 // valor positivo estado=0-- valor negativo estado=1 
....................                  
....................                 //TENSION 
....................                 #asm 
....................                 clrf &pos_V; 
121A:  CLRF   2B
....................                 btfsc (&tension + 0x01), 7; 
121C:  BTFSC  33.7
....................                 bsf &pos_V,0; 
121E:  BSF    2B.0
....................                 #endasm 
.................... 				 
....................                 //CORRIENTE 
....................                 #asm 
....................                 clrf &pos_I; 
1220:  CLRF   2C
....................                 btfsc (&corriente + 0x01), 7; // comprueba signo en un bit de los 4 byte del float 
1222:  BTFSC  37.7
....................                 bsf &pos_I,0; 
1224:  BSF    2C.0
....................                 #endasm 
....................  
....................                  
....................                  
.................... 				 
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_V==1 && contador!=0 && pos_V_A==0 && control_V != 0){  
1226:  DECFSZ 2B,W
1228:  BRA    123E
122A:  MOVF   22,F
122C:  BZ    123E
122E:  MOVF   2D,F
1230:  BNZ   123E
1232:  MOVF   2F,F
1234:  BZ    123E
....................                  control_V= contador; // tiempo en el que cruz la tension  
1236:  MOVFF  22,2F
....................                  desfase=1; 
123A:  MOVLW  01
123C:  MOVWF  31
....................                 } 
....................                  
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_I==1 && contador!=0 && pos_I_A==0 && control_I != 0){ 
123E:  DECFSZ 2C,W
1240:  BRA    1256
1242:  MOVF   22,F
1244:  BZ    1256
1246:  MOVF   2E,F
1248:  BNZ   1256
124A:  MOVF   30,F
124C:  BZ    1256
....................                      
....................                  control_I= contador; // tiempo en el que cruz la corriente 
124E:  MOVFF  22,30
....................                  desfase=2; 
1252:  MOVLW  02
1254:  MOVWF  31
....................                 } 
....................                  
....................                 pos_V_A=pos_V; 
1256:  MOVFF  2B,2D
....................                 pos_I_A=pos_I; 
125A:  MOVFF  2C,2E
....................                  
....................                  
.................... 					estado = TENS_CORR_RMS; 
125E:  MOVLW  02
1260:  MOVWF  4E
.................... 		 
.................... 				 
....................  
.................... 				break; 
1262:  BRA    15EE
.................... 			 
.................... 			case TENS_CORR_RMS: 
.................... 			 
.................... 				if((contador<30)&& (pulso_timer==1)) 
1264:  MOVF   22,W
1266:  SUBLW  1D
1268:  BNC   1326
126A:  DECFSZ 25,W
126C:  BRA    1326
.................... 				{ 
.................... 					tension_RMS=tension_RMS+ tension * tension;       //calcula tension eficaz 
126E:  MOVFF  35,84
1272:  MOVFF  34,83
1276:  MOVFF  33,82
127A:  MOVFF  32,81
127E:  MOVFF  35,88
1282:  MOVFF  34,87
1286:  MOVFF  33,86
128A:  MOVFF  32,85
128E:  CALL   0824
1292:  BCF    FD8.1
1294:  MOVFF  3D,84
1298:  MOVFF  3C,83
129C:  MOVFF  3B,82
12A0:  MOVFF  3A,81
12A4:  MOVFF  03,88
12A8:  MOVFF  02,87
12AC:  MOVFF  01,86
12B0:  MOVFF  00,85
12B4:  CALL   05BA
12B8:  MOVFF  03,3D
12BC:  MOVFF  02,3C
12C0:  MOVFF  01,3B
12C4:  MOVFF  00,3A
....................                     corriente_RMS= corriente_RMS+ corriente * corriente; // calcula corriente eficaz 
12C8:  MOVFF  39,84
12CC:  MOVFF  38,83
12D0:  MOVFF  37,82
12D4:  MOVFF  36,81
12D8:  MOVFF  39,88
12DC:  MOVFF  38,87
12E0:  MOVFF  37,86
12E4:  MOVFF  36,85
12E8:  CALL   0824
12EC:  BCF    FD8.1
12EE:  MOVFF  41,84
12F2:  MOVFF  40,83
12F6:  MOVFF  3F,82
12FA:  MOVFF  3E,81
12FE:  MOVFF  03,88
1302:  MOVFF  02,87
1306:  MOVFF  01,86
130A:  MOVFF  00,85
130E:  CALL   05BA
1312:  MOVFF  03,41
1316:  MOVFF  02,40
131A:  MOVFF  01,3F
131E:  MOVFF  00,3E
....................                     pulso_timer=0; 
1322:  CLRF   25
....................                      
.................... 					estado = PUNTO_TENS_CORR; 
1324:  CLRF   4E
.................... 		 
.................... 				} 
.................... 				if((contador== 29)) 
1326:  MOVF   22,W
1328:  SUBLW  1D
132A:  BNZ   1338
.................... 				{ 
.................... 					disable_interrupts(GLOBAL); 
132C:  BCF    FF2.6
132E:  BCF    FF2.7
1330:  BTFSC  FF2.7
1332:  BRA    132E
.................... 					estado = CALCULO_POT_ENER; 
1334:  MOVLW  03
1336:  MOVWF  4E
....................                       // lcd_gotoxy(1,1);   
....................                       // printf(LCD_PUTC,"entro timer \%d",contador); 
.................... 				} 
....................  
.................... 				break; 
1338:  BRA    15EE
.................... 			 
.................... 			case CALCULO_POT_ENER: // falta calculo de energia 
....................                 //calcula las raices para completar el calculo RMS 
.................... 				tension_RMS= sqrt(tension_RMS/30); 
133A:  MOVFF  3D,64
133E:  MOVFF  3C,63
1342:  MOVFF  3B,62
1346:  MOVFF  3A,61
134A:  CLRF   x68
134C:  CLRF   x67
134E:  MOVLW  70
1350:  MOVWF  x66
1352:  MOVLW  83
1354:  MOVWF  x65
1356:  CALL   0460
135A:  MOVFF  03,52
135E:  MOVFF  02,51
1362:  MOVFF  01,50
1366:  MOVFF  00,4F
136A:  MOVFF  03,56
136E:  MOVFF  02,55
1372:  MOVFF  01,54
1376:  MOVFF  00,53
137A:  CALL   098C
137E:  MOVFF  03,3D
1382:  MOVFF  02,3C
1386:  MOVFF  01,3B
138A:  MOVFF  00,3A
....................                 corriente_RMS= sqrt(corriente_RMS/30); 
138E:  MOVFF  41,64
1392:  MOVFF  40,63
1396:  MOVFF  3F,62
139A:  MOVFF  3E,61
139E:  CLRF   x68
13A0:  CLRF   x67
13A2:  MOVLW  70
13A4:  MOVWF  x66
13A6:  MOVLW  83
13A8:  MOVWF  x65
13AA:  CALL   0460
13AE:  MOVFF  03,52
13B2:  MOVFF  02,51
13B6:  MOVFF  01,50
13BA:  MOVFF  00,4F
13BE:  MOVFF  03,56
13C2:  MOVFF  02,55
13C6:  MOVFF  01,54
13CA:  MOVFF  00,53
13CE:  CALL   098C
13D2:  MOVFF  03,41
13D6:  MOVFF  02,40
13DA:  MOVFF  01,3F
13DE:  MOVFF  00,3E
....................                  
....................                 // se controla si se pudo calcular desfase en el estado anterior  
....................                 // se realiza las diferencia de cruce por cero y se convierte de tiempo a radianes 
....................                 if (desfase==2){ 
13E2:  MOVF   31,W
13E4:  SUBLW  02
13E6:  BNZ   148E
....................                     t_desfase= (control_I-control_V); 
13E8:  MOVF   2F,W
13EA:  SUBWF  30,W
13EC:  CLRF   x82
13EE:  MOVWF  x81
13F0:  CALL   042A
13F4:  MOVFF  03,45
13F8:  MOVFF  02,44
13FC:  MOVFF  01,43
1400:  MOVFF  00,42
....................                     angulo= (t_desfase*pi)/20;      // angulo de desfase en radianes. 
1404:  MOVFF  45,84
1408:  MOVFF  44,83
140C:  MOVFF  43,82
1410:  MOVFF  42,81
1414:  MOVLW  DB
1416:  MOVWF  x88
1418:  MOVLW  0F
141A:  MOVWF  x87
141C:  MOVLW  49
141E:  MOVWF  x86
1420:  MOVLW  80
1422:  MOVWF  x85
1424:  CALL   0824
1428:  MOVFF  03,52
142C:  MOVFF  02,51
1430:  MOVFF  01,50
1434:  MOVFF  00,4F
1438:  MOVFF  03,64
143C:  MOVFF  02,63
1440:  MOVFF  01,62
1444:  MOVFF  00,61
1448:  CLRF   x68
144A:  CLRF   x67
144C:  MOVLW  20
144E:  MOVWF  x66
1450:  MOVLW  83
1452:  MOVWF  x65
1454:  CALL   0460
1458:  MOVFF  03,4D
145C:  MOVFF  02,4C
1460:  MOVFF  01,4B
1464:  MOVFF  00,4A
....................                      lcd_gotoxy(1,1); 
1468:  MOVLW  01
146A:  MOVWF  5E
146C:  MOVWF  5F
146E:  CALL   029C
....................                      printf(LCD_PUTC,"Se midio desfase"); 
1472:  MOVLW  CC
1474:  MOVWF  FF6
1476:  MOVLW  00
1478:  MOVWF  FF7
147A:  GOTO   0A96
....................                      delay_ms(1000); 
147E:  MOVLW  04
1480:  MOVWF  4F
1482:  MOVLW  FA
1484:  MOVWF  5E
1486:  CALL   00FE
148A:  DECFSZ 4F,F
148C:  BRA    1482
....................                 }                 
....................                // calculo de potencia  
....................                 potencia_ins= tension_RMS*corriente_RMS* cos(angulo); 
148E:  MOVFF  3D,84
1492:  MOVFF  3C,83
1496:  MOVFF  3B,82
149A:  MOVFF  3A,81
149E:  MOVFF  41,88
14A2:  MOVFF  40,87
14A6:  MOVFF  3F,86
14AA:  MOVFF  3E,85
14AE:  CALL   0824
14B2:  MOVFF  03,52
14B6:  MOVFF  02,51
14BA:  MOVFF  01,50
14BE:  MOVFF  00,4F
14C2:  MOVFF  4D,56
14C6:  MOVFF  4C,55
14CA:  MOVFF  4B,54
14CE:  MOVFF  4A,53
14D2:  GOTO   0AF2
14D6:  MOVFF  52,84
14DA:  MOVFF  51,83
14DE:  MOVFF  50,82
14E2:  MOVFF  4F,81
14E6:  MOVFF  03,88
14EA:  MOVFF  02,87
14EE:  MOVFF  01,86
14F2:  MOVFF  00,85
14F6:  CALL   0824
14FA:  MOVFF  03,49
14FE:  MOVFF  02,48
1502:  MOVFF  01,47
1506:  MOVFF  00,46
....................                 //se limpian las variables para la prxima tanta de muestreo 
....................                 control_V=0;       
150A:  CLRF   2F
....................                 control_I=0; 
150C:  CLRF   30
....................                 angulo=0; 
150E:  CLRF   4D
1510:  CLRF   4C
1512:  CLRF   4B
1514:  CLRF   4A
....................                 desfase=0;  
1516:  CLRF   31
....................                  
.................... 					estado = MOSTRAR_DATOS; 
1518:  MOVLW  04
151A:  MOVWF  4E
.................... 				break; 
151C:  BRA    15EE
.................... 			 
.................... 			case MOSTRAR_DATOS: 
....................                 //este estado solo muestra los datos en la pantalla LCD 
....................                 lcd_gotoxy(1,1); 
151E:  MOVLW  01
1520:  MOVWF  5E
1522:  MOVWF  5F
1524:  CALL   029C
....................                 printf(LCD_PUTC,"Potencia= \%f W",potencia_ins); 
1528:  MOVLW  DE
152A:  MOVWF  FF6
152C:  MOVLW  00
152E:  MOVWF  FF7
1530:  MOVLW  0A
1532:  MOVWF  4F
1534:  RCALL  0E30
1536:  MOVLW  89
1538:  MOVWF  FE9
153A:  MOVFF  49,52
153E:  MOVFF  48,51
1542:  MOVFF  47,50
1546:  MOVFF  46,4F
154A:  MOVLW  02
154C:  MOVWF  53
154E:  RCALL  0F1E
1550:  MOVLW  20
1552:  MOVWF  5D
1554:  CALL   02F2
1558:  MOVLW  57
155A:  MOVWF  5D
155C:  CALL   02F2
....................                 lcd_gotoxy(1,2); 
1560:  MOVLW  01
1562:  MOVWF  5E
1564:  MOVLW  02
1566:  MOVWF  5F
1568:  CALL   029C
....................                 printf (LCD_PUTC, "T=\%f V  I=\%f A",tension_RMS,corriente_RMS); 
156C:  MOVLW  54
156E:  MOVWF  5D
1570:  CALL   02F2
1574:  MOVLW  3D
1576:  MOVWF  5D
1578:  CALL   02F2
157C:  MOVLW  89
157E:  MOVWF  FE9
1580:  MOVFF  3D,52
1584:  MOVFF  3C,51
1588:  MOVFF  3B,50
158C:  MOVFF  3A,4F
1590:  MOVLW  02
1592:  MOVWF  53
1594:  RCALL  0F1E
1596:  MOVLW  F2
1598:  MOVWF  FF6
159A:  MOVLW  00
159C:  MOVWF  FF7
159E:  MOVLW  06
15A0:  MOVWF  4F
15A2:  RCALL  0E30
15A4:  MOVLW  89
15A6:  MOVWF  FE9
15A8:  MOVFF  41,52
15AC:  MOVFF  40,51
15B0:  MOVFF  3F,50
15B4:  MOVFF  3E,4F
15B8:  MOVLW  02
15BA:  MOVWF  53
15BC:  RCALL  0F1E
15BE:  MOVLW  20
15C0:  MOVWF  5D
15C2:  CALL   02F2
15C6:  MOVLW  41
15C8:  MOVWF  5D
15CA:  CALL   02F2
....................                 delay_ms(1000); 
15CE:  MOVLW  04
15D0:  MOVWF  4F
15D2:  MOVLW  FA
15D4:  MOVWF  5E
15D6:  CALL   00FE
15DA:  DECFSZ 4F,F
15DC:  BRA    15D2
....................                 enable_interrupts(GLOBAL); 
15DE:  MOVLW  C0
15E0:  IORWF  FF2,F
....................                 set_timer0(0x1D);   // se carga 29 para un desborde en 500 us teniendo en cuenta los tiempos en C 
15E2:  CLRF   FD7
15E4:  MOVLW  1D
15E6:  MOVWF  FD6
.................... 					 
.................... 					estado = PUNTO_TENS_CORR; 
15E8:  CLRF   4E
.................... 		 
....................  
.................... 				break; 
15EA:  BRA    15EE
.................... 			 
.................... 			default: estado = PUNTO_TENS_CORR; 
15EC:  CLRF   4E
.................... 		} 
15EE:  GOTO   1630 (RETURN)
....................  
....................  
.................... } 
....................  
.................... //Funciones asociadas a los eventos 
....................  
.................... /** 
.................... *	\fn int -(void) 
.................... *	\brief Resumen 
.................... *	\details Detalles 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 4C02   PLL3 CPUDIV1 NOUSBDIV HS FCMEN NOIESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
