CCS PCH C Compiler, Version 5.048, 5967               03-nov-16 11:09

               Filename:   C:\Users\MARCOS\Proyecto_final\Med_pot.X\dist\default\production\Med_pot.X.production.lst

               ROM used:   6008 bytes (18%)
                           Largest free fragment is 26756
               RAM used:   80 (4%) at main() level
                           142 (7%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   173A
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   00BC
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #import(file="build/default/production/main.o") 
.................... #import(file="build/default/production/funciones.o") 
.................... /** 
.................... *	\file main.c 
.................... *	\brief Resumen del contenido del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  DATA 50,72
00B0:  DATA 69,6D
00B2:  DATA 65,72
00B4:  DATA 20,70
00B6:  DATA 72,75
00B8:  DATA 65,62
00BA:  DATA 61,00
*
034C:  TBLRD*+
034E:  MOVF   FF5,F
0350:  BZ    036A
0352:  MOVFF  FF6,50
0356:  MOVFF  FF7,51
035A:  MOVFF  FF5,5E
035E:  RCALL  02DE
0360:  MOVFF  50,FF6
0364:  MOVFF  51,FF7
0368:  BRA    034C
036A:  GOTO   0390 (RETURN)
*
0560:  MOVLW  8E
0562:  MOVWF  00
0564:  MOVFF  7F,01
0568:  MOVFF  7E,02
056C:  CLRF   03
056E:  MOVF   01,F
0570:  BNZ   0584
0572:  MOVFF  02,01
0576:  CLRF   02
0578:  MOVLW  08
057A:  SUBWF  00,F
057C:  MOVF   01,F
057E:  BNZ   0584
0580:  CLRF   00
0582:  BRA    0594
0584:  BCF    FD8.0
0586:  BTFSC  01.7
0588:  BRA    0592
058A:  RLCF   02,F
058C:  RLCF   01,F
058E:  DECF   00,F
0590:  BRA    0584
0592:  BCF    01.7
0594:  RETURN 0
0596:  MOVF   x7E,W
0598:  BTFSC  FD8.2
059A:  BRA    067E
059C:  MOVWF  00
059E:  MOVF   x82,W
05A0:  BTFSC  FD8.2
05A2:  BRA    067E
05A4:  ADDWF  00,F
05A6:  BNC   05B0
05A8:  MOVLW  81
05AA:  ADDWF  00,F
05AC:  BC    067E
05AE:  BRA    05B8
05B0:  MOVLW  7F
05B2:  SUBWF  00,F
05B4:  BNC   067E
05B6:  BZ    067E
05B8:  MOVFF  7F,86
05BC:  MOVF   x83,W
05BE:  XORWF  x86,F
05C0:  BSF    x7F.7
05C2:  BSF    x83.7
05C4:  MOVF   x81,W
05C6:  MULWF  x85
05C8:  MOVFF  FF4,88
05CC:  MOVF   x80,W
05CE:  MULWF  x84
05D0:  MOVFF  FF4,03
05D4:  MOVFF  FF3,87
05D8:  MULWF  x85
05DA:  MOVF   FF3,W
05DC:  ADDWF  x88,F
05DE:  MOVF   FF4,W
05E0:  ADDWFC x87,F
05E2:  MOVLW  00
05E4:  ADDWFC 03,F
05E6:  MOVF   x81,W
05E8:  MULWF  x84
05EA:  MOVF   FF3,W
05EC:  ADDWF  x88,F
05EE:  MOVF   FF4,W
05F0:  ADDWFC x87,F
05F2:  MOVLW  00
05F4:  CLRF   02
05F6:  ADDWFC 03,F
05F8:  ADDWFC 02,F
05FA:  MOVF   x7F,W
05FC:  MULWF  x85
05FE:  MOVF   FF3,W
0600:  ADDWF  x87,F
0602:  MOVF   FF4,W
0604:  ADDWFC 03,F
0606:  MOVLW  00
0608:  ADDWFC 02,F
060A:  MOVF   x7F,W
060C:  MULWF  x84
060E:  MOVF   FF3,W
0610:  ADDWF  03,F
0612:  MOVF   FF4,W
0614:  ADDWFC 02,F
0616:  MOVLW  00
0618:  CLRF   01
061A:  ADDWFC 01,F
061C:  MOVF   x81,W
061E:  MULWF  x83
0620:  MOVF   FF3,W
0622:  ADDWF  x87,F
0624:  MOVF   FF4,W
0626:  ADDWFC 03,F
0628:  MOVLW  00
062A:  ADDWFC 02,F
062C:  ADDWFC 01,F
062E:  MOVF   x80,W
0630:  MULWF  x83
0632:  MOVF   FF3,W
0634:  ADDWF  03,F
0636:  MOVF   FF4,W
0638:  ADDWFC 02,F
063A:  MOVLW  00
063C:  ADDWFC 01,F
063E:  MOVF   x7F,W
0640:  MULWF  x83
0642:  MOVF   FF3,W
0644:  ADDWF  02,F
0646:  MOVF   FF4,W
0648:  ADDWFC 01,F
064A:  INCF   00,F
064C:  BTFSC  01.7
064E:  BRA    065A
0650:  RLCF   x87,F
0652:  RLCF   03,F
0654:  RLCF   02,F
0656:  RLCF   01,F
0658:  DECF   00,F
065A:  MOVLW  00
065C:  BTFSS  x87.7
065E:  BRA    0674
0660:  INCF   03,F
0662:  ADDWFC 02,F
0664:  ADDWFC 01,F
0666:  MOVF   01,W
0668:  BNZ   0674
066A:  MOVF   02,W
066C:  BNZ   0674
066E:  MOVF   03,W
0670:  BNZ   0674
0672:  INCF   00,F
0674:  BTFSC  x86.7
0676:  BSF    01.7
0678:  BTFSS  x86.7
067A:  BCF    01.7
067C:  BRA    0686
067E:  CLRF   00
0680:  CLRF   01
0682:  CLRF   02
0684:  CLRF   03
0686:  RETURN 0
0688:  MOVF   x62,W
068A:  BTFSC  FD8.2
068C:  BRA    07D8
068E:  MOVWF  x6E
0690:  MOVF   x66,W
0692:  BTFSC  FD8.2
0694:  BRA    07D8
0696:  SUBWF  x6E,F
0698:  BNC   06A4
069A:  MOVLW  7F
069C:  ADDWF  x6E,F
069E:  BTFSC  FD8.0
06A0:  BRA    07D8
06A2:  BRA    06B0
06A4:  MOVLW  81
06A6:  SUBWF  x6E,F
06A8:  BTFSS  FD8.0
06AA:  BRA    07D8
06AC:  BTFSC  FD8.2
06AE:  BRA    07D8
06B0:  MOVFF  6E,00
06B4:  CLRF   01
06B6:  CLRF   02
06B8:  CLRF   03
06BA:  CLRF   x6D
06BC:  MOVFF  63,6C
06C0:  BSF    x6C.7
06C2:  MOVFF  64,6B
06C6:  MOVFF  65,6A
06CA:  MOVLW  19
06CC:  MOVWF  x6E
06CE:  MOVF   x69,W
06D0:  SUBWF  x6A,F
06D2:  BC    06EE
06D4:  MOVLW  01
06D6:  SUBWF  x6B,F
06D8:  BC    06EE
06DA:  SUBWF  x6C,F
06DC:  BC    06EE
06DE:  SUBWF  x6D,F
06E0:  BC    06EE
06E2:  INCF   x6D,F
06E4:  INCF   x6C,F
06E6:  INCF   x6B,F
06E8:  MOVF   x69,W
06EA:  ADDWF  x6A,F
06EC:  BRA    073E
06EE:  MOVF   x68,W
06F0:  SUBWF  x6B,F
06F2:  BC    0718
06F4:  MOVLW  01
06F6:  SUBWF  x6C,F
06F8:  BC    0718
06FA:  SUBWF  x6D,F
06FC:  BC    0718
06FE:  INCF   x6D,F
0700:  INCF   x6C,F
0702:  MOVF   x68,W
0704:  ADDWF  x6B,F
0706:  MOVF   x69,W
0708:  ADDWF  x6A,F
070A:  BNC   073E
070C:  INCF   x6B,F
070E:  BNZ   073E
0710:  INCF   x6C,F
0712:  BNZ   073E
0714:  INCF   x6D,F
0716:  BRA    073E
0718:  MOVF   x67,W
071A:  IORLW  80
071C:  SUBWF  x6C,F
071E:  BC    073C
0720:  MOVLW  01
0722:  SUBWF  x6D,F
0724:  BC    073C
0726:  INCF   x6D,F
0728:  MOVF   x67,W
072A:  IORLW  80
072C:  ADDWF  x6C,F
072E:  MOVF   x68,W
0730:  ADDWF  x6B,F
0732:  BNC   0706
0734:  INCF   x6C,F
0736:  BNZ   0706
0738:  INCF   x6D,F
073A:  BRA    0706
073C:  BSF    03.0
073E:  DECFSZ x6E,F
0740:  BRA    0744
0742:  BRA    075A
0744:  BCF    FD8.0
0746:  RLCF   x6A,F
0748:  RLCF   x6B,F
074A:  RLCF   x6C,F
074C:  RLCF   x6D,F
074E:  BCF    FD8.0
0750:  RLCF   03,F
0752:  RLCF   02,F
0754:  RLCF   01,F
0756:  RLCF   x6F,F
0758:  BRA    06CE
075A:  BTFSS  x6F.0
075C:  BRA    076A
075E:  BCF    FD8.0
0760:  RRCF   01,F
0762:  RRCF   02,F
0764:  RRCF   03,F
0766:  RRCF   x6F,F
0768:  BRA    076E
076A:  DECF   00,F
076C:  BZ    07D8
076E:  BTFSC  x6F.7
0770:  BRA    07AE
0772:  BCF    FD8.0
0774:  RLCF   x6A,F
0776:  RLCF   x6B,F
0778:  RLCF   x6C,F
077A:  RLCF   x6D,F
077C:  MOVF   x69,W
077E:  SUBWF  x6A,F
0780:  BC    0790
0782:  MOVLW  01
0784:  SUBWF  x6B,F
0786:  BC    0790
0788:  SUBWF  x6C,F
078A:  BC    0790
078C:  SUBWF  x6D,F
078E:  BNC   07C4
0790:  MOVF   x68,W
0792:  SUBWF  x6B,F
0794:  BC    07A0
0796:  MOVLW  01
0798:  SUBWF  x6C,F
079A:  BC    07A0
079C:  SUBWF  x6D,F
079E:  BNC   07C4
07A0:  MOVF   x67,W
07A2:  IORLW  80
07A4:  SUBWF  x6C,F
07A6:  BC    07AE
07A8:  MOVLW  01
07AA:  SUBWF  x6D,F
07AC:  BNC   07C4
07AE:  INCF   03,F
07B0:  BNZ   07C4
07B2:  INCF   02,F
07B4:  BNZ   07C4
07B6:  INCF   01,F
07B8:  BNZ   07C4
07BA:  INCF   00,F
07BC:  BZ    07D8
07BE:  RRCF   01,F
07C0:  RRCF   02,F
07C2:  RRCF   03,F
07C4:  MOVFF  63,6E
07C8:  MOVF   x67,W
07CA:  XORWF  x6E,F
07CC:  BTFSS  x6E.7
07CE:  BRA    07D4
07D0:  BSF    01.7
07D2:  BRA    07E0
07D4:  BCF    01.7
07D6:  BRA    07E0
07D8:  CLRF   00
07DA:  CLRF   01
07DC:  CLRF   02
07DE:  CLRF   03
07E0:  RETURN 0
07E2:  MOVLW  80
07E4:  BTFSC  FD8.1
07E6:  XORWF  x83,F
07E8:  CLRF   x88
07EA:  CLRF   x89
07EC:  MOVFF  7F,87
07F0:  MOVF   x83,W
07F2:  XORWF  x87,F
07F4:  MOVF   x7E,W
07F6:  BTFSC  FD8.2
07F8:  BRA    09B2
07FA:  MOVWF  x86
07FC:  MOVWF  00
07FE:  MOVF   x82,W
0800:  BTFSC  FD8.2
0802:  BRA    09C4
0804:  SUBWF  x86,F
0806:  BTFSC  FD8.2
0808:  BRA    090C
080A:  BNC   0886
080C:  MOVFF  83,8C
0810:  BSF    x8C.7
0812:  MOVFF  84,8B
0816:  MOVFF  85,8A
081A:  CLRF   x89
081C:  BCF    FD8.0
081E:  RRCF   x8C,F
0820:  RRCF   x8B,F
0822:  RRCF   x8A,F
0824:  RRCF   x89,F
0826:  DECFSZ x86,F
0828:  BRA    081A
082A:  BTFSS  x87.7
082C:  BRA    0834
082E:  BSF    x88.0
0830:  BRA    09EC
0832:  BCF    x88.0
0834:  BCF    x86.0
0836:  BSF    x88.4
0838:  CLRF   FEA
083A:  MOVLW  81
083C:  MOVWF  FE9
083E:  BRA    0A12
0840:  BCF    x88.4
0842:  BTFSC  x87.7
0844:  BRA    085A
0846:  BTFSS  x86.0
0848:  BRA    0870
084A:  RRCF   x8C,F
084C:  RRCF   x8B,F
084E:  RRCF   x8A,F
0850:  RRCF   x89,F
0852:  INCF   00,F
0854:  BTFSC  FD8.2
0856:  BRA    09E2
0858:  BRA    0870
085A:  BTFSC  x8C.7
085C:  BRA    0876
085E:  BCF    FD8.0
0860:  RLCF   x89,F
0862:  RLCF   x8A,F
0864:  RLCF   x8B,F
0866:  RLCF   x8C,F
0868:  DECF   00,F
086A:  BTFSC  FD8.2
086C:  BRA    09E2
086E:  BRA    085A
0870:  BSF    x88.6
0872:  BRA    094A
0874:  BCF    x88.6
0876:  MOVFF  7F,87
087A:  BTFSS  x7F.7
087C:  BRA    0882
087E:  BSF    x8C.7
0880:  BRA    09D4
0882:  BCF    x8C.7
0884:  BRA    09D4
0886:  MOVFF  82,86
088A:  MOVFF  82,00
088E:  MOVF   x7E,W
0890:  SUBWF  x86,F
0892:  MOVFF  7F,8C
0896:  BSF    x8C.7
0898:  MOVFF  80,8B
089C:  MOVFF  81,8A
08A0:  CLRF   x89
08A2:  BCF    FD8.0
08A4:  RRCF   x8C,F
08A6:  RRCF   x8B,F
08A8:  RRCF   x8A,F
08AA:  RRCF   x89,F
08AC:  DECFSZ x86,F
08AE:  BRA    08A0
08B0:  BTFSS  x87.7
08B2:  BRA    08BA
08B4:  BSF    x88.1
08B6:  BRA    09EC
08B8:  BCF    x88.1
08BA:  BCF    x86.0
08BC:  BSF    x88.5
08BE:  CLRF   FEA
08C0:  MOVLW  85
08C2:  MOVWF  FE9
08C4:  BRA    0A12
08C6:  BCF    x88.5
08C8:  BTFSC  x87.7
08CA:  BRA    08E0
08CC:  BTFSS  x86.0
08CE:  BRA    08F6
08D0:  RRCF   x8C,F
08D2:  RRCF   x8B,F
08D4:  RRCF   x8A,F
08D6:  RRCF   x89,F
08D8:  INCF   00,F
08DA:  BTFSC  FD8.2
08DC:  BRA    09E2
08DE:  BRA    08F6
08E0:  BTFSC  x8C.7
08E2:  BRA    08FC
08E4:  BCF    FD8.0
08E6:  RLCF   x89,F
08E8:  RLCF   x8A,F
08EA:  RLCF   x8B,F
08EC:  RLCF   x8C,F
08EE:  DECF   00,F
08F0:  BTFSC  FD8.2
08F2:  BRA    09E2
08F4:  BRA    08E0
08F6:  BSF    x88.7
08F8:  BRA    094A
08FA:  BCF    x88.7
08FC:  MOVFF  83,87
0900:  BTFSS  x83.7
0902:  BRA    0908
0904:  BSF    x8C.7
0906:  BRA    09D4
0908:  BCF    x8C.7
090A:  BRA    09D4
090C:  MOVFF  83,8C
0910:  BSF    x8C.7
0912:  MOVFF  84,8B
0916:  MOVFF  85,8A
091A:  BTFSS  x87.7
091C:  BRA    0926
091E:  BCF    x8C.7
0920:  BSF    x88.2
0922:  BRA    09EC
0924:  BCF    x88.2
0926:  CLRF   x89
0928:  BCF    x86.0
092A:  CLRF   FEA
092C:  MOVLW  81
092E:  MOVWF  FE9
0930:  BRA    0A12
0932:  BTFSC  x87.7
0934:  BRA    096E
0936:  MOVFF  7F,87
093A:  BTFSS  x86.0
093C:  BRA    094A
093E:  RRCF   x8C,F
0940:  RRCF   x8B,F
0942:  RRCF   x8A,F
0944:  RRCF   x89,F
0946:  INCF   00,F
0948:  BZ    09E2
094A:  BTFSS  x89.7
094C:  BRA    0964
094E:  INCF   x8A,F
0950:  BNZ   0964
0952:  INCF   x8B,F
0954:  BNZ   0964
0956:  INCF   x8C,F
0958:  BNZ   0964
095A:  RRCF   x8C,F
095C:  RRCF   x8B,F
095E:  RRCF   x8A,F
0960:  INCF   00,F
0962:  BZ    09E2
0964:  BTFSC  x88.6
0966:  BRA    0874
0968:  BTFSC  x88.7
096A:  BRA    08FA
096C:  BRA    09A6
096E:  MOVLW  80
0970:  XORWF  x8C,F
0972:  BTFSS  x8C.7
0974:  BRA    097E
0976:  BRA    09EC
0978:  MOVFF  83,87
097C:  BRA    0992
097E:  MOVFF  7F,87
0982:  MOVF   x8C,F
0984:  BNZ   0992
0986:  MOVF   x8B,F
0988:  BNZ   0992
098A:  MOVF   x8A,F
098C:  BNZ   0992
098E:  CLRF   00
0990:  BRA    09D4
0992:  BTFSC  x8C.7
0994:  BRA    09A6
0996:  BCF    FD8.0
0998:  RLCF   x89,F
099A:  RLCF   x8A,F
099C:  RLCF   x8B,F
099E:  RLCF   x8C,F
09A0:  DECFSZ 00,F
09A2:  BRA    0992
09A4:  BRA    09E2
09A6:  BTFSS  x87.7
09A8:  BRA    09AE
09AA:  BSF    x8C.7
09AC:  BRA    09D4
09AE:  BCF    x8C.7
09B0:  BRA    09D4
09B2:  MOVFF  82,00
09B6:  MOVFF  83,8C
09BA:  MOVFF  84,8B
09BE:  MOVFF  85,8A
09C2:  BRA    09D4
09C4:  MOVFF  7E,00
09C8:  MOVFF  7F,8C
09CC:  MOVFF  80,8B
09D0:  MOVFF  81,8A
09D4:  MOVFF  8C,01
09D8:  MOVFF  8B,02
09DC:  MOVFF  8A,03
09E0:  BRA    0A4A
09E2:  CLRF   00
09E4:  CLRF   01
09E6:  CLRF   02
09E8:  CLRF   03
09EA:  BRA    0A4A
09EC:  CLRF   x89
09EE:  COMF   x8A,F
09F0:  COMF   x8B,F
09F2:  COMF   x8C,F
09F4:  COMF   x89,F
09F6:  INCF   x89,F
09F8:  BNZ   0A04
09FA:  INCF   x8A,F
09FC:  BNZ   0A04
09FE:  INCF   x8B,F
0A00:  BNZ   0A04
0A02:  INCF   x8C,F
0A04:  BTFSC  x88.0
0A06:  BRA    0832
0A08:  BTFSC  x88.1
0A0A:  BRA    08B8
0A0C:  BTFSC  x88.2
0A0E:  BRA    0924
0A10:  BRA    0978
0A12:  MOVF   FEF,W
0A14:  ADDWF  x8A,F
0A16:  BNC   0A22
0A18:  INCF   x8B,F
0A1A:  BNZ   0A22
0A1C:  INCF   x8C,F
0A1E:  BTFSC  FD8.2
0A20:  BSF    x86.0
0A22:  MOVF   FED,F
0A24:  MOVF   FEF,W
0A26:  ADDWF  x8B,F
0A28:  BNC   0A30
0A2A:  INCF   x8C,F
0A2C:  BTFSC  FD8.2
0A2E:  BSF    x86.0
0A30:  MOVF   FED,F
0A32:  MOVF   FEF,W
0A34:  BTFSC  FEF.7
0A36:  BRA    0A3A
0A38:  XORLW  80
0A3A:  ADDWF  x8C,F
0A3C:  BTFSC  FD8.0
0A3E:  BSF    x86.0
0A40:  BTFSC  x88.4
0A42:  BRA    0840
0A44:  BTFSC  x88.5
0A46:  BRA    08C6
0A48:  BRA    0932
0A4A:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
*
00EA:  CLRF   FEA
00EC:  MOVLW  5F
00EE:  MOVWF  FE9
00F0:  MOVF   FEF,W
00F2:  BZ    0110
00F4:  MOVLW  0F
00F6:  MOVWF  01
00F8:  CLRF   00
00FA:  DECFSZ 00,F
00FC:  BRA    00FA
00FE:  DECFSZ 01,F
0100:  BRA    00F8
0102:  MOVLW  8F
0104:  MOVWF  00
0106:  DECFSZ 00,F
0108:  BRA    0106
010A:  NOP   
010C:  DECFSZ FEF,F
010E:  BRA    00F4
0110:  RETURN 0
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
0112:  MOVLW  08
0114:  MOVWF  01
0116:  MOVLW  11
0118:  MOVWF  00
011A:  DECFSZ 00,F
011C:  BRA    011A
011E:  BCF    F8C.7
0120:  BCF    F95.7
0122:  MOVLW  11
0124:  MOVWF  00
0126:  DECFSZ 00,F
0128:  BRA    0126
012A:  RLCF   x63,F
012C:  BCF    F8C.6
012E:  BTFSC  FD8.0
0130:  BSF    F95.6
0132:  BTFSS  FD8.0
0134:  BCF    F95.6
0136:  BSF    F95.7
0138:  BTFSS  F83.7
013A:  BRA    0138
013C:  DECFSZ 01,F
013E:  BRA    0116
0140:  MOVLW  11
0142:  MOVWF  00
0144:  DECFSZ 00,F
0146:  BRA    0144
0148:  BCF    F8C.7
014A:  BCF    F95.7
014C:  NOP   
014E:  BSF    F95.6
0150:  MOVLW  11
0152:  MOVWF  00
0154:  DECFSZ 00,F
0156:  BRA    0154
0158:  MOVLW  11
015A:  MOVWF  00
015C:  DECFSZ 00,F
015E:  BRA    015C
0160:  BSF    F95.7
0162:  BTFSS  F83.7
0164:  BRA    0162
0166:  CLRF   01
0168:  MOVLW  11
016A:  MOVWF  00
016C:  DECFSZ 00,F
016E:  BRA    016C
0170:  BTFSC  F83.6
0172:  BSF    01.0
0174:  BCF    F8C.7
0176:  BCF    F95.7
0178:  BCF    F8C.6
017A:  BCF    F95.6
017C:  RETURN 0
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
*
174A:  CLRF   19
174C:  CLRF   1A
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
*
175C:  CLRF   26
175E:  MOVF   FC1,W
1760:  ANDLW  C0
1762:  IORLW  0F
1764:  MOVWF  FC1
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
....................         delay_us(20); 
....................         i2c_write(LCD_ADDR); //the slave addresse 
....................         delay_us(20); 
....................         i2c_write(data); 
....................         delay_us(20); 
....................         i2c_stop(); 
....................         delay_us(20); 
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
....................         i2c_send_nibble(data); 
....................         data=data-4;       //toggle EN back to 0 
....................         i2c_send_nibble(data); 
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
....................     lcd_send_byte(0x10); 
....................     delay_ms(2); 
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x30); 
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x20); 
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
....................         lcd_send_byte(0x80); 
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0xC0); 
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x60); 
....................            //clears the display 
....................         lcd_clear(); 
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
*
174E:  CLRF   21
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
....................       case 2:  address= lcd_line_two;     break; 
....................       case 3:  address= lcd_line_three;   break; 
....................       case 4:  address= lcd_line_four;    break; 
....................       default: address= lcd_line_one;     break;  
....................    } 
....................   
....................    address+=x-1; 
....................    data=address&0xF0; 
....................    lcd_send_byte(data); 
....................    data=address&0x0F; 
....................    data=data<<4; 
....................    lcd_send_byte(data); 
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
....................      case '\1': lcd_gotoxy(1,1);  break; 
....................      case '\2': lcd_gotoxy(1,2);  break; 
....................      case '\3': lcd_gotoxy(1,3);  break; 
....................      case '\4': lcd_gotoxy(1,4);  break; 
....................  
....................      default: 
....................         data=in_data&0xF0; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................         data=in_data&0x0F; 
....................         data=data<<4; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................      break; 
....................    } 
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
....................  
.................... const long carga= 0xE8AB; 
.................... extern int contador; 
.................... extern long pulso_timer; 
....................  
.................... void inicializar(); 
....................  
.................... void main() 
*
173A:  CLRF   FF8
173C:  BCF    FD0.7
173E:  BSF    07.7
1740:  BSF    20.0
1742:  CLRF   24
1744:  CLRF   23
1746:  BSF    20.0
1748:  BSF    20.0
*
1750:  CLRF   22
1752:  CLRF   25
1754:  BSF    20.0
1756:  MOVLW  14
1758:  MOVWF  32
175A:  CLRF   4F
*
1766:  MOVLW  07
1768:  MOVWF  FB4
.................... { 
....................  
.................... //declaracion de variables 
.................... //inicializacion de perifericos 
....................  
.................... 	inicializar() ; 
176A:  GOTO   036E
....................      
....................     set_timer0(carga); 
176E:  MOVLW  E8
1770:  MOVWF  FD7
1772:  MOVLW  AB
1774:  MOVWF  FD6
.................... 	while(1) 
.................... 	{ 
....................  
.................... 		maquina_estado(); 
1776:  BRA    11BC
1778:  BRA    1776
....................  
.................... 	} 
.................... } 
....................  
177A:  SLEEP 
.................... void Inicializar(){ 
....................     //setup_timer_1( T1_INTERNAL|T1_DIV_BY_2); 
....................     setup_timer_0(T0_INTERNAL |T0_DIV_2); 
*
036E:  MOVLW  80
0370:  MOVWF  FD5
....................     //set_timer0(0x0000); 
....................     set_tris_a(0xE8);// configuracion portA necesaria para la libreria control_ADC 
0372:  MOVLW  E8
0374:  MOVWF  F92
....................     set_tris_b(0xFF); 
0376:  MOVLW  FF
0378:  MOVWF  F93
....................     contador=0; 
037A:  CLRF   22
....................     lcd_init(); 
037C:  BRA    022C
....................     lcd_gotoxy(1,1); 
037E:  MOVLW  01
0380:  MOVWF  5F
0382:  MOVWF  x60
0384:  RCALL  0288
....................     printf(LCD_PUTC,"Primer prueba"); 
0386:  MOVLW  AE
0388:  MOVWF  FF6
038A:  MOVLW  00
038C:  MOVWF  FF7
038E:  BRA    034C
....................     lcd_backlight=ON; 
0390:  BSF    20.0
....................     enable_interrupts (INT_RTCC); 
0392:  BSF    FF2.5
....................     enable_interrupts (GLOBAL); 
0394:  MOVLW  C0
0396:  IORWF  FF2,F
....................     output_high (PIN_A0); //pone en alto el chipselect del AD7450 
0398:  BSF    F89.0
....................     output_high (PIN_A1); // pone en alto el chipselect del MAX186 
039A:  BSF    F89.1
039C:  GOTO   176E (RETURN)
.................... } 
....................  
....................  
.................... /** 
.................... *	\file funciones.c 
.................... *	\brief  
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
00CC:  DATA 50,4F
00CE:  DATA 54,3D
00D0:  DATA 20,25
00D2:  DATA 66,20
00D4:  DATA 57,20
00D6:  DATA 20,20
00D8:  DATA 20,00
00DA:  DATA 54,3D
00DC:  DATA 25,66
00DE:  DATA 20,20
00E0:  DATA 49,3D
00E2:  DATA 25,66
00E4:  DATA 20,20
00E6:  DATA 20,20
00E8:  DATA 20,00
*
0516:  MOVLW  8E
0518:  MOVWF  00
051A:  MOVFF  51,01
051E:  MOVFF  50,02
0522:  CLRF   03
0524:  BTFSS  51.7
0526:  BRA    0532
0528:  COMF   01,F
052A:  COMF   02,F
052C:  INCF   02,F
052E:  BNZ   0532
0530:  INCF   01,F
0532:  MOVF   01,F
0534:  BNZ   0548
0536:  MOVFF  02,01
053A:  CLRF   02
053C:  MOVLW  08
053E:  SUBWF  00,F
0540:  MOVF   01,F
0542:  BNZ   0548
0544:  CLRF   00
0546:  BRA    055C
0548:  BCF    FD8.0
054A:  BTFSC  01.7
054C:  BRA    0556
054E:  RLCF   02,F
0550:  RLCF   01,F
0552:  DECF   00,F
0554:  BRA    0548
0556:  BTFSC  51.7
0558:  BRA    055C
055A:  BCF    01.7
055C:  GOTO   11FE (RETURN)
*
0A4C:  MOVFF  7B,82
0A50:  MOVF   x7F,W
0A52:  XORWF  x82,F
0A54:  BTFSS  x82.7
0A56:  BRA    0A62
0A58:  BCF    FD8.2
0A5A:  BCF    FD8.0
0A5C:  BTFSC  x7B.7
0A5E:  BSF    FD8.0
0A60:  BRA    0AC0
0A62:  MOVFF  7B,82
0A66:  MOVFF  7E,83
0A6A:  MOVF   x7A,W
0A6C:  SUBWF  x83,F
0A6E:  BZ    0A7C
0A70:  BTFSS  x82.7
0A72:  BRA    0AC0
0A74:  MOVF   FD8,W
0A76:  XORLW  01
0A78:  MOVWF  FD8
0A7A:  BRA    0AC0
0A7C:  MOVFF  7F,83
0A80:  MOVF   x7B,W
0A82:  SUBWF  x83,F
0A84:  BZ    0A92
0A86:  BTFSS  x82.7
0A88:  BRA    0AC0
0A8A:  MOVF   FD8,W
0A8C:  XORLW  01
0A8E:  MOVWF  FD8
0A90:  BRA    0AC0
0A92:  MOVFF  80,83
0A96:  MOVF   x7C,W
0A98:  SUBWF  x83,F
0A9A:  BZ    0AA8
0A9C:  BTFSS  x82.7
0A9E:  BRA    0AC0
0AA0:  MOVF   FD8,W
0AA2:  XORLW  01
0AA4:  MOVWF  FD8
0AA6:  BRA    0AC0
0AA8:  MOVFF  81,83
0AAC:  MOVF   x7D,W
0AAE:  SUBWF  x83,F
0AB0:  BZ    0ABE
0AB2:  BTFSS  x82.7
0AB4:  BRA    0AC0
0AB6:  MOVF   FD8,W
0AB8:  XORLW  01
0ABA:  MOVWF  FD8
0ABC:  BRA    0AC0
0ABE:  BCF    FD8.0
0AC0:  RETURN 0
*
0BCC:  MOVLW  8E
0BCE:  MOVWF  00
0BD0:  MOVF   x7A,W
0BD2:  SUBWF  00,F
0BD4:  MOVFF  7B,02
0BD8:  MOVFF  7C,01
0BDC:  BSF    02.7
0BDE:  MOVF   00,F
0BE0:  BZ    0BF4
0BE2:  BCF    FD8.0
0BE4:  MOVF   02,F
0BE6:  BNZ   0BEC
0BE8:  MOVF   01,F
0BEA:  BZ    0BF4
0BEC:  RRCF   02,F
0BEE:  RRCF   01,F
0BF0:  DECFSZ 00,F
0BF2:  BRA    0BE2
0BF4:  BTFSS  x7B.7
0BF6:  BRA    0C02
0BF8:  COMF   01,F
0BFA:  COMF   02,F
0BFC:  INCF   01,F
0BFE:  BTFSC  FD8.2
0C00:  INCF   02,F
0C02:  GOTO   0CB2 (RETURN)
*
0F4C:  TBLRD*+
0F4E:  MOVFF  FF6,51
0F52:  MOVFF  FF7,52
0F56:  MOVFF  FF5,5E
0F5A:  CALL   02DE
0F5E:  MOVFF  51,FF6
0F62:  MOVFF  52,FF7
0F66:  DECFSZ 50,F
0F68:  BRA    0F4C
0F6A:  RETURN 0
0F6C:  MOVF   5D,W
0F6E:  SUBLW  B6
0F70:  MOVWF  5D
0F72:  CLRF   03
0F74:  MOVFF  5E,61
0F78:  BSF    5E.7
0F7A:  BCF    FD8.0
0F7C:  RRCF   5E,F
0F7E:  RRCF   5F,F
0F80:  RRCF   x60,F
0F82:  RRCF   03,F
0F84:  RRCF   02,F
0F86:  RRCF   01,F
0F88:  RRCF   00,F
0F8A:  DECFSZ 5D,F
0F8C:  BRA    0F7A
0F8E:  BTFSS  x61.7
0F90:  BRA    0FA8
0F92:  COMF   00,F
0F94:  COMF   01,F
0F96:  COMF   02,F
0F98:  COMF   03,F
0F9A:  INCF   00,F
0F9C:  BTFSC  FD8.2
0F9E:  INCF   01,F
0FA0:  BTFSC  FD8.2
0FA2:  INCF   02,F
0FA4:  BTFSC  FD8.2
0FA6:  INCF   03,F
0FA8:  GOTO   108A (RETURN)
0FAC:  BTFSC  FD8.1
0FAE:  BRA    0FB6
0FB0:  CLRF   FEA
0FB2:  MOVLW  65
0FB4:  MOVWF  FE9
0FB6:  CLRF   00
0FB8:  CLRF   01
0FBA:  CLRF   02
0FBC:  CLRF   03
0FBE:  CLRF   x65
0FC0:  CLRF   x66
0FC2:  CLRF   x67
0FC4:  CLRF   x68
0FC6:  MOVF   x64,W
0FC8:  IORWF  x63,W
0FCA:  IORWF  x62,W
0FCC:  IORWF  x61,W
0FCE:  BZ    1028
0FD0:  MOVLW  20
0FD2:  MOVWF  x69
0FD4:  BCF    FD8.0
0FD6:  RLCF   5D,F
0FD8:  RLCF   5E,F
0FDA:  RLCF   5F,F
0FDC:  RLCF   x60,F
0FDE:  RLCF   x65,F
0FE0:  RLCF   x66,F
0FE2:  RLCF   x67,F
0FE4:  RLCF   x68,F
0FE6:  MOVF   x64,W
0FE8:  SUBWF  x68,W
0FEA:  BNZ   0FFC
0FEC:  MOVF   x63,W
0FEE:  SUBWF  x67,W
0FF0:  BNZ   0FFC
0FF2:  MOVF   x62,W
0FF4:  SUBWF  x66,W
0FF6:  BNZ   0FFC
0FF8:  MOVF   x61,W
0FFA:  SUBWF  x65,W
0FFC:  BNC   101C
0FFE:  MOVF   x61,W
1000:  SUBWF  x65,F
1002:  MOVF   x62,W
1004:  BTFSS  FD8.0
1006:  INCFSZ x62,W
1008:  SUBWF  x66,F
100A:  MOVF   x63,W
100C:  BTFSS  FD8.0
100E:  INCFSZ x63,W
1010:  SUBWF  x67,F
1012:  MOVF   x64,W
1014:  BTFSS  FD8.0
1016:  INCFSZ x64,W
1018:  SUBWF  x68,F
101A:  BSF    FD8.0
101C:  RLCF   00,F
101E:  RLCF   01,F
1020:  RLCF   02,F
1022:  RLCF   03,F
1024:  DECFSZ x69,F
1026:  BRA    0FD4
1028:  MOVFF  65,FEF
102C:  MOVFF  66,FEC
1030:  MOVFF  67,FEC
1034:  MOVFF  68,FEC
1038:  RETURN 0
103A:  MOVF   FE9,W
103C:  MOVWF  55
103E:  MOVF   54,W
1040:  MOVWF  57
1042:  BZ    1078
1044:  MOVFF  53,81
1048:  MOVFF  52,80
104C:  MOVFF  51,7F
1050:  MOVFF  50,7E
1054:  CLRF   x85
1056:  CLRF   x84
1058:  MOVLW  20
105A:  MOVWF  x83
105C:  MOVLW  82
105E:  MOVWF  x82
1060:  CALL   0596
1064:  MOVFF  03,53
1068:  MOVFF  02,52
106C:  MOVFF  01,51
1070:  MOVFF  00,50
1074:  DECFSZ 57,F
1076:  BRA    1044
1078:  MOVFF  53,60
107C:  MOVFF  52,5F
1080:  MOVFF  51,5E
1084:  MOVFF  50,5D
1088:  BRA    0F6C
108A:  MOVFF  03,53
108E:  MOVFF  02,52
1092:  MOVFF  01,51
1096:  MOVFF  00,50
109A:  BTFSS  53.7
109C:  BRA    10B8
109E:  DECF   55,F
10A0:  BSF    55.5
10A2:  COMF   50,F
10A4:  COMF   51,F
10A6:  COMF   52,F
10A8:  COMF   53,F
10AA:  INCF   50,F
10AC:  BTFSC  FD8.2
10AE:  INCF   51,F
10B0:  BTFSC  FD8.2
10B2:  INCF   52,F
10B4:  BTFSC  FD8.2
10B6:  INCF   53,F
10B8:  MOVLW  3B
10BA:  MOVWF  5C
10BC:  MOVLW  9A
10BE:  MOVWF  5B
10C0:  MOVLW  CA
10C2:  MOVWF  5A
10C4:  CLRF   59
10C6:  MOVLW  0A
10C8:  MOVWF  57
10CA:  MOVF   54,W
10CC:  BTFSC  FD8.2
10CE:  INCF   55,F
10D0:  BSF    FD8.1
10D2:  CLRF   FEA
10D4:  MOVLW  50
10D6:  MOVWF  FE9
10D8:  MOVFF  53,60
10DC:  MOVFF  52,5F
10E0:  MOVFF  51,5E
10E4:  MOVFF  50,5D
10E8:  MOVFF  5C,64
10EC:  MOVFF  5B,63
10F0:  MOVFF  5A,62
10F4:  MOVFF  59,61
10F8:  RCALL  0FAC
10FA:  MOVF   01,W
10FC:  MOVF   00,F
10FE:  BNZ   111E
1100:  INCF   54,W
1102:  SUBWF  57,W
1104:  BZ    111E
1106:  MOVF   55,W
1108:  BZ    1122
110A:  ANDLW  0F
110C:  SUBWF  57,W
110E:  BZ    1112
1110:  BC    1188
1112:  BTFSC  55.7
1114:  BRA    1188
1116:  BTFSC  55.6
1118:  BRA    1122
111A:  MOVLW  20
111C:  BRA    117E
111E:  MOVLW  20
1120:  ANDWF  55,F
1122:  BTFSS  55.5
1124:  BRA    1140
1126:  BCF    55.5
1128:  MOVF   54,W
112A:  BTFSS  FD8.2
112C:  DECF   55,F
112E:  MOVF   00,W
1130:  MOVWF  55
1132:  MOVLW  2D
1134:  MOVWF  5E
1136:  CALL   02DE
113A:  MOVF   55,W
113C:  MOVWF  00
113E:  CLRF   55
1140:  MOVF   54,W
1142:  SUBWF  57,W
1144:  BNZ   115C
1146:  MOVF   00,W
1148:  MOVWF  55
114A:  MOVLW  2E
114C:  MOVWF  5E
114E:  CALL   02DE
1152:  MOVF   55,W
1154:  MOVWF  00
1156:  MOVLW  20
1158:  ANDWF  55,F
115A:  MOVLW  00
115C:  MOVLW  30
115E:  BTFSS  55.5
1160:  BRA    117E
1162:  BCF    55.5
1164:  MOVF   54,W
1166:  BTFSS  FD8.2
1168:  DECF   55,F
116A:  MOVF   00,W
116C:  MOVWF  55
116E:  MOVLW  2D
1170:  MOVWF  5E
1172:  CALL   02DE
1176:  MOVF   55,W
1178:  MOVWF  00
117A:  CLRF   55
117C:  MOVLW  30
117E:  ADDWF  00,F
1180:  MOVFF  00,5E
1184:  CALL   02DE
1188:  BCF    FD8.1
118A:  MOVFF  5C,60
118E:  MOVFF  5B,5F
1192:  MOVFF  5A,5E
1196:  MOVFF  59,5D
119A:  CLRF   x64
119C:  CLRF   x63
119E:  CLRF   x62
11A0:  MOVLW  0A
11A2:  MOVWF  x61
11A4:  RCALL  0FAC
11A6:  MOVFF  03,5C
11AA:  MOVFF  02,5B
11AE:  MOVFF  01,5A
11B2:  MOVFF  00,59
11B6:  DECFSZ 57,F
11B8:  BRA    10D0
11BA:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
.................... int contador = 0 ;int pulso_timer = 0 ; 
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
0AC2:  MOVFF  57,7D
0AC6:  MOVFF  56,7C
0ACA:  MOVFF  55,7B
0ACE:  MOVFF  54,7A
0AD2:  CLRF   x81
0AD4:  CLRF   x80
0AD6:  CLRF   x7F
0AD8:  CLRF   x7E
0ADA:  RCALL  0A4C
0ADC:  BC    0AE0
0ADE:  BNZ   0AEA
....................       return(0.0); 
0AE0:  CLRF   00
0AE2:  CLRF   01
0AE4:  CLRF   02
0AE6:  CLRF   03
0AE8:  BRA    0BCA
....................  
....................    y=x; 
0AEA:  MOVFF  57,5B
0AEE:  MOVFF  56,5A
0AF2:  MOVFF  55,59
0AF6:  MOVFF  54,58
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
0AFA:  CLRF   x61
0AFC:  MOVLW  58
0AFE:  MOVWF  x60
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
0B00:  MOVFF  60,FE9
0B04:  MOVFF  61,FEA
0B08:  MOVF   FEF,W
0B0A:  CLRF   x65
0B0C:  MOVWF  x64
0B0E:  MOVLW  7F
0B10:  ADDWF  x64,F
0B12:  MOVLW  00
0B14:  ADDWFC x65,F
0B16:  BCF    FD8.0
0B18:  RRCF   x65,W
0B1A:  RRCF   x64,W
0B1C:  MOVFF  61,FEA
0B20:  MOVFF  60,FE9
0B24:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0B26:  MOVFF  5B,5F
0B2A:  MOVFF  5A,5E
0B2E:  MOVFF  59,5D
0B32:  MOVFF  58,5C
....................       y+=(x/y); 
0B36:  MOVFF  57,65
0B3A:  MOVFF  56,64
0B3E:  MOVFF  55,63
0B42:  MOVFF  54,62
0B46:  MOVFF  5B,69
0B4A:  MOVFF  5A,68
0B4E:  MOVFF  59,67
0B52:  MOVFF  58,66
0B56:  RCALL  0688
0B58:  BCF    FD8.1
0B5A:  MOVFF  5B,81
0B5E:  MOVFF  5A,80
0B62:  MOVFF  59,7F
0B66:  MOVFF  58,7E
0B6A:  MOVFF  03,85
0B6E:  MOVFF  02,84
0B72:  MOVFF  01,83
0B76:  MOVFF  00,82
0B7A:  RCALL  07E2
0B7C:  MOVFF  03,5B
0B80:  MOVFF  02,5A
0B84:  MOVFF  01,59
0B88:  MOVFF  00,58
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
0B8C:  MOVFF  60,FE9
0B90:  MOVFF  61,FEA
0B94:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
0B96:  MOVFF  5F,7D
0B9A:  MOVFF  5E,7C
0B9E:  MOVFF  5D,7B
0BA2:  MOVFF  5C,7A
0BA6:  MOVFF  5B,81
0BAA:  MOVFF  5A,80
0BAE:  MOVFF  59,7F
0BB2:  MOVFF  58,7E
0BB6:  RCALL  0A4C
0BB8:  BNZ   0B26
....................  
....................    return(res); 
0BBA:  MOVFF  5C,00
0BBE:  MOVFF  5D,01
0BC2:  MOVFF  5E,02
0BC6:  MOVFF  5F,03
0BCA:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
0C06:  CLRF   5F
0C08:  CLRF   5E
0C0A:  CLRF   5D
0C0C:  MOVLW  7F
0C0E:  MOVWF  5C
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
0C10:  MOVLW  7E
0C12:  MOVWF  x66
0C14:  MOVLW  80
0C16:  MOVWF  x67
0C18:  CLRF   x68
0C1A:  CLRF   x69
0C1C:  MOVLW  7A
0C1E:  MOVWF  x6A
0C20:  MOVLW  2A
0C22:  MOVWF  x6B
0C24:  MOVLW  AA
0C26:  MOVWF  x6C
0C28:  MOVLW  A3
0C2A:  MOVWF  x6D
0C2C:  MOVLW  75
0C2E:  MOVWF  x6E
0C30:  MOVLW  B6
0C32:  MOVWF  x6F
0C34:  MOVLW  09
0C36:  MOVWF  x70
0C38:  MOVLW  B4
0C3A:  MOVWF  x71
0C3C:  MOVLW  6F
0C3E:  MOVWF  x72
0C40:  MOVLW  4F
0C42:  MOVWF  x73
0C44:  MOVLW  B6
0C46:  MOVWF  x74
0C48:  MOVLW  AA
0C4A:  MOVWF  x75
0C4C:  MOVLW  69
0C4E:  MOVWF  x76
0C50:  MOVLW  8B
0C52:  MOVWF  x77
0C54:  MOVLW  F6
0C56:  MOVWF  x78
0C58:  MOVLW  E8
0C5A:  MOVWF  x79
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0C5C:  MOVFF  53,7D
0C60:  MOVFF  52,7C
0C64:  MOVFF  51,7B
0C68:  MOVFF  50,7A
0C6C:  CLRF   x81
0C6E:  CLRF   x80
0C70:  CLRF   x7F
0C72:  CLRF   x7E
0C74:  RCALL  0A4C
0C76:  BNC   0C7E
0C78:  MOVF   51,W
0C7A:  XORLW  80
0C7C:  MOVWF  51
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0C7E:  MOVFF  53,81
0C82:  MOVFF  52,80
0C86:  MOVFF  51,7F
0C8A:  MOVFF  50,7E
0C8E:  MOVLW  83
0C90:  MOVWF  x85
0C92:  MOVLW  F9
0C94:  MOVWF  x84
0C96:  MOVLW  22
0C98:  MOVWF  x83
0C9A:  MOVLW  7E
0C9C:  MOVWF  x82
0C9E:  RCALL  0596
0CA0:  MOVFF  03,7D
0CA4:  MOVFF  02,7C
0CA8:  MOVFF  01,7B
0CAC:  MOVFF  00,7A
0CB0:  BRA    0BCC
0CB2:  MOVFF  01,60
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0CB6:  MOVFF  53,81
0CBA:  MOVFF  52,80
0CBE:  MOVFF  51,7F
0CC2:  MOVFF  50,7E
0CC6:  MOVLW  83
0CC8:  MOVWF  x85
0CCA:  MOVLW  F9
0CCC:  MOVWF  x84
0CCE:  MOVLW  22
0CD0:  MOVWF  x83
0CD2:  MOVLW  7E
0CD4:  MOVWF  x82
0CD6:  RCALL  0596
0CD8:  MOVFF  03,7D
0CDC:  MOVFF  02,7C
0CE0:  MOVFF  01,7B
0CE4:  MOVFF  00,7A
0CE8:  CLRF   x7F
0CEA:  MOVFF  60,7E
0CEE:  RCALL  0560
0CF0:  BSF    FD8.1
0CF2:  MOVFF  7D,81
0CF6:  MOVFF  7C,80
0CFA:  MOVFF  7B,7F
0CFE:  MOVFF  7A,7E
0D02:  MOVFF  03,85
0D06:  MOVFF  02,84
0D0A:  MOVFF  01,83
0D0E:  MOVFF  00,82
0D12:  RCALL  07E2
0D14:  MOVFF  03,65
0D18:  MOVFF  02,64
0D1C:  MOVFF  01,63
0D20:  MOVFF  00,62
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0D24:  MOVLW  03
0D26:  ANDWF  x60,F
....................  
....................    if (quad == 0 || quad == 2) 
0D28:  MOVF   x60,F
0D2A:  BZ    0D32
0D2C:  MOVF   x60,W
0D2E:  SUBLW  02
0D30:  BNZ   0D66
....................       t = frac * PI_DIV_BY_TWO; 
0D32:  MOVFF  65,81
0D36:  MOVFF  64,80
0D3A:  MOVFF  63,7F
0D3E:  MOVFF  62,7E
0D42:  MOVLW  DB
0D44:  MOVWF  x85
0D46:  MOVLW  0F
0D48:  MOVWF  x84
0D4A:  MOVLW  49
0D4C:  MOVWF  x83
0D4E:  MOVLW  7F
0D50:  MOVWF  x82
0D52:  RCALL  0596
0D54:  MOVFF  03,5B
0D58:  MOVFF  02,5A
0D5C:  MOVFF  01,59
0D60:  MOVFF  00,58
0D64:  BRA    0E30
....................    else if (quad == 1) 
0D66:  DECFSZ x60,W
0D68:  BRA    0DCE
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0D6A:  BSF    FD8.1
0D6C:  CLRF   x81
0D6E:  CLRF   x80
0D70:  CLRF   x7F
0D72:  MOVLW  7F
0D74:  MOVWF  x7E
0D76:  MOVFF  65,85
0D7A:  MOVFF  64,84
0D7E:  MOVFF  63,83
0D82:  MOVFF  62,82
0D86:  RCALL  07E2
0D88:  MOVFF  03,7D
0D8C:  MOVFF  02,7C
0D90:  MOVFF  01,7B
0D94:  MOVFF  00,7A
0D98:  MOVFF  03,81
0D9C:  MOVFF  02,80
0DA0:  MOVFF  01,7F
0DA4:  MOVFF  00,7E
0DA8:  MOVLW  DB
0DAA:  MOVWF  x85
0DAC:  MOVLW  0F
0DAE:  MOVWF  x84
0DB0:  MOVLW  49
0DB2:  MOVWF  x83
0DB4:  MOVLW  7F
0DB6:  MOVWF  x82
0DB8:  CALL   0596
0DBC:  MOVFF  03,5B
0DC0:  MOVFF  02,5A
0DC4:  MOVFF  01,59
0DC8:  MOVFF  00,58
0DCC:  BRA    0E30
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0DCE:  BSF    FD8.1
0DD0:  MOVFF  65,81
0DD4:  MOVFF  64,80
0DD8:  MOVFF  63,7F
0DDC:  MOVFF  62,7E
0DE0:  CLRF   x85
0DE2:  CLRF   x84
0DE4:  CLRF   x83
0DE6:  MOVLW  7F
0DE8:  MOVWF  x82
0DEA:  RCALL  07E2
0DEC:  MOVFF  03,7D
0DF0:  MOVFF  02,7C
0DF4:  MOVFF  01,7B
0DF8:  MOVFF  00,7A
0DFC:  MOVFF  03,81
0E00:  MOVFF  02,80
0E04:  MOVFF  01,7F
0E08:  MOVFF  00,7E
0E0C:  MOVLW  DB
0E0E:  MOVWF  x85
0E10:  MOVLW  0F
0E12:  MOVWF  x84
0E14:  MOVLW  49
0E16:  MOVWF  x83
0E18:  MOVLW  7F
0E1A:  MOVWF  x82
0E1C:  CALL   0596
0E20:  MOVFF  03,5B
0E24:  MOVFF  02,5A
0E28:  MOVFF  01,59
0E2C:  MOVFF  00,58
....................  
....................    y = 1.0; 
0E30:  CLRF   57
0E32:  CLRF   56
0E34:  CLRF   55
0E36:  MOVLW  7F
0E38:  MOVWF  54
....................    t = t * t; 
0E3A:  MOVFF  5B,81
0E3E:  MOVFF  5A,80
0E42:  MOVFF  59,7F
0E46:  MOVFF  58,7E
0E4A:  MOVFF  5B,85
0E4E:  MOVFF  5A,84
0E52:  MOVFF  59,83
0E56:  MOVFF  58,82
0E5A:  CALL   0596
0E5E:  MOVFF  03,5B
0E62:  MOVFF  02,5A
0E66:  MOVFF  01,59
0E6A:  MOVFF  00,58
....................    for (i = 0; i <= 4; i++) 
0E6E:  CLRF   x61
0E70:  MOVF   x61,W
0E72:  SUBLW  04
0E74:  BNC   0F28
....................    { 
....................       t2 = t2 * t; 
0E76:  MOVFF  5F,81
0E7A:  MOVFF  5E,80
0E7E:  MOVFF  5D,7F
0E82:  MOVFF  5C,7E
0E86:  MOVFF  5B,85
0E8A:  MOVFF  5A,84
0E8E:  MOVFF  59,83
0E92:  MOVFF  58,82
0E96:  CALL   0596
0E9A:  MOVFF  03,5F
0E9E:  MOVFF  02,5E
0EA2:  MOVFF  01,5D
0EA6:  MOVFF  00,5C
....................       y = y + p[i] * t2; 
0EAA:  MOVF   x61,W
0EAC:  MULLW  04
0EAE:  MOVF   FF3,W
0EB0:  CLRF   03
0EB2:  ADDLW  66
0EB4:  MOVWF  FE9
0EB6:  MOVLW  00
0EB8:  ADDWFC 03,W
0EBA:  MOVWF  FEA
0EBC:  MOVFF  FEF,7E
0EC0:  MOVFF  FEC,7F
0EC4:  MOVFF  FEC,80
0EC8:  MOVFF  FEC,81
0ECC:  MOVFF  5F,85
0ED0:  MOVFF  5E,84
0ED4:  MOVFF  5D,83
0ED8:  MOVFF  5C,82
0EDC:  CALL   0596
0EE0:  MOVFF  FEA,7B
0EE4:  MOVFF  FE9,7A
0EE8:  BCF    FD8.1
0EEA:  MOVFF  57,81
0EEE:  MOVFF  56,80
0EF2:  MOVFF  55,7F
0EF6:  MOVFF  54,7E
0EFA:  MOVFF  03,85
0EFE:  MOVFF  02,84
0F02:  MOVFF  01,83
0F06:  MOVFF  00,82
0F0A:  RCALL  07E2
0F0C:  MOVFF  7B,FEA
0F10:  MOVFF  7A,FE9
0F14:  MOVFF  03,57
0F18:  MOVFF  02,56
0F1C:  MOVFF  01,55
0F20:  MOVFF  00,54
0F24:  INCF   x61,F
0F26:  BRA    0E70
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
0F28:  MOVF   x60,W
0F2A:  SUBLW  02
0F2C:  BZ    0F32
0F2E:  DECFSZ x60,W
0F30:  BRA    0F38
....................       y = -y;  // correct sign 
0F32:  MOVF   55,W
0F34:  XORLW  80
0F36:  MOVWF  55
....................  
....................    return (y); 
0F38:  MOVFF  54,00
0F3C:  MOVFF  55,01
0F40:  MOVFF  56,02
0F44:  MOVFF  57,03
0F48:  GOTO   15C8 (RETURN)
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
*
017E:  BSF    F95.6
0180:  MOVLW  11
0182:  MOVWF  00
0184:  DECFSZ 00,F
0186:  BRA    0184
0188:  BSF    F95.7
018A:  MOVLW  11
018C:  MOVWF  00
018E:  DECFSZ 00,F
0190:  BRA    018E
0192:  BCF    F8C.6
0194:  BCF    F95.6
0196:  MOVLW  11
0198:  MOVWF  00
019A:  DECFSZ 00,F
019C:  BRA    019A
019E:  BCF    F8C.7
01A0:  BCF    F95.7
....................         delay_us(20); 
01A2:  MOVLW  4F
01A4:  MOVWF  00
01A6:  DECFSZ 00,F
01A8:  BRA    01A6
01AA:  BRA    01AC
....................         i2c_write(LCD_ADDR); //the slave addresse 
01AC:  MOVLW  4E
01AE:  MOVWF  x63
01B0:  RCALL  0112
....................         delay_us(20); 
01B2:  MOVLW  4F
01B4:  MOVWF  00
01B6:  DECFSZ 00,F
01B8:  BRA    01B6
01BA:  BRA    01BC
....................         i2c_write(data); 
01BC:  MOVFF  62,63
01C0:  RCALL  0112
....................         delay_us(20); 
01C2:  MOVLW  4F
01C4:  MOVWF  00
01C6:  DECFSZ 00,F
01C8:  BRA    01C6
01CA:  BRA    01CC
....................         i2c_stop(); 
01CC:  BCF    F95.6
01CE:  NOP   
01D0:  BSF    F95.7
01D2:  BTFSS  F83.7
01D4:  BRA    01D2
01D6:  MOVLW  11
01D8:  MOVWF  00
01DA:  DECFSZ 00,F
01DC:  BRA    01DA
01DE:  BRA    01E0
01E0:  NOP   
01E2:  BSF    F95.6
01E4:  MOVLW  11
01E6:  MOVWF  00
01E8:  DECFSZ 00,F
01EA:  BRA    01E8
....................         delay_us(20); 
01EC:  MOVLW  4F
01EE:  MOVWF  00
01F0:  DECFSZ 00,F
01F2:  BRA    01F0
01F4:  BRA    01F6
01F6:  RETURN 0
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
01F8:  BTFSS  20.0
01FA:  BRA    0206
01FC:  MOVF   x61,W
01FE:  IORLW  04
0200:  IORLW  08
0202:  MOVWF  x61
0204:  BRA    0208
0206:  BSF    x61.2
....................         i2c_send_nibble(data); 
0208:  MOVFF  61,62
020C:  RCALL  017E
....................         data=data-4;       //toggle EN back to 0 
020E:  MOVLW  04
0210:  SUBWF  x61,F
....................         i2c_send_nibble(data); 
0212:  MOVFF  61,62
0216:  RCALL  017E
0218:  RETURN 0
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
021A:  CLRF   x61
021C:  RCALL  01F8
....................     lcd_send_byte(0x10); 
021E:  MOVLW  10
0220:  MOVWF  x61
0222:  RCALL  01F8
....................     delay_ms(2); 
0224:  MOVLW  02
0226:  MOVWF  5F
0228:  RCALL  00EA
022A:  RETURN 0
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
022C:  MOVLW  C8
022E:  MOVWF  5F
0230:  RCALL  00EA
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
0232:  CLRF   x61
0234:  RCALL  01F8
....................         lcd_send_byte(0x10); 
0236:  MOVLW  10
0238:  MOVWF  x61
023A:  RCALL  01F8
....................         lcd_send_byte(0x00); 
023C:  CLRF   x61
023E:  RCALL  01F8
....................         lcd_send_byte(0x00); 
0240:  CLRF   x61
0242:  RCALL  01F8
....................         lcd_send_byte(0x10); 
0244:  MOVLW  10
0246:  MOVWF  x61
0248:  RCALL  01F8
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
024A:  MOVLW  30
024C:  MOVWF  x61
024E:  RCALL  01F8
....................         lcd_send_byte(0x30); 
0250:  MOVLW  30
0252:  MOVWF  x61
0254:  RCALL  01F8
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
0256:  MOVLW  30
0258:  MOVWF  x61
025A:  RCALL  01F8
....................         lcd_send_byte(0x20); 
025C:  MOVLW  20
025E:  MOVWF  x61
0260:  RCALL  01F8
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
0262:  MOVLW  20
0264:  MOVWF  x61
0266:  RCALL  01F8
....................         lcd_send_byte(0x80); 
0268:  MOVLW  80
026A:  MOVWF  x61
026C:  RCALL  01F8
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
026E:  CLRF   x61
0270:  RCALL  01F8
....................         lcd_send_byte(0xC0); 
0272:  MOVLW  C0
0274:  MOVWF  x61
0276:  RCALL  01F8
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
0278:  CLRF   x61
027A:  RCALL  01F8
....................         lcd_send_byte(0x60); 
027C:  MOVLW  60
027E:  MOVWF  x61
0280:  RCALL  01F8
....................            //clears the display 
....................         lcd_clear(); 
0282:  RCALL  021A
0284:  GOTO   037E (RETURN)
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
0288:  MOVF   x60,W
028A:  XORLW  01
028C:  BZ    029C
028E:  XORLW  03
0290:  BZ    02A2
0292:  XORLW  01
0294:  BZ    02A8
0296:  XORLW  07
0298:  BZ    02AE
029A:  BRA    02B4
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
029C:  MOVLW  80
029E:  MOVWF  1F
02A0:  BRA    02B8
....................       case 2:  address= lcd_line_two;     break; 
02A2:  MOVLW  C0
02A4:  MOVWF  1F
02A6:  BRA    02B8
....................       case 3:  address= lcd_line_three;   break; 
02A8:  MOVLW  94
02AA:  MOVWF  1F
02AC:  BRA    02B8
....................       case 4:  address= lcd_line_four;    break; 
02AE:  MOVLW  D4
02B0:  MOVWF  1F
02B2:  BRA    02B8
....................       default: address= lcd_line_one;     break;  
02B4:  MOVLW  80
02B6:  MOVWF  1F
....................    } 
....................   
....................    address+=x-1; 
02B8:  MOVLW  01
02BA:  SUBWF  5F,W
02BC:  ADDWF  1F,F
....................    data=address&0xF0; 
02BE:  MOVF   1F,W
02C0:  ANDLW  F0
02C2:  MOVWF  26
....................    lcd_send_byte(data); 
02C4:  MOVFF  26,61
02C8:  RCALL  01F8
....................    data=address&0x0F; 
02CA:  MOVF   1F,W
02CC:  ANDLW  0F
02CE:  MOVWF  26
....................    data=data<<4; 
02D0:  SWAPF  26,F
02D2:  MOVLW  F0
02D4:  ANDWF  26,F
....................    lcd_send_byte(data); 
02D6:  MOVFF  26,61
02DA:  RCALL  01F8
02DC:  RETURN 0
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
02DE:  MOVF   5E,W
02E0:  XORLW  0C
02E2:  BZ    02F6
02E4:  XORLW  0D
02E6:  BZ    02FA
02E8:  XORLW  03
02EA:  BZ    0304
02EC:  XORLW  01
02EE:  BZ    0310
02F0:  XORLW  07
02F2:  BZ    031C
02F4:  BRA    0328
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
02F6:  RCALL  021A
02F8:  BRA    034A
....................      case '\1': lcd_gotoxy(1,1);  break; 
02FA:  MOVLW  01
02FC:  MOVWF  5F
02FE:  MOVWF  x60
0300:  RCALL  0288
0302:  BRA    034A
....................      case '\2': lcd_gotoxy(1,2);  break; 
0304:  MOVLW  01
0306:  MOVWF  5F
0308:  MOVLW  02
030A:  MOVWF  x60
030C:  RCALL  0288
030E:  BRA    034A
....................      case '\3': lcd_gotoxy(1,3);  break; 
0310:  MOVLW  01
0312:  MOVWF  5F
0314:  MOVLW  03
0316:  MOVWF  x60
0318:  RCALL  0288
031A:  BRA    034A
....................      case '\4': lcd_gotoxy(1,4);  break; 
031C:  MOVLW  01
031E:  MOVWF  5F
0320:  MOVLW  04
0322:  MOVWF  x60
0324:  RCALL  0288
0326:  BRA    034A
....................  
....................      default: 
....................         data=in_data&0xF0; 
0328:  MOVF   5E,W
032A:  ANDLW  F0
032C:  MOVWF  5F
....................         data=data|RS; //set RS pin to 1 
032E:  BSF    5F.0
....................         lcd_send_byte(data); 
0330:  MOVFF  5F,61
0334:  RCALL  01F8
....................         data=in_data&0x0F; 
0336:  MOVF   5E,W
0338:  ANDLW  0F
033A:  MOVWF  5F
....................         data=data<<4; 
033C:  SWAPF  5F,F
033E:  MOVLW  F0
0340:  ANDWF  5F,F
....................         data=data|RS; //set RS pin to 1 
0342:  BSF    5F.0
....................         lcd_send_byte(data); 
0344:  MOVFF  5F,61
0348:  RCALL  01F8
....................      break; 
....................    } 
034A:  RETURN 0
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #include <Control_ADCs.h> 
.................... /*  
....................  * File:   MAX191.h 
....................  * Author: MARCOS 
....................  * 
....................  * Created on 23 de septiembre de 2016, 08:14 
....................  */ 
....................  
.................... #ifndef Control_ADCs_H 
.................... #define Control_ADCs_H 
....................  
.................... #define ADC_CSCorriente PIN_A0  // salida 
.................... #define ADC_CSTension PIN_A1 // salida 
.................... #define ADC_SCLK PIN_A2 // salida clock tension 
.................... #define ADC_SCLKcorr PIN_B1 
.................... #define ADC_DOUT PIN_B0  // entrada, por aqui ingresa la info del MAX186 
.................... #define ADC_DIN PIN_A4 //salida, se envia la informacion al MAX186 
.................... #define ADC_SSTRB PIN_A5//entrada 
.................... #define ADC_SDATA PIN_A3//entrada SDATA en AD7450 
....................  
.................... //control AD7450 
.................... signed long leer_Tension(){ 
*
03A0:  CLRF   51
03A2:  CLRF   50
....................     signed long dato=0,dato_t; 
....................     int i; 
....................     output_low (ADC_CSTension); 
03A4:  BCF    F92.1
03A6:  BCF    F89.1
....................     delay_us(1); 
03A8:  MOVLW  03
03AA:  MOVWF  00
03AC:  DECFSZ 00,F
03AE:  BRA    03AC
03B0:  BRA    03B2
....................     output_low (ADC_SCLK); 
03B2:  BCF    F92.2
03B4:  BCF    F89.2
....................     delay_us(1); 
03B6:  MOVLW  03
03B8:  MOVWF  00
03BA:  DECFSZ 00,F
03BC:  BRA    03BA
03BE:  BRA    03C0
....................     output_high (ADC_SCLK); 
03C0:  BCF    F92.2
03C2:  BSF    F89.2
....................     delay_us(1); 
03C4:  MOVLW  03
03C6:  MOVWF  00
03C8:  DECFSZ 00,F
03CA:  BRA    03C8
03CC:  BRA    03CE
....................      
....................         for(i=0;i<15;i++){ 
03CE:  CLRF   54
03D0:  MOVF   54,W
03D2:  SUBLW  0E
03D4:  BNC   0406
....................           shift_left(&dato,2,input(ADC_SDATA)); 
03D6:  BSF    F92.3
03D8:  BTFSC  F80.3
03DA:  BRA    03E0
03DC:  BCF    FD8.0
03DE:  BRA    03E2
03E0:  BSF    FD8.0
03E2:  RLCF   50,F
03E4:  RLCF   51,F
....................           output_low(ADC_SCLK); 
03E6:  BCF    F92.2
03E8:  BCF    F89.2
....................           delay_us(1);  
03EA:  MOVLW  03
03EC:  MOVWF  00
03EE:  DECFSZ 00,F
03F0:  BRA    03EE
03F2:  BRA    03F4
....................           output_high(ADC_SCLK);  
03F4:  BCF    F92.2
03F6:  BSF    F89.2
....................           delay_us(1); 
03F8:  MOVLW  03
03FA:  MOVWF  00
03FC:  DECFSZ 00,F
03FE:  BRA    03FC
0400:  BRA    0402
0402:  INCF   54,F
0404:  BRA    03D0
....................         } 
....................  
....................        // output_high (ADC_SCLK); 
....................        // delay_us(1); 
....................         output_high (ADC_CSTension); 
0406:  BCF    F92.1
0408:  BSF    F89.1
....................          
....................        dato_t=(dato&0x0800); 
040A:  CLRF   52
040C:  MOVF   51,W
040E:  ANDLW  08
0410:  MOVWF  53
....................          
....................       if (dato_t==0x0800){ 
0412:  MOVF   52,F
0414:  BNZ   0430
0416:  MOVF   53,W
0418:  SUBLW  08
041A:  BNZ   0430
....................             dato=-2048+(dato&0xF7FF); 
041C:  MOVFF  50,00
0420:  MOVF   51,W
0422:  ANDLW  F7
0424:  MOVWF  03
0426:  MOVFF  50,50
042A:  MOVLW  F8
042C:  ADDWF  03,W
042E:  MOVWF  51
....................       } 
....................     return(dato); 
0430:  MOVFF  50,01
0434:  MOVFF  51,02
0438:  GOTO   11DE (RETURN)
.................... } 
....................  
.................... //control MAX186 
.................... long leer_Corriente(){ 
043C:  CLRF   51
043E:  CLRF   50
0440:  MOVLW  8E
0442:  MOVWF  52
....................     long dato=0; 
....................     BYTE config= 0b10001110; 
....................     int i; 
....................     output_low (ADC_CSCorriente); 
0444:  BCF    F92.0
0446:  BCF    F89.0
....................     output_low (ADC_DIN); 
0448:  BCF    F92.4
044A:  BCF    F89.4
....................     delay_us(1); 
044C:  MOVLW  03
044E:  MOVWF  00
0450:  DECFSZ 00,F
0452:  BRA    0450
0454:  BRA    0456
....................      
....................     for(i=0; i<8; i++) { 
0456:  CLRF   53
0458:  MOVF   53,W
045A:  SUBLW  07
045C:  BNC   048C
....................       output_bit(ADC_DIN, shift_left(&config,1,0)); 
045E:  BCF    FD8.0
0460:  RLCF   52,F
0462:  BC    0468
0464:  BCF    F89.4
0466:  BRA    046A
0468:  BSF    F89.4
046A:  BCF    F92.4
....................       output_high(ADC_SCLKcorr); 
046C:  BCF    F93.1
046E:  BSF    F8A.1
....................       delay_us(1); 
0470:  MOVLW  03
0472:  MOVWF  00
0474:  DECFSZ 00,F
0476:  BRA    0474
0478:  BRA    047A
....................       output_low(ADC_SCLKcorr);	 
047A:  BCF    F93.1
047C:  BCF    F8A.1
....................       delay_us(1); 
047E:  MOVLW  03
0480:  MOVWF  00
0482:  DECFSZ 00,F
0484:  BRA    0482
0486:  BRA    0488
0488:  INCF   53,F
048A:  BRA    0458
....................    } 
....................  
....................     output_high(ADC_CSCorriente); 
048C:  BCF    F92.0
048E:  BSF    F89.0
....................      
....................     while(input(ADC_SSTRB)=='0');    
....................          
....................         output_low (ADC_CSCorriente); 
0490:  BCF    F92.0
0492:  BCF    F89.0
....................         output_high (ADC_SCLKcorr); 
0494:  BCF    F93.1
0496:  BSF    F8A.1
....................         delay_us(1); 
0498:  MOVLW  03
049A:  MOVWF  00
049C:  DECFSZ 00,F
049E:  BRA    049C
04A0:  BRA    04A2
....................         output_low (ADC_SCLKcorr); 
04A2:  BCF    F93.1
04A4:  BCF    F8A.1
....................         delay_us(1); 
04A6:  MOVLW  03
04A8:  MOVWF  00
04AA:  DECFSZ 00,F
04AC:  BRA    04AA
04AE:  BRA    04B0
....................          
....................         for(i=0;i<15;i++){ 
04B0:  CLRF   53
04B2:  MOVF   53,W
04B4:  SUBLW  0E
04B6:  BNC   04E8
....................           output_high(ADC_SCLKcorr); 
04B8:  BCF    F93.1
04BA:  BSF    F8A.1
....................           delay_us(1); 
04BC:  MOVLW  03
04BE:  MOVWF  00
04C0:  DECFSZ 00,F
04C2:  BRA    04C0
04C4:  BRA    04C6
....................           shift_left(&dato,2,input(ADC_DOUT));  
04C6:  BSF    F93.0
04C8:  BTFSC  F81.0
04CA:  BRA    04D0
04CC:  BCF    FD8.0
04CE:  BRA    04D2
04D0:  BSF    FD8.0
04D2:  RLCF   50,F
04D4:  RLCF   51,F
....................           output_low(ADC_SCLKcorr); 
04D6:  BCF    F93.1
04D8:  BCF    F8A.1
....................           delay_us(1); 
04DA:  MOVLW  03
04DC:  MOVWF  00
04DE:  DECFSZ 00,F
04E0:  BRA    04DE
04E2:  BRA    04E4
04E4:  INCF   53,F
04E6:  BRA    04B2
....................         } 
....................   
....................          
....................         output_high (ADC_CSCorriente); 
04E8:  BCF    F92.0
04EA:  BSF    F89.0
....................      
....................        
....................     dato= (dato>>3)& 0x0FFF; 
04EC:  RRCF   51,W
04EE:  MOVWF  55
04F0:  RRCF   50,W
04F2:  MOVWF  54
04F4:  RRCF   55,F
04F6:  RRCF   54,F
04F8:  RRCF   55,F
04FA:  RRCF   54,F
04FC:  MOVLW  1F
04FE:  ANDWF  55,F
0500:  MOVFF  54,50
0504:  MOVF   55,W
0506:  ANDLW  0F
0508:  MOVWF  51
....................     return(dato); 
050A:  MOVFF  50,01
050E:  MOVFF  51,02
0512:  GOTO   11EA (RETURN)
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //Implementacion Switch-Case 
....................  
.................... /** 
.................... *	\fn void maquina_estado() 
.................... *	\brief Implementacion Switch-Case 
.................... *	\details  
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
....................  **/ 
.................... signed long punto1; 
.................... long punto2; 
.................... //int16 tiempo_potencia; 
.................... BYTE pos_V,pos_I,pos_V_A,pos_I_A; 
.................... int control_V; 
.................... int control_I; 
.................... int desfase; 
.................... int puntos=20;//puntos por periodo 
.................... float tension, corriente, tension_RMS,corriente_RMS, t_desfase, potencia_ins,angulo; 
.................... //float Energia_Wms=0, Energia_Wh=0, Energia_kWh=0; 
....................  
.................... const long carga= 0xE8AB; 
....................  
.................... #INT_RTCC               // interrupcion para demora de 1 ms 
.................... void interrtimer_0(){ 
....................     set_timer0(carga);   // interrupcion cada 1 ms 
*
00BC:  MOVLW  E8
00BE:  MOVWF  FD7
00C0:  MOVLW  AB
00C2:  MOVWF  FD6
....................     pulso_timer++; 
00C4:  INCF   25,F
....................  
00C6:  BCF    FF2.2
00C8:  GOTO   0060
....................    } 
....................  
.................... void maquina_estado() 
.................... { 
.................... 		static int estado = PUNTO_TENS_CORR; 
....................  
.................... 		switch(estado) 
*
11BC:  MOVF   4F,W
11BE:  XORLW  00
11C0:  BZ    11DA
11C2:  XORLW  01
11C4:  BZ    1232
11C6:  XORLW  03
11C8:  BTFSC  FD8.2
11CA:  BRA    13AC
11CC:  XORLW  01
11CE:  BTFSC  FD8.2
11D0:  BRA    147E
11D2:  XORLW  07
11D4:  BTFSC  FD8.2
11D6:  BRA    1654
11D8:  BRA    1734
.................... 		{ 
.................... 			case PUNTO_TENS_CORR: 
....................                 punto1= leer_Tension(); 
11DA:  GOTO   03A0
11DE:  MOVFF  02,28
11E2:  MOVFF  01,27
....................                 punto2= leer_Corriente(); // comprobar si funciona con el tiempo de demora de la lectura del externo 
11E6:  GOTO   043C
11EA:  MOVFF  02,2A
11EE:  MOVFF  01,29
....................                 // convierte los valores de long a float 
....................                 tension=punto1; 
11F2:  MOVFF  28,51
11F6:  MOVFF  27,50
11FA:  GOTO   0516
11FE:  MOVFF  03,36
1202:  MOVFF  02,35
1206:  MOVFF  01,34
120A:  MOVFF  00,33
....................                 corriente=punto2; 
120E:  MOVFF  2A,7F
1212:  MOVFF  29,7E
1216:  CALL   0560
121A:  MOVFF  03,3A
121E:  MOVFF  02,39
1222:  MOVFF  01,38
1226:  MOVFF  00,37
....................                 contador++; 
122A:  INCF   22,F
.................... 					estado = CONVERSION_DESFASE; 
122C:  MOVLW  01
122E:  MOVWF  4F
....................  
.................... 				break; 
1230:  BRA    1736
.................... 			 
.................... 			case CONVERSION_DESFASE: 
....................                 tension= (tension)*2.5/2048; 
1232:  MOVFF  36,81
1236:  MOVFF  35,80
123A:  MOVFF  34,7F
123E:  MOVFF  33,7E
1242:  CLRF   x85
1244:  CLRF   x84
1246:  MOVLW  20
1248:  MOVWF  x83
124A:  MOVLW  80
124C:  MOVWF  x82
124E:  CALL   0596
1252:  MOVFF  03,53
1256:  MOVFF  02,52
125A:  MOVFF  01,51
125E:  MOVFF  00,50
1262:  MOVFF  03,65
1266:  MOVFF  02,64
126A:  MOVFF  01,63
126E:  MOVFF  00,62
1272:  CLRF   x69
1274:  CLRF   x68
1276:  CLRF   x67
1278:  MOVLW  8A
127A:  MOVWF  x66
127C:  CALL   0688
1280:  MOVFF  03,36
1284:  MOVFF  02,35
1288:  MOVFF  01,34
128C:  MOVFF  00,33
....................                 corriente= (corriente)/1000-2.510; 
1290:  MOVFF  3A,65
1294:  MOVFF  39,64
1298:  MOVFF  38,63
129C:  MOVFF  37,62
12A0:  CLRF   x69
12A2:  CLRF   x68
12A4:  MOVLW  7A
12A6:  MOVWF  x67
12A8:  MOVLW  88
12AA:  MOVWF  x66
12AC:  CALL   0688
12B0:  MOVFF  03,53
12B4:  MOVFF  02,52
12B8:  MOVFF  01,51
12BC:  MOVFF  00,50
12C0:  BSF    FD8.1
12C2:  MOVFF  03,81
12C6:  MOVFF  02,80
12CA:  MOVFF  01,7F
12CE:  MOVFF  00,7E
12D2:  MOVLW  D7
12D4:  MOVWF  x85
12D6:  MOVLW  A3
12D8:  MOVWF  x84
12DA:  MOVLW  20
12DC:  MOVWF  x83
12DE:  MOVLW  80
12E0:  MOVWF  x82
12E2:  CALL   07E2
12E6:  MOVFF  03,3A
12EA:  MOVFF  02,39
12EE:  MOVFF  01,38
12F2:  MOVFF  00,37
....................                 //se convierte a la tension y corriente real 
....................                 tension= tension*155.57; // conversion con 2 V igual a 311.13 V 
12F6:  MOVFF  36,81
12FA:  MOVFF  35,80
12FE:  MOVFF  34,7F
1302:  MOVFF  33,7E
1306:  MOVLW  EC
1308:  MOVWF  x85
130A:  MOVLW  91
130C:  MOVWF  x84
130E:  MOVLW  1B
1310:  MOVWF  x83
1312:  MOVLW  86
1314:  MOVWF  x82
1316:  CALL   0596
131A:  MOVFF  03,36
131E:  MOVFF  02,35
1322:  MOVFF  01,34
1326:  MOVFF  00,33
....................                 corriente= corriente*12; // 2.5 V es igual a +30 A (recordar que el sensor mide 30A) 
132A:  MOVFF  3A,81
132E:  MOVFF  39,80
1332:  MOVFF  38,7F
1336:  MOVFF  37,7E
133A:  CLRF   x85
133C:  CLRF   x84
133E:  MOVLW  40
1340:  MOVWF  x83
1342:  MOVLW  82
1344:  MOVWF  x82
1346:  CALL   0596
134A:  MOVFF  03,3A
134E:  MOVFF  02,39
1352:  MOVFF  01,38
1356:  MOVFF  00,37
....................                  
....................                 // Analisis del punto POSITVO O NEGATIVO 
....................                 // valor positivo estado=0-- valor negativo estado=1 
....................                  
....................                 //TENSION 
....................                 #asm 
....................                 clrf &pos_V; 
135A:  CLRF   2B
....................                 btfsc (&tension + 0x01), 7; 
135C:  BTFSC  34.7
....................                 bsf &pos_V,0; 
135E:  BSF    2B.0
....................                 #endasm 
.................... 				 
....................                 //CORRIENTE 
....................                 #asm 
....................                 clrf &pos_I; 
1360:  CLRF   2C
....................                 btfsc (&corriente + 0x01), 7; // comprueba signo en un bit de los 4 byte del float 
1362:  BTFSC  38.7
....................                 bsf &pos_I,0; 
1364:  BSF    2C.0
....................                 #endasm 
....................  
....................                  
....................                  
.................... 				 
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contador distinto de cero) 
....................                 if (pos_V==1 && contador>=2 && pos_V_A==0 && desfase!=1){  
1366:  DECFSZ 2B,W
1368:  BRA    1382
136A:  MOVF   22,W
136C:  SUBLW  01
136E:  BC    1382
1370:  MOVF   2D,F
1372:  BNZ   1382
1374:  DECFSZ 31,W
1376:  BRA    137A
1378:  BRA    1382
....................                  control_V= contador; // tiempo en el que cruz la tension  
137A:  MOVFF  22,2F
....................                  desfase=1; 
137E:  MOVLW  01
1380:  MOVWF  31
....................                 } 
....................                  
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_I==1 && contador>=2 && pos_I_A==0 && desfase!=2){ 
1382:  DECFSZ 2C,W
1384:  BRA    139E
1386:  MOVF   22,W
1388:  SUBLW  01
138A:  BC    139E
138C:  MOVF   2E,F
138E:  BNZ   139E
1390:  MOVF   31,W
1392:  SUBLW  02
1394:  BZ    139E
....................                      
....................                  control_I= contador; // tiempo en el que cruz la corriente 
1396:  MOVFF  22,30
....................                  desfase=2; 
139A:  MOVLW  02
139C:  MOVWF  31
....................                 } 
....................                 // guarda el signo de los puntos anteriores 
....................                 pos_V_A=pos_V; 
139E:  MOVFF  2B,2D
....................                 pos_I_A=pos_I; 
13A2:  MOVFF  2C,2E
....................                  
....................                  
.................... 					estado = TENS_CORR_RMS; 
13A6:  MOVLW  02
13A8:  MOVWF  4F
.................... 		 
.................... 				 
....................  
.................... 				break; 
13AA:  BRA    1736
.................... //---------------------------------------------------------------------------------------------------- 
....................                  
.................... 			case TENS_CORR_RMS: 
.................... 			 
.................... 				if((contador<30)&& (pulso_timer==1)) 
13AC:  MOVF   22,W
13AE:  SUBLW  1D
13B0:  BNC   147C
13B2:  DECFSZ 25,W
13B4:  BRA    147C
.................... 				{ 
.................... 					tension_RMS=tension_RMS+ tension * tension;       //calcula tension eficaz 
13B6:  MOVFF  36,81
13BA:  MOVFF  35,80
13BE:  MOVFF  34,7F
13C2:  MOVFF  33,7E
13C6:  MOVFF  36,85
13CA:  MOVFF  35,84
13CE:  MOVFF  34,83
13D2:  MOVFF  33,82
13D6:  CALL   0596
13DA:  BCF    FD8.1
13DC:  MOVFF  3E,81
13E0:  MOVFF  3D,80
13E4:  MOVFF  3C,7F
13E8:  MOVFF  3B,7E
13EC:  MOVFF  03,85
13F0:  MOVFF  02,84
13F4:  MOVFF  01,83
13F8:  MOVFF  00,82
13FC:  CALL   07E2
1400:  MOVFF  03,3E
1404:  MOVFF  02,3D
1408:  MOVFF  01,3C
140C:  MOVFF  00,3B
....................                     corriente_RMS= corriente_RMS+ corriente * corriente; // calcula corriente eficaz 
1410:  MOVFF  3A,81
1414:  MOVFF  39,80
1418:  MOVFF  38,7F
141C:  MOVFF  37,7E
1420:  MOVFF  3A,85
1424:  MOVFF  39,84
1428:  MOVFF  38,83
142C:  MOVFF  37,82
1430:  CALL   0596
1434:  BCF    FD8.1
1436:  MOVFF  42,81
143A:  MOVFF  41,80
143E:  MOVFF  40,7F
1442:  MOVFF  3F,7E
1446:  MOVFF  03,85
144A:  MOVFF  02,84
144E:  MOVFF  01,83
1452:  MOVFF  00,82
1456:  CALL   07E2
145A:  MOVFF  03,42
145E:  MOVFF  02,41
1462:  MOVFF  01,40
1466:  MOVFF  00,3F
....................                     pulso_timer=0; 
146A:  CLRF   25
....................                      
.................... 					estado = PUNTO_TENS_CORR; 
146C:  CLRF   4F
....................                      
....................                     if((contador== 29)){ 
146E:  MOVF   22,W
1470:  SUBLW  1D
1472:  BNZ   147C
.................... 					disable_interrupts(INT_RTCC);// deshabilita la interrupcion para no entrar al timer 
1474:  BCF    FF2.5
....................                     contador=0; //se reinicia el contador, para comenzar nuevamente  
1476:  CLRF   22
.................... 					estado = CALCULO_POT_ENER; 
1478:  MOVLW  03
147A:  MOVWF  4F
.................... 				} 
.................... 				} 
.................... 				 
....................  
.................... 				break; 
147C:  BRA    1736
....................                  
.................... //--------------------------------------------------------------------------------------------------------------------                 
.................... 			 
.................... 			case CALCULO_POT_ENER: // falta calculo de energia 
....................                 //calcula las raices para completar el calculo RMS 
.................... 				tension_RMS= sqrt(tension_RMS/30); 
147E:  MOVFF  3E,65
1482:  MOVFF  3D,64
1486:  MOVFF  3C,63
148A:  MOVFF  3B,62
148E:  CLRF   x69
1490:  CLRF   x68
1492:  MOVLW  70
1494:  MOVWF  x67
1496:  MOVLW  83
1498:  MOVWF  x66
149A:  CALL   0688
149E:  MOVFF  03,53
14A2:  MOVFF  02,52
14A6:  MOVFF  01,51
14AA:  MOVFF  00,50
14AE:  MOVFF  03,57
14B2:  MOVFF  02,56
14B6:  MOVFF  01,55
14BA:  MOVFF  00,54
14BE:  CALL   0AC2
14C2:  MOVFF  03,3E
14C6:  MOVFF  02,3D
14CA:  MOVFF  01,3C
14CE:  MOVFF  00,3B
....................                 corriente_RMS= sqrt(corriente_RMS/30); 
14D2:  MOVFF  42,65
14D6:  MOVFF  41,64
14DA:  MOVFF  40,63
14DE:  MOVFF  3F,62
14E2:  CLRF   x69
14E4:  CLRF   x68
14E6:  MOVLW  70
14E8:  MOVWF  x67
14EA:  MOVLW  83
14EC:  MOVWF  x66
14EE:  CALL   0688
14F2:  MOVFF  03,53
14F6:  MOVFF  02,52
14FA:  MOVFF  01,51
14FE:  MOVFF  00,50
1502:  MOVFF  03,57
1506:  MOVFF  02,56
150A:  MOVFF  01,55
150E:  MOVFF  00,54
1512:  CALL   0AC2
1516:  MOVFF  03,42
151A:  MOVFF  02,41
151E:  MOVFF  01,40
1522:  MOVFF  00,3F
....................                  
....................                 // se controla si se pudo calcular desfase en el estado anterior  
....................                 // se realiza las diferencia de cruce por cero y se convierte de tiempo a radianes 
....................                 angulo=0; 
1526:  CLRF   4E
1528:  CLRF   4D
152A:  CLRF   4C
152C:  CLRF   4B
....................                 if (desfase==2){ 
152E:  MOVF   31,W
1530:  SUBLW  02
1532:  BNZ   15B4
....................                     t_desfase= (control_I-control_V); 
1534:  MOVF   2F,W
1536:  SUBWF  30,W
1538:  CLRF   x7F
153A:  MOVWF  x7E
153C:  CALL   0560
1540:  MOVFF  03,46
1544:  MOVFF  02,45
1548:  MOVFF  01,44
154C:  MOVFF  00,43
....................                     angulo= (t_desfase*pi)/10;      // angulo de desfase en radianes. 20 puntos por periodo 
1550:  MOVFF  46,81
1554:  MOVFF  45,80
1558:  MOVFF  44,7F
155C:  MOVFF  43,7E
1560:  MOVLW  DB
1562:  MOVWF  x85
1564:  MOVLW  0F
1566:  MOVWF  x84
1568:  MOVLW  49
156A:  MOVWF  x83
156C:  MOVLW  80
156E:  MOVWF  x82
1570:  CALL   0596
1574:  MOVFF  03,53
1578:  MOVFF  02,52
157C:  MOVFF  01,51
1580:  MOVFF  00,50
1584:  MOVFF  03,65
1588:  MOVFF  02,64
158C:  MOVFF  01,63
1590:  MOVFF  00,62
1594:  CLRF   x69
1596:  CLRF   x68
1598:  MOVLW  20
159A:  MOVWF  x67
159C:  MOVLW  82
159E:  MOVWF  x66
15A0:  CALL   0688
15A4:  MOVFF  03,4E
15A8:  MOVFF  02,4D
15AC:  MOVFF  01,4C
15B0:  MOVFF  00,4B
....................                    /*  lcd_gotoxy(1,1); 
....................                      printf(LCD_PUTC,"desfase= %f       ",t_desfase); 
....................                      lcd_gotoxy(1,2); 
....................                      printf(LCD_PUTC,"angulo=%f        ",angulo); 
....................                      delay_ms(1000);*/ 
....................                 }                 
....................                  
....................                 angulo=cos(angulo); 
15B4:  MOVFF  4E,53
15B8:  MOVFF  4D,52
15BC:  MOVFF  4C,51
15C0:  MOVFF  4B,50
15C4:  GOTO   0C06
15C8:  MOVFF  03,4E
15CC:  MOVFF  02,4D
15D0:  MOVFF  01,4C
15D4:  MOVFF  00,4B
....................                // calculo de potencia  
....................                 potencia_ins= tension_RMS*corriente_RMS*angulo; 
15D8:  MOVFF  3E,81
15DC:  MOVFF  3D,80
15E0:  MOVFF  3C,7F
15E4:  MOVFF  3B,7E
15E8:  MOVFF  42,85
15EC:  MOVFF  41,84
15F0:  MOVFF  40,83
15F4:  MOVFF  3F,82
15F8:  CALL   0596
15FC:  MOVFF  03,53
1600:  MOVFF  02,52
1604:  MOVFF  01,51
1608:  MOVFF  00,50
160C:  MOVFF  03,81
1610:  MOVFF  02,80
1614:  MOVFF  01,7F
1618:  MOVFF  00,7E
161C:  MOVFF  4E,85
1620:  MOVFF  4D,84
1624:  MOVFF  4C,83
1628:  MOVFF  4B,82
162C:  CALL   0596
1630:  MOVFF  03,4A
1634:  MOVFF  02,49
1638:  MOVFF  01,48
163C:  MOVFF  00,47
....................                 //se limpian las variables para la prxima etapa de muestreo 
....................                 control_V=0;       
1640:  CLRF   2F
....................                 control_I=0; 
1642:  CLRF   30
....................                 angulo=0; 
1644:  CLRF   4E
1646:  CLRF   4D
1648:  CLRF   4C
164A:  CLRF   4B
....................                 desfase=0;  
164C:  CLRF   31
....................                /*  
....................                 //Calculo de Energia 
....................                 tiempo_potencia=65536 - get_timer0();    //variable para calcular energia segun tiempo de potencia 
....................                 Energia_Wms=Energia_Wms+potencia_ins*tiempo_potencia/37500000;             //Energia en Watt por milisegundo 
....................                  
....................                 if(Energia_Wms>=3600000){ 
....................                     Energia_Wh=Energia_Wh+1;  // rekacion watt ms a watt hora 
....................                     Energia_Wms=0;                 
....................                 } 
....................                  
....................                 if (Energia_Wh==1000){ 
....................                     Energia_kWh=Energia_kWh+1; 
....................                     Energia_Wh=0; 
....................                 } 
....................                  
....................                  
....................                  
....................                 // Se reinicia timer 0 nuevamente, para volver a calcular energia 
....................                // set_timer0(0x0000);*/ 
....................                  
.................... 					estado = MOSTRAR_DATOS; 
164E:  MOVLW  04
1650:  MOVWF  4F
.................... 				break; 
1652:  BRA    1736
....................                  
.................... //------------------------------------------------------------------------------------- 
....................                  
.................... 			case MOSTRAR_DATOS: 
....................                 //este estado solo muestra los datos en la pantalla LCD 
....................                 lcd_gotoxy(1,1); 
1654:  MOVLW  01
1656:  MOVWF  5F
1658:  MOVWF  x60
165A:  CALL   0288
....................                 printf(LCD_PUTC,"POT= \%f W    ",potencia_ins); 
165E:  MOVLW  CC
1660:  MOVWF  FF6
1662:  MOVLW  00
1664:  MOVWF  FF7
1666:  MOVLW  05
1668:  MOVWF  50
166A:  RCALL  0F4C
166C:  MOVLW  89
166E:  MOVWF  FE9
1670:  MOVFF  4A,53
1674:  MOVFF  49,52
1678:  MOVFF  48,51
167C:  MOVFF  47,50
1680:  MOVLW  02
1682:  MOVWF  54
1684:  RCALL  103A
1686:  MOVLW  D3
1688:  MOVWF  FF6
168A:  MOVLW  00
168C:  MOVWF  FF7
168E:  MOVLW  06
1690:  MOVWF  50
1692:  RCALL  0F4C
....................                 lcd_gotoxy(1,2); 
1694:  MOVLW  01
1696:  MOVWF  5F
1698:  MOVLW  02
169A:  MOVWF  x60
169C:  CALL   0288
....................                 printf (LCD_PUTC, "T=\%f  I=\%f     ",tension_RMS,corriente_RMS); 
16A0:  MOVLW  54
16A2:  MOVWF  5E
16A4:  CALL   02DE
16A8:  MOVLW  3D
16AA:  MOVWF  5E
16AC:  CALL   02DE
16B0:  MOVLW  89
16B2:  MOVWF  FE9
16B4:  MOVFF  3E,53
16B8:  MOVFF  3D,52
16BC:  MOVFF  3C,51
16C0:  MOVFF  3B,50
16C4:  MOVLW  02
16C6:  MOVWF  54
16C8:  RCALL  103A
16CA:  MOVLW  DE
16CC:  MOVWF  FF6
16CE:  MOVLW  00
16D0:  MOVWF  FF7
16D2:  MOVLW  04
16D4:  MOVWF  50
16D6:  RCALL  0F4C
16D8:  MOVLW  89
16DA:  MOVWF  FE9
16DC:  MOVFF  42,53
16E0:  MOVFF  41,52
16E4:  MOVFF  40,51
16E8:  MOVFF  3F,50
16EC:  MOVLW  02
16EE:  MOVWF  54
16F0:  RCALL  103A
16F2:  MOVLW  E4
16F4:  MOVWF  FF6
16F6:  MOVLW  00
16F8:  MOVWF  FF7
16FA:  MOVLW  05
16FC:  MOVWF  50
16FE:  RCALL  0F4C
....................                 delay_ms(1000); 
1700:  MOVLW  04
1702:  MOVWF  50
1704:  MOVLW  FA
1706:  MOVWF  5F
1708:  CALL   00EA
170C:  DECFSZ 50,F
170E:  BRA    1704
....................                 enable_interrupts(INT_RTCC); 
1710:  BSF    FF2.5
....................                 enable_interrupts(GLOBAL); 
1712:  MOVLW  C0
1714:  IORWF  FF2,F
....................                 pulso_timer=0; 
1716:  CLRF   25
....................                 set_timer0(carga);    
1718:  MOVLW  E8
171A:  MOVWF  FD7
171C:  MOVLW  AB
171E:  MOVWF  FD6
.................... 				//reinicia todo 
....................                 corriente_RMS=0; 
1720:  CLRF   42
1722:  CLRF   41
1724:  CLRF   40
1726:  CLRF   3F
....................                 tension_RMS=0; 
1728:  CLRF   3E
172A:  CLRF   3D
172C:  CLRF   3C
172E:  CLRF   3B
....................                  
.................... 				estado = PUNTO_TENS_CORR; 
1730:  CLRF   4F
.................... 		 
....................  
.................... 				break; 
1732:  BRA    1736
.................... 			 
.................... 			default: estado = PUNTO_TENS_CORR; 
1734:  CLRF   4F
.................... 		} 
1736:  GOTO   1778 (RETURN)
....................  
....................  
.................... } 
....................  
.................... //Funciones asociadas a los eventos 
....................  
.................... /** 
.................... *	\fn int -(void) 
.................... *	\brief Resumen 
.................... *	\details Detalles 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 4C07   PLL12 CPUDIV1 NOUSBDIV HS FCMEN NOIESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
