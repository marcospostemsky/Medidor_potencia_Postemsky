CCS PCH C Compiler, Version 5.048, 5967               30-oct-16 20:55

               Filename:   C:\Users\MARCOS\Proyecto_final\Med_pot.X\dist\default\production\Med_pot.X.production.lst

               ROM used:   5876 bytes (18%)
                           Largest free fragment is 26888
               RAM used:   79 (4%) at main() level
                           145 (7%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   16B6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   00BC
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #import(file="build/default/production/main.o") 
.................... #import(file="build/default/production/funciones.o") 
.................... /** 
.................... *	\file main.c 
.................... *	\brief Resumen del contenido del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  DATA 50,72
00B0:  DATA 69,6D
00B2:  DATA 65,72
00B4:  DATA 20,70
00B6:  DATA 72,75
00B8:  DATA 65,62
00BA:  DATA 61,00
*
0360:  TBLRD*+
0362:  MOVF   FF5,F
0364:  BZ    037E
0366:  MOVFF  FF6,4F
036A:  MOVFF  FF7,50
036E:  MOVFF  FF5,5D
0372:  RCALL  02F2
0374:  MOVFF  4F,FF6
0378:  MOVFF  50,FF7
037C:  BRA    0360
037E:  GOTO   03B6 (RETURN)
*
04F0:  MOVLW  8E
04F2:  MOVWF  00
04F4:  MOVFF  82,01
04F8:  MOVFF  81,02
04FC:  CLRF   03
04FE:  MOVF   01,F
0500:  BNZ   0514
0502:  MOVFF  02,01
0506:  CLRF   02
0508:  MOVLW  08
050A:  SUBWF  00,F
050C:  MOVF   01,F
050E:  BNZ   0514
0510:  CLRF   00
0512:  BRA    0524
0514:  BCF    FD8.0
0516:  BTFSC  01.7
0518:  BRA    0522
051A:  RLCF   02,F
051C:  RLCF   01,F
051E:  DECF   00,F
0520:  BRA    0514
0522:  BCF    01.7
0524:  RETURN 0
0526:  MOVF   x61,W
0528:  BTFSC  FD8.2
052A:  BRA    0676
052C:  MOVWF  x6D
052E:  MOVF   x65,W
0530:  BTFSC  FD8.2
0532:  BRA    0676
0534:  SUBWF  x6D,F
0536:  BNC   0542
0538:  MOVLW  7F
053A:  ADDWF  x6D,F
053C:  BTFSC  FD8.0
053E:  BRA    0676
0540:  BRA    054E
0542:  MOVLW  81
0544:  SUBWF  x6D,F
0546:  BTFSS  FD8.0
0548:  BRA    0676
054A:  BTFSC  FD8.2
054C:  BRA    0676
054E:  MOVFF  6D,00
0552:  CLRF   01
0554:  CLRF   02
0556:  CLRF   03
0558:  CLRF   x6C
055A:  MOVFF  62,6B
055E:  BSF    x6B.7
0560:  MOVFF  63,6A
0564:  MOVFF  64,69
0568:  MOVLW  19
056A:  MOVWF  x6D
056C:  MOVF   x68,W
056E:  SUBWF  x69,F
0570:  BC    058C
0572:  MOVLW  01
0574:  SUBWF  x6A,F
0576:  BC    058C
0578:  SUBWF  x6B,F
057A:  BC    058C
057C:  SUBWF  x6C,F
057E:  BC    058C
0580:  INCF   x6C,F
0582:  INCF   x6B,F
0584:  INCF   x6A,F
0586:  MOVF   x68,W
0588:  ADDWF  x69,F
058A:  BRA    05DC
058C:  MOVF   x67,W
058E:  SUBWF  x6A,F
0590:  BC    05B6
0592:  MOVLW  01
0594:  SUBWF  x6B,F
0596:  BC    05B6
0598:  SUBWF  x6C,F
059A:  BC    05B6
059C:  INCF   x6C,F
059E:  INCF   x6B,F
05A0:  MOVF   x67,W
05A2:  ADDWF  x6A,F
05A4:  MOVF   x68,W
05A6:  ADDWF  x69,F
05A8:  BNC   05DC
05AA:  INCF   x6A,F
05AC:  BNZ   05DC
05AE:  INCF   x6B,F
05B0:  BNZ   05DC
05B2:  INCF   x6C,F
05B4:  BRA    05DC
05B6:  MOVF   x66,W
05B8:  IORLW  80
05BA:  SUBWF  x6B,F
05BC:  BC    05DA
05BE:  MOVLW  01
05C0:  SUBWF  x6C,F
05C2:  BC    05DA
05C4:  INCF   x6C,F
05C6:  MOVF   x66,W
05C8:  IORLW  80
05CA:  ADDWF  x6B,F
05CC:  MOVF   x67,W
05CE:  ADDWF  x6A,F
05D0:  BNC   05A4
05D2:  INCF   x6B,F
05D4:  BNZ   05A4
05D6:  INCF   x6C,F
05D8:  BRA    05A4
05DA:  BSF    03.0
05DC:  DECFSZ x6D,F
05DE:  BRA    05E2
05E0:  BRA    05F8
05E2:  BCF    FD8.0
05E4:  RLCF   x69,F
05E6:  RLCF   x6A,F
05E8:  RLCF   x6B,F
05EA:  RLCF   x6C,F
05EC:  BCF    FD8.0
05EE:  RLCF   03,F
05F0:  RLCF   02,F
05F2:  RLCF   01,F
05F4:  RLCF   x6E,F
05F6:  BRA    056C
05F8:  BTFSS  x6E.0
05FA:  BRA    0608
05FC:  BCF    FD8.0
05FE:  RRCF   01,F
0600:  RRCF   02,F
0602:  RRCF   03,F
0604:  RRCF   x6E,F
0606:  BRA    060C
0608:  DECF   00,F
060A:  BZ    0676
060C:  BTFSC  x6E.7
060E:  BRA    064C
0610:  BCF    FD8.0
0612:  RLCF   x69,F
0614:  RLCF   x6A,F
0616:  RLCF   x6B,F
0618:  RLCF   x6C,F
061A:  MOVF   x68,W
061C:  SUBWF  x69,F
061E:  BC    062E
0620:  MOVLW  01
0622:  SUBWF  x6A,F
0624:  BC    062E
0626:  SUBWF  x6B,F
0628:  BC    062E
062A:  SUBWF  x6C,F
062C:  BNC   0662
062E:  MOVF   x67,W
0630:  SUBWF  x6A,F
0632:  BC    063E
0634:  MOVLW  01
0636:  SUBWF  x6B,F
0638:  BC    063E
063A:  SUBWF  x6C,F
063C:  BNC   0662
063E:  MOVF   x66,W
0640:  IORLW  80
0642:  SUBWF  x6B,F
0644:  BC    064C
0646:  MOVLW  01
0648:  SUBWF  x6C,F
064A:  BNC   0662
064C:  INCF   03,F
064E:  BNZ   0662
0650:  INCF   02,F
0652:  BNZ   0662
0654:  INCF   01,F
0656:  BNZ   0662
0658:  INCF   00,F
065A:  BZ    0676
065C:  RRCF   01,F
065E:  RRCF   02,F
0660:  RRCF   03,F
0662:  MOVFF  62,6D
0666:  MOVF   x66,W
0668:  XORWF  x6D,F
066A:  BTFSS  x6D.7
066C:  BRA    0672
066E:  BSF    01.7
0670:  BRA    067E
0672:  BCF    01.7
0674:  BRA    067E
0676:  CLRF   00
0678:  CLRF   01
067A:  CLRF   02
067C:  CLRF   03
067E:  RETURN 0
0680:  MOVLW  80
0682:  BTFSC  FD8.1
0684:  XORWF  x86,F
0686:  CLRF   x8B
0688:  CLRF   x8C
068A:  MOVFF  82,8A
068E:  MOVF   x86,W
0690:  XORWF  x8A,F
0692:  MOVF   x81,W
0694:  BTFSC  FD8.2
0696:  BRA    0850
0698:  MOVWF  x89
069A:  MOVWF  00
069C:  MOVF   x85,W
069E:  BTFSC  FD8.2
06A0:  BRA    0862
06A2:  SUBWF  x89,F
06A4:  BTFSC  FD8.2
06A6:  BRA    07AA
06A8:  BNC   0724
06AA:  MOVFF  86,8F
06AE:  BSF    x8F.7
06B0:  MOVFF  87,8E
06B4:  MOVFF  88,8D
06B8:  CLRF   x8C
06BA:  BCF    FD8.0
06BC:  RRCF   x8F,F
06BE:  RRCF   x8E,F
06C0:  RRCF   x8D,F
06C2:  RRCF   x8C,F
06C4:  DECFSZ x89,F
06C6:  BRA    06B8
06C8:  BTFSS  x8A.7
06CA:  BRA    06D2
06CC:  BSF    x8B.0
06CE:  BRA    088A
06D0:  BCF    x8B.0
06D2:  BCF    x89.0
06D4:  BSF    x8B.4
06D6:  CLRF   FEA
06D8:  MOVLW  84
06DA:  MOVWF  FE9
06DC:  BRA    08B0
06DE:  BCF    x8B.4
06E0:  BTFSC  x8A.7
06E2:  BRA    06F8
06E4:  BTFSS  x89.0
06E6:  BRA    070E
06E8:  RRCF   x8F,F
06EA:  RRCF   x8E,F
06EC:  RRCF   x8D,F
06EE:  RRCF   x8C,F
06F0:  INCF   00,F
06F2:  BTFSC  FD8.2
06F4:  BRA    0880
06F6:  BRA    070E
06F8:  BTFSC  x8F.7
06FA:  BRA    0714
06FC:  BCF    FD8.0
06FE:  RLCF   x8C,F
0700:  RLCF   x8D,F
0702:  RLCF   x8E,F
0704:  RLCF   x8F,F
0706:  DECF   00,F
0708:  BTFSC  FD8.2
070A:  BRA    0880
070C:  BRA    06F8
070E:  BSF    x8B.6
0710:  BRA    07E8
0712:  BCF    x8B.6
0714:  MOVFF  82,8A
0718:  BTFSS  x82.7
071A:  BRA    0720
071C:  BSF    x8F.7
071E:  BRA    0872
0720:  BCF    x8F.7
0722:  BRA    0872
0724:  MOVFF  85,89
0728:  MOVFF  85,00
072C:  MOVF   x81,W
072E:  SUBWF  x89,F
0730:  MOVFF  82,8F
0734:  BSF    x8F.7
0736:  MOVFF  83,8E
073A:  MOVFF  84,8D
073E:  CLRF   x8C
0740:  BCF    FD8.0
0742:  RRCF   x8F,F
0744:  RRCF   x8E,F
0746:  RRCF   x8D,F
0748:  RRCF   x8C,F
074A:  DECFSZ x89,F
074C:  BRA    073E
074E:  BTFSS  x8A.7
0750:  BRA    0758
0752:  BSF    x8B.1
0754:  BRA    088A
0756:  BCF    x8B.1
0758:  BCF    x89.0
075A:  BSF    x8B.5
075C:  CLRF   FEA
075E:  MOVLW  88
0760:  MOVWF  FE9
0762:  BRA    08B0
0764:  BCF    x8B.5
0766:  BTFSC  x8A.7
0768:  BRA    077E
076A:  BTFSS  x89.0
076C:  BRA    0794
076E:  RRCF   x8F,F
0770:  RRCF   x8E,F
0772:  RRCF   x8D,F
0774:  RRCF   x8C,F
0776:  INCF   00,F
0778:  BTFSC  FD8.2
077A:  BRA    0880
077C:  BRA    0794
077E:  BTFSC  x8F.7
0780:  BRA    079A
0782:  BCF    FD8.0
0784:  RLCF   x8C,F
0786:  RLCF   x8D,F
0788:  RLCF   x8E,F
078A:  RLCF   x8F,F
078C:  DECF   00,F
078E:  BTFSC  FD8.2
0790:  BRA    0880
0792:  BRA    077E
0794:  BSF    x8B.7
0796:  BRA    07E8
0798:  BCF    x8B.7
079A:  MOVFF  86,8A
079E:  BTFSS  x86.7
07A0:  BRA    07A6
07A2:  BSF    x8F.7
07A4:  BRA    0872
07A6:  BCF    x8F.7
07A8:  BRA    0872
07AA:  MOVFF  86,8F
07AE:  BSF    x8F.7
07B0:  MOVFF  87,8E
07B4:  MOVFF  88,8D
07B8:  BTFSS  x8A.7
07BA:  BRA    07C4
07BC:  BCF    x8F.7
07BE:  BSF    x8B.2
07C0:  BRA    088A
07C2:  BCF    x8B.2
07C4:  CLRF   x8C
07C6:  BCF    x89.0
07C8:  CLRF   FEA
07CA:  MOVLW  84
07CC:  MOVWF  FE9
07CE:  BRA    08B0
07D0:  BTFSC  x8A.7
07D2:  BRA    080C
07D4:  MOVFF  82,8A
07D8:  BTFSS  x89.0
07DA:  BRA    07E8
07DC:  RRCF   x8F,F
07DE:  RRCF   x8E,F
07E0:  RRCF   x8D,F
07E2:  RRCF   x8C,F
07E4:  INCF   00,F
07E6:  BZ    0880
07E8:  BTFSS  x8C.7
07EA:  BRA    0802
07EC:  INCF   x8D,F
07EE:  BNZ   0802
07F0:  INCF   x8E,F
07F2:  BNZ   0802
07F4:  INCF   x8F,F
07F6:  BNZ   0802
07F8:  RRCF   x8F,F
07FA:  RRCF   x8E,F
07FC:  RRCF   x8D,F
07FE:  INCF   00,F
0800:  BZ    0880
0802:  BTFSC  x8B.6
0804:  BRA    0712
0806:  BTFSC  x8B.7
0808:  BRA    0798
080A:  BRA    0844
080C:  MOVLW  80
080E:  XORWF  x8F,F
0810:  BTFSS  x8F.7
0812:  BRA    081C
0814:  BRA    088A
0816:  MOVFF  86,8A
081A:  BRA    0830
081C:  MOVFF  82,8A
0820:  MOVF   x8F,F
0822:  BNZ   0830
0824:  MOVF   x8E,F
0826:  BNZ   0830
0828:  MOVF   x8D,F
082A:  BNZ   0830
082C:  CLRF   00
082E:  BRA    0872
0830:  BTFSC  x8F.7
0832:  BRA    0844
0834:  BCF    FD8.0
0836:  RLCF   x8C,F
0838:  RLCF   x8D,F
083A:  RLCF   x8E,F
083C:  RLCF   x8F,F
083E:  DECFSZ 00,F
0840:  BRA    0830
0842:  BRA    0880
0844:  BTFSS  x8A.7
0846:  BRA    084C
0848:  BSF    x8F.7
084A:  BRA    0872
084C:  BCF    x8F.7
084E:  BRA    0872
0850:  MOVFF  85,00
0854:  MOVFF  86,8F
0858:  MOVFF  87,8E
085C:  MOVFF  88,8D
0860:  BRA    0872
0862:  MOVFF  81,00
0866:  MOVFF  82,8F
086A:  MOVFF  83,8E
086E:  MOVFF  84,8D
0872:  MOVFF  8F,01
0876:  MOVFF  8E,02
087A:  MOVFF  8D,03
087E:  BRA    08E8
0880:  CLRF   00
0882:  CLRF   01
0884:  CLRF   02
0886:  CLRF   03
0888:  BRA    08E8
088A:  CLRF   x8C
088C:  COMF   x8D,F
088E:  COMF   x8E,F
0890:  COMF   x8F,F
0892:  COMF   x8C,F
0894:  INCF   x8C,F
0896:  BNZ   08A2
0898:  INCF   x8D,F
089A:  BNZ   08A2
089C:  INCF   x8E,F
089E:  BNZ   08A2
08A0:  INCF   x8F,F
08A2:  BTFSC  x8B.0
08A4:  BRA    06D0
08A6:  BTFSC  x8B.1
08A8:  BRA    0756
08AA:  BTFSC  x8B.2
08AC:  BRA    07C2
08AE:  BRA    0816
08B0:  MOVF   FEF,W
08B2:  ADDWF  x8D,F
08B4:  BNC   08C0
08B6:  INCF   x8E,F
08B8:  BNZ   08C0
08BA:  INCF   x8F,F
08BC:  BTFSC  FD8.2
08BE:  BSF    x89.0
08C0:  MOVF   FED,F
08C2:  MOVF   FEF,W
08C4:  ADDWF  x8E,F
08C6:  BNC   08CE
08C8:  INCF   x8F,F
08CA:  BTFSC  FD8.2
08CC:  BSF    x89.0
08CE:  MOVF   FED,F
08D0:  MOVF   FEF,W
08D2:  BTFSC  FEF.7
08D4:  BRA    08D8
08D6:  XORLW  80
08D8:  ADDWF  x8F,F
08DA:  BTFSC  FD8.0
08DC:  BSF    x89.0
08DE:  BTFSC  x8B.4
08E0:  BRA    06DE
08E2:  BTFSC  x8B.5
08E4:  BRA    0764
08E6:  BRA    07D0
08E8:  RETURN 0
08EA:  MOVF   x81,W
08EC:  BTFSC  FD8.2
08EE:  BRA    09D2
08F0:  MOVWF  00
08F2:  MOVF   x85,W
08F4:  BTFSC  FD8.2
08F6:  BRA    09D2
08F8:  ADDWF  00,F
08FA:  BNC   0904
08FC:  MOVLW  81
08FE:  ADDWF  00,F
0900:  BC    09D2
0902:  BRA    090C
0904:  MOVLW  7F
0906:  SUBWF  00,F
0908:  BNC   09D2
090A:  BZ    09D2
090C:  MOVFF  82,89
0910:  MOVF   x86,W
0912:  XORWF  x89,F
0914:  BSF    x82.7
0916:  BSF    x86.7
0918:  MOVF   x84,W
091A:  MULWF  x88
091C:  MOVFF  FF4,8B
0920:  MOVF   x83,W
0922:  MULWF  x87
0924:  MOVFF  FF4,03
0928:  MOVFF  FF3,8A
092C:  MULWF  x88
092E:  MOVF   FF3,W
0930:  ADDWF  x8B,F
0932:  MOVF   FF4,W
0934:  ADDWFC x8A,F
0936:  MOVLW  00
0938:  ADDWFC 03,F
093A:  MOVF   x84,W
093C:  MULWF  x87
093E:  MOVF   FF3,W
0940:  ADDWF  x8B,F
0942:  MOVF   FF4,W
0944:  ADDWFC x8A,F
0946:  MOVLW  00
0948:  CLRF   02
094A:  ADDWFC 03,F
094C:  ADDWFC 02,F
094E:  MOVF   x82,W
0950:  MULWF  x88
0952:  MOVF   FF3,W
0954:  ADDWF  x8A,F
0956:  MOVF   FF4,W
0958:  ADDWFC 03,F
095A:  MOVLW  00
095C:  ADDWFC 02,F
095E:  MOVF   x82,W
0960:  MULWF  x87
0962:  MOVF   FF3,W
0964:  ADDWF  03,F
0966:  MOVF   FF4,W
0968:  ADDWFC 02,F
096A:  MOVLW  00
096C:  CLRF   01
096E:  ADDWFC 01,F
0970:  MOVF   x84,W
0972:  MULWF  x86
0974:  MOVF   FF3,W
0976:  ADDWF  x8A,F
0978:  MOVF   FF4,W
097A:  ADDWFC 03,F
097C:  MOVLW  00
097E:  ADDWFC 02,F
0980:  ADDWFC 01,F
0982:  MOVF   x83,W
0984:  MULWF  x86
0986:  MOVF   FF3,W
0988:  ADDWF  03,F
098A:  MOVF   FF4,W
098C:  ADDWFC 02,F
098E:  MOVLW  00
0990:  ADDWFC 01,F
0992:  MOVF   x82,W
0994:  MULWF  x86
0996:  MOVF   FF3,W
0998:  ADDWF  02,F
099A:  MOVF   FF4,W
099C:  ADDWFC 01,F
099E:  INCF   00,F
09A0:  BTFSC  01.7
09A2:  BRA    09AE
09A4:  RLCF   x8A,F
09A6:  RLCF   03,F
09A8:  RLCF   02,F
09AA:  RLCF   01,F
09AC:  DECF   00,F
09AE:  MOVLW  00
09B0:  BTFSS  x8A.7
09B2:  BRA    09C8
09B4:  INCF   03,F
09B6:  ADDWFC 02,F
09B8:  ADDWFC 01,F
09BA:  MOVF   01,W
09BC:  BNZ   09C8
09BE:  MOVF   02,W
09C0:  BNZ   09C8
09C2:  MOVF   03,W
09C4:  BNZ   09C8
09C6:  INCF   00,F
09C8:  BTFSC  x89.7
09CA:  BSF    01.7
09CC:  BTFSS  x89.7
09CE:  BCF    01.7
09D0:  BRA    09DA
09D2:  CLRF   00
09D4:  CLRF   01
09D6:  CLRF   02
09D8:  CLRF   03
09DA:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=12 Mhz, crystal= 12 MHz)   // Selecciona la velocidad del oscilador interno 
*
00FE:  CLRF   FEA
0100:  MOVLW  5E
0102:  MOVWF  FE9
0104:  MOVF   FEF,W
0106:  BZ    0124
0108:  MOVLW  03
010A:  MOVWF  01
010C:  CLRF   00
010E:  DECFSZ 00,F
0110:  BRA    010E
0112:  DECFSZ 01,F
0114:  BRA    010C
0116:  MOVLW  E3
0118:  MOVWF  00
011A:  DECFSZ 00,F
011C:  BRA    011A
011E:  NOP   
0120:  DECFSZ FEF,F
0122:  BRA    0108
0124:  RETURN 0
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
0126:  MOVLW  08
0128:  MOVWF  01
012A:  MOVLW  02
012C:  MOVWF  00
012E:  DECFSZ 00,F
0130:  BRA    012E
0132:  BCF    F8C.7
0134:  BCF    F95.7
0136:  MOVLW  02
0138:  MOVWF  00
013A:  DECFSZ 00,F
013C:  BRA    013A
013E:  RLCF   x62,F
0140:  BCF    F8C.6
0142:  BTFSC  FD8.0
0144:  BSF    F95.6
0146:  BTFSS  FD8.0
0148:  BCF    F95.6
014A:  BSF    F95.7
014C:  BTFSS  F83.7
014E:  BRA    014C
0150:  DECFSZ 01,F
0152:  BRA    012A
0154:  MOVLW  02
0156:  MOVWF  00
0158:  DECFSZ 00,F
015A:  BRA    0158
015C:  BCF    F8C.7
015E:  BCF    F95.7
0160:  NOP   
0162:  BSF    F95.6
0164:  MOVLW  02
0166:  MOVWF  00
0168:  DECFSZ 00,F
016A:  BRA    0168
016C:  MOVLW  02
016E:  MOVWF  00
0170:  DECFSZ 00,F
0172:  BRA    0170
0174:  BSF    F95.7
0176:  BTFSS  F83.7
0178:  BRA    0176
017A:  CLRF   01
017C:  MOVLW  02
017E:  MOVWF  00
0180:  DECFSZ 00,F
0182:  BRA    0180
0184:  BTFSC  F83.6
0186:  BSF    01.0
0188:  BCF    F8C.7
018A:  BCF    F95.7
018C:  BCF    F8C.6
018E:  BCF    F95.6
0190:  RETURN 0
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
*
16D8:  CLRF   26
16DA:  MOVF   FC1,W
16DC:  ANDLW  C0
16DE:  IORLW  0F
16E0:  MOVWF  FC1
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
*
16C6:  CLRF   19
16C8:  CLRF   1A
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
....................         delay_us(20); 
....................         i2c_write(LCD_ADDR); //the slave addresse 
....................         delay_us(20); 
....................         i2c_write(data); 
....................         delay_us(20); 
....................         i2c_stop(); 
....................         delay_us(20); 
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
....................         i2c_send_nibble(data); 
....................         data=data-4;       //toggle EN back to 0 
....................         i2c_send_nibble(data); 
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
....................     lcd_send_byte(0x10); 
....................     delay_ms(2); 
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x30); 
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x20); 
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
....................         lcd_send_byte(0x80); 
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0xC0); 
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x60); 
....................            //clears the display 
....................         lcd_clear(); 
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
16CA:  CLRF   21
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
....................       case 2:  address= lcd_line_two;     break; 
....................       case 3:  address= lcd_line_three;   break; 
....................       case 4:  address= lcd_line_four;    break; 
....................       default: address= lcd_line_one;     break;  
....................    } 
....................   
....................    address+=x-1; 
....................    data=address&0xF0; 
....................    lcd_send_byte(data); 
....................    data=address&0x0F; 
....................    data=data<<4; 
....................    lcd_send_byte(data); 
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
....................      case '\1': lcd_gotoxy(1,1);  break; 
....................      case '\2': lcd_gotoxy(1,2);  break; 
....................      case '\3': lcd_gotoxy(1,3);  break; 
....................      case '\4': lcd_gotoxy(1,4);  break; 
....................  
....................      default: 
....................         data=in_data&0xF0; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................         data=in_data&0x0F; 
....................         data=data<<4; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................      break; 
....................    } 
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
....................  
.................... const long carga= 0xF485; 
.................... extern int contador; 
.................... extern long pulso_timer; 
....................  
.................... void inicializar(); 
....................  
.................... void main() 
*
16B6:  CLRF   FF8
16B8:  BCF    FD0.7
16BA:  BSF    07.7
16BC:  BSF    20.0
16BE:  CLRF   24
16C0:  CLRF   23
16C2:  BSF    20.0
16C4:  BSF    20.0
*
16CC:  CLRF   22
16CE:  CLRF   25
16D0:  BSF    20.0
16D2:  CLRF   4E
16D4:  CLRF   24
16D6:  CLRF   23
*
16E2:  MOVLW  07
16E4:  MOVWF  FB4
.................... { 
....................  
.................... //declaracion de variables 
.................... //inicializacion de perifericos 
....................  
.................... 	inicializar() ; 
16E6:  GOTO   0382
....................      
....................     set_timer0(carga); 
16EA:  MOVLW  F4
16EC:  MOVWF  FD7
16EE:  MOVLW  85
16F0:  MOVWF  FD6
.................... 	while(1) 
.................... 	{ 
....................  
.................... 		maquina_estado(); 
16F2:  BRA    1166
16F4:  BRA    16F2
....................  
.................... 	} 
.................... } 
....................  
16F6:  SLEEP 
.................... void Inicializar(){ 
....................  
....................     setup_adc_ports(AN0);                                   //Canal 0 analógico 
*
0382:  MOVF   FC1,W
0384:  ANDLW  C0
0386:  IORLW  0E
0388:  MOVWF  FC1
....................     setup_adc(ADC_CLOCK_DIV_16);    
038A:  MOVF   FC0,W
038C:  ANDLW  C0
038E:  IORLW  05
0390:  MOVWF  FC0
0392:  BCF    FC0.7
0394:  BSF    FC2.0
....................     setup_timer_0( RTCC_INTERNAL | T0_DIV_2); 
0396:  MOVLW  80
0398:  MOVWF  FD5
....................     set_tris_a(0xF9); 
039A:  MOVLW  F9
039C:  MOVWF  F92
....................     contador=1; 
039E:  MOVLW  01
03A0:  MOVWF  22
....................     lcd_init(); 
03A2:  BRA    0240
....................     lcd_gotoxy(1,1); 
03A4:  MOVLW  01
03A6:  MOVWF  5E
03A8:  MOVWF  5F
03AA:  RCALL  029C
....................     printf(LCD_PUTC,"Primer prueba"); 
03AC:  MOVLW  AE
03AE:  MOVWF  FF6
03B0:  MOVLW  00
03B2:  MOVWF  FF7
03B4:  BRA    0360
....................     lcd_backlight=ON; 
03B6:  BSF    20.0
....................     enable_interrupts (INT_RTCC); 
03B8:  BSF    FF2.5
....................     enable_interrupts (GLOBAL); 
03BA:  MOVLW  C0
03BC:  IORWF  FF2,F
....................     output_high (PIN_A0); //pone en alto el chipselect del AD7450 
03BE:  BSF    F89.0
....................     output_high (PIN_A1); // pone en alto el chipselect del MAX186 
03C0:  BSF    F89.1
03C2:  GOTO   16EA (RETURN)
.................... } 
....................  
....................  
.................... /** 
.................... *	\file funciones.c 
.................... *	\brief  
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
00CC:  DATA 53,65
00CE:  DATA 20,6D
00D0:  DATA 69,64
00D2:  DATA 69,6F
00D4:  DATA 20,64
00D6:  DATA 65,73
00D8:  DATA 66,61
00DA:  DATA 73,65
00DC:  DATA 00,00
00DE:  DATA 50,6F
00E0:  DATA 74,65
00E2:  DATA 6E,63
00E4:  DATA 69,61
00E6:  DATA 3D,20
00E8:  DATA 25,66
00EA:  DATA 20,57
00EC:  DATA 00,00
00EE:  DATA 54,3D
00F0:  DATA 25,66
00F2:  DATA 20,56
00F4:  DATA 20,20
00F6:  DATA 49,3D
00F8:  DATA 25,66
00FA:  DATA 20,41
00FC:  DATA 00,00
*
09DC:  MOVFF  7E,85
09E0:  MOVF   x82,W
09E2:  XORWF  x85,F
09E4:  BTFSS  x85.7
09E6:  BRA    09F2
09E8:  BCF    FD8.2
09EA:  BCF    FD8.0
09EC:  BTFSC  x7E.7
09EE:  BSF    FD8.0
09F0:  BRA    0A50
09F2:  MOVFF  7E,85
09F6:  MOVFF  81,86
09FA:  MOVF   x7D,W
09FC:  SUBWF  x86,F
09FE:  BZ    0A0C
0A00:  BTFSS  x85.7
0A02:  BRA    0A50
0A04:  MOVF   FD8,W
0A06:  XORLW  01
0A08:  MOVWF  FD8
0A0A:  BRA    0A50
0A0C:  MOVFF  82,86
0A10:  MOVF   x7E,W
0A12:  SUBWF  x86,F
0A14:  BZ    0A22
0A16:  BTFSS  x85.7
0A18:  BRA    0A50
0A1A:  MOVF   FD8,W
0A1C:  XORLW  01
0A1E:  MOVWF  FD8
0A20:  BRA    0A50
0A22:  MOVFF  83,86
0A26:  MOVF   x7F,W
0A28:  SUBWF  x86,F
0A2A:  BZ    0A38
0A2C:  BTFSS  x85.7
0A2E:  BRA    0A50
0A30:  MOVF   FD8,W
0A32:  XORLW  01
0A34:  MOVWF  FD8
0A36:  BRA    0A50
0A38:  MOVFF  84,86
0A3C:  MOVF   x80,W
0A3E:  SUBWF  x86,F
0A40:  BZ    0A4E
0A42:  BTFSS  x85.7
0A44:  BRA    0A50
0A46:  MOVF   FD8,W
0A48:  XORLW  01
0A4A:  MOVWF  FD8
0A4C:  BRA    0A50
0A4E:  BCF    FD8.0
0A50:  RETURN 0
*
0B5C:  TBLRD*+
0B5E:  MOVF   FF5,F
0B60:  BZ    0B7C
0B62:  MOVFF  FF6,4F
0B66:  MOVFF  FF7,50
0B6A:  MOVFF  FF5,5D
0B6E:  CALL   02F2
0B72:  MOVFF  4F,FF6
0B76:  MOVFF  50,FF7
0B7A:  BRA    0B5C
0B7C:  GOTO   1542 (RETURN)
0B80:  MOVLW  8E
0B82:  MOVWF  00
0B84:  MOVF   x7D,W
0B86:  SUBWF  00,F
0B88:  MOVFF  7E,02
0B8C:  MOVFF  7F,01
0B90:  BSF    02.7
0B92:  MOVF   00,F
0B94:  BZ    0BA8
0B96:  BCF    FD8.0
0B98:  MOVF   02,F
0B9A:  BNZ   0BA0
0B9C:  MOVF   01,F
0B9E:  BZ    0BA8
0BA0:  RRCF   02,F
0BA2:  RRCF   01,F
0BA4:  DECFSZ 00,F
0BA6:  BRA    0B96
0BA8:  BTFSS  x7E.7
0BAA:  BRA    0BB6
0BAC:  COMF   01,F
0BAE:  COMF   02,F
0BB0:  INCF   01,F
0BB2:  BTFSC  FD8.2
0BB4:  INCF   02,F
0BB6:  GOTO   0C66 (RETURN)
*
0EF8:  TBLRD*+
0EFA:  MOVFF  FF6,50
0EFE:  MOVFF  FF7,51
0F02:  MOVFF  FF5,5D
0F06:  CALL   02F2
0F0A:  MOVFF  50,FF6
0F0E:  MOVFF  51,FF7
0F12:  DECFSZ 4F,F
0F14:  BRA    0EF8
0F16:  RETURN 0
0F18:  MOVF   5C,W
0F1A:  SUBLW  B6
0F1C:  MOVWF  5C
0F1E:  CLRF   03
0F20:  MOVFF  5D,60
0F24:  BSF    5D.7
0F26:  BCF    FD8.0
0F28:  RRCF   5D,F
0F2A:  RRCF   5E,F
0F2C:  RRCF   5F,F
0F2E:  RRCF   03,F
0F30:  RRCF   02,F
0F32:  RRCF   01,F
0F34:  RRCF   00,F
0F36:  DECFSZ 5C,F
0F38:  BRA    0F26
0F3A:  BTFSS  x60.7
0F3C:  BRA    0F54
0F3E:  COMF   00,F
0F40:  COMF   01,F
0F42:  COMF   02,F
0F44:  COMF   03,F
0F46:  INCF   00,F
0F48:  BTFSC  FD8.2
0F4A:  INCF   01,F
0F4C:  BTFSC  FD8.2
0F4E:  INCF   02,F
0F50:  BTFSC  FD8.2
0F52:  INCF   03,F
0F54:  GOTO   1034 (RETURN)
0F58:  BTFSC  FD8.1
0F5A:  BRA    0F62
0F5C:  CLRF   FEA
0F5E:  MOVLW  64
0F60:  MOVWF  FE9
0F62:  CLRF   00
0F64:  CLRF   01
0F66:  CLRF   02
0F68:  CLRF   03
0F6A:  CLRF   x64
0F6C:  CLRF   x65
0F6E:  CLRF   x66
0F70:  CLRF   x67
0F72:  MOVF   x63,W
0F74:  IORWF  x62,W
0F76:  IORWF  x61,W
0F78:  IORWF  x60,W
0F7A:  BZ    0FD4
0F7C:  MOVLW  20
0F7E:  MOVWF  x68
0F80:  BCF    FD8.0
0F82:  RLCF   5C,F
0F84:  RLCF   5D,F
0F86:  RLCF   5E,F
0F88:  RLCF   5F,F
0F8A:  RLCF   x64,F
0F8C:  RLCF   x65,F
0F8E:  RLCF   x66,F
0F90:  RLCF   x67,F
0F92:  MOVF   x63,W
0F94:  SUBWF  x67,W
0F96:  BNZ   0FA8
0F98:  MOVF   x62,W
0F9A:  SUBWF  x66,W
0F9C:  BNZ   0FA8
0F9E:  MOVF   x61,W
0FA0:  SUBWF  x65,W
0FA2:  BNZ   0FA8
0FA4:  MOVF   x60,W
0FA6:  SUBWF  x64,W
0FA8:  BNC   0FC8
0FAA:  MOVF   x60,W
0FAC:  SUBWF  x64,F
0FAE:  MOVF   x61,W
0FB0:  BTFSS  FD8.0
0FB2:  INCFSZ x61,W
0FB4:  SUBWF  x65,F
0FB6:  MOVF   x62,W
0FB8:  BTFSS  FD8.0
0FBA:  INCFSZ x62,W
0FBC:  SUBWF  x66,F
0FBE:  MOVF   x63,W
0FC0:  BTFSS  FD8.0
0FC2:  INCFSZ x63,W
0FC4:  SUBWF  x67,F
0FC6:  BSF    FD8.0
0FC8:  RLCF   00,F
0FCA:  RLCF   01,F
0FCC:  RLCF   02,F
0FCE:  RLCF   03,F
0FD0:  DECFSZ x68,F
0FD2:  BRA    0F80
0FD4:  MOVFF  64,FEF
0FD8:  MOVFF  65,FEC
0FDC:  MOVFF  66,FEC
0FE0:  MOVFF  67,FEC
0FE4:  RETURN 0
0FE6:  MOVF   FE9,W
0FE8:  MOVWF  54
0FEA:  MOVF   53,W
0FEC:  MOVWF  56
0FEE:  BZ    1022
0FF0:  MOVFF  52,84
0FF4:  MOVFF  51,83
0FF8:  MOVFF  50,82
0FFC:  MOVFF  4F,81
1000:  CLRF   x88
1002:  CLRF   x87
1004:  MOVLW  20
1006:  MOVWF  x86
1008:  MOVLW  82
100A:  MOVWF  x85
100C:  RCALL  08EA
100E:  MOVFF  03,52
1012:  MOVFF  02,51
1016:  MOVFF  01,50
101A:  MOVFF  00,4F
101E:  DECFSZ 56,F
1020:  BRA    0FF0
1022:  MOVFF  52,5F
1026:  MOVFF  51,5E
102A:  MOVFF  50,5D
102E:  MOVFF  4F,5C
1032:  BRA    0F18
1034:  MOVFF  03,52
1038:  MOVFF  02,51
103C:  MOVFF  01,50
1040:  MOVFF  00,4F
1044:  BTFSS  52.7
1046:  BRA    1062
1048:  DECF   54,F
104A:  BSF    54.5
104C:  COMF   4F,F
104E:  COMF   50,F
1050:  COMF   51,F
1052:  COMF   52,F
1054:  INCF   4F,F
1056:  BTFSC  FD8.2
1058:  INCF   50,F
105A:  BTFSC  FD8.2
105C:  INCF   51,F
105E:  BTFSC  FD8.2
1060:  INCF   52,F
1062:  MOVLW  3B
1064:  MOVWF  5B
1066:  MOVLW  9A
1068:  MOVWF  5A
106A:  MOVLW  CA
106C:  MOVWF  59
106E:  CLRF   58
1070:  MOVLW  0A
1072:  MOVWF  56
1074:  MOVF   53,W
1076:  BTFSC  FD8.2
1078:  INCF   54,F
107A:  BSF    FD8.1
107C:  CLRF   FEA
107E:  MOVLW  4F
1080:  MOVWF  FE9
1082:  MOVFF  52,5F
1086:  MOVFF  51,5E
108A:  MOVFF  50,5D
108E:  MOVFF  4F,5C
1092:  MOVFF  5B,63
1096:  MOVFF  5A,62
109A:  MOVFF  59,61
109E:  MOVFF  58,60
10A2:  RCALL  0F58
10A4:  MOVF   01,W
10A6:  MOVF   00,F
10A8:  BNZ   10C8
10AA:  INCF   53,W
10AC:  SUBWF  56,W
10AE:  BZ    10C8
10B0:  MOVF   54,W
10B2:  BZ    10CC
10B4:  ANDLW  0F
10B6:  SUBWF  56,W
10B8:  BZ    10BC
10BA:  BC    1132
10BC:  BTFSC  54.7
10BE:  BRA    1132
10C0:  BTFSC  54.6
10C2:  BRA    10CC
10C4:  MOVLW  20
10C6:  BRA    1128
10C8:  MOVLW  20
10CA:  ANDWF  54,F
10CC:  BTFSS  54.5
10CE:  BRA    10EA
10D0:  BCF    54.5
10D2:  MOVF   53,W
10D4:  BTFSS  FD8.2
10D6:  DECF   54,F
10D8:  MOVF   00,W
10DA:  MOVWF  54
10DC:  MOVLW  2D
10DE:  MOVWF  5D
10E0:  CALL   02F2
10E4:  MOVF   54,W
10E6:  MOVWF  00
10E8:  CLRF   54
10EA:  MOVF   53,W
10EC:  SUBWF  56,W
10EE:  BNZ   1106
10F0:  MOVF   00,W
10F2:  MOVWF  54
10F4:  MOVLW  2E
10F6:  MOVWF  5D
10F8:  CALL   02F2
10FC:  MOVF   54,W
10FE:  MOVWF  00
1100:  MOVLW  20
1102:  ANDWF  54,F
1104:  MOVLW  00
1106:  MOVLW  30
1108:  BTFSS  54.5
110A:  BRA    1128
110C:  BCF    54.5
110E:  MOVF   53,W
1110:  BTFSS  FD8.2
1112:  DECF   54,F
1114:  MOVF   00,W
1116:  MOVWF  54
1118:  MOVLW  2D
111A:  MOVWF  5D
111C:  CALL   02F2
1120:  MOVF   54,W
1122:  MOVWF  00
1124:  CLRF   54
1126:  MOVLW  30
1128:  ADDWF  00,F
112A:  MOVFF  00,5D
112E:  CALL   02F2
1132:  BCF    FD8.1
1134:  MOVFF  5B,5F
1138:  MOVFF  5A,5E
113C:  MOVFF  59,5D
1140:  MOVFF  58,5C
1144:  CLRF   x63
1146:  CLRF   x62
1148:  CLRF   x61
114A:  MOVLW  0A
114C:  MOVWF  x60
114E:  RCALL  0F58
1150:  MOVFF  03,5B
1154:  MOVFF  02,5A
1158:  MOVFF  01,59
115C:  MOVFF  00,58
1160:  DECFSZ 56,F
1162:  BRA    107A
1164:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=12 Mhz, crystal= 12 MHz)   // Selecciona la velocidad del oscilador interno 
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
.................... int contador = 0 ;int pulso_timer = 0 ; 
.................... #include "funciones.h"  
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
*
0192:  BSF    F95.6
0194:  MOVLW  02
0196:  MOVWF  00
0198:  DECFSZ 00,F
019A:  BRA    0198
019C:  BSF    F95.7
019E:  MOVLW  02
01A0:  MOVWF  00
01A2:  DECFSZ 00,F
01A4:  BRA    01A2
01A6:  BCF    F8C.6
01A8:  BCF    F95.6
01AA:  MOVLW  02
01AC:  MOVWF  00
01AE:  DECFSZ 00,F
01B0:  BRA    01AE
01B2:  BCF    F8C.7
01B4:  BCF    F95.7
....................         delay_us(20); 
01B6:  MOVLW  13
01B8:  MOVWF  00
01BA:  DECFSZ 00,F
01BC:  BRA    01BA
01BE:  BRA    01C0
....................         i2c_write(LCD_ADDR); //the slave addresse 
01C0:  MOVLW  4E
01C2:  MOVWF  x62
01C4:  RCALL  0126
....................         delay_us(20); 
01C6:  MOVLW  13
01C8:  MOVWF  00
01CA:  DECFSZ 00,F
01CC:  BRA    01CA
01CE:  BRA    01D0
....................         i2c_write(data); 
01D0:  MOVFF  61,62
01D4:  RCALL  0126
....................         delay_us(20); 
01D6:  MOVLW  13
01D8:  MOVWF  00
01DA:  DECFSZ 00,F
01DC:  BRA    01DA
01DE:  BRA    01E0
....................         i2c_stop(); 
01E0:  BCF    F95.6
01E2:  NOP   
01E4:  BSF    F95.7
01E6:  BTFSS  F83.7
01E8:  BRA    01E6
01EA:  MOVLW  02
01EC:  MOVWF  00
01EE:  DECFSZ 00,F
01F0:  BRA    01EE
01F2:  BRA    01F4
01F4:  NOP   
01F6:  BSF    F95.6
01F8:  MOVLW  02
01FA:  MOVWF  00
01FC:  DECFSZ 00,F
01FE:  BRA    01FC
....................         delay_us(20); 
0200:  MOVLW  13
0202:  MOVWF  00
0204:  DECFSZ 00,F
0206:  BRA    0204
0208:  BRA    020A
020A:  RETURN 0
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
020C:  BTFSS  20.0
020E:  BRA    021A
0210:  MOVF   x60,W
0212:  IORLW  04
0214:  IORLW  08
0216:  MOVWF  x60
0218:  BRA    021C
021A:  BSF    x60.2
....................         i2c_send_nibble(data); 
021C:  MOVFF  60,61
0220:  RCALL  0192
....................         data=data-4;       //toggle EN back to 0 
0222:  MOVLW  04
0224:  SUBWF  x60,F
....................         i2c_send_nibble(data); 
0226:  MOVFF  60,61
022A:  RCALL  0192
022C:  RETURN 0
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
022E:  CLRF   x60
0230:  RCALL  020C
....................     lcd_send_byte(0x10); 
0232:  MOVLW  10
0234:  MOVWF  x60
0236:  RCALL  020C
....................     delay_ms(2); 
0238:  MOVLW  02
023A:  MOVWF  5E
023C:  RCALL  00FE
023E:  RETURN 0
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
0240:  MOVLW  C8
0242:  MOVWF  5E
0244:  RCALL  00FE
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
0246:  CLRF   x60
0248:  RCALL  020C
....................         lcd_send_byte(0x10); 
024A:  MOVLW  10
024C:  MOVWF  x60
024E:  RCALL  020C
....................         lcd_send_byte(0x00); 
0250:  CLRF   x60
0252:  RCALL  020C
....................         lcd_send_byte(0x00); 
0254:  CLRF   x60
0256:  RCALL  020C
....................         lcd_send_byte(0x10); 
0258:  MOVLW  10
025A:  MOVWF  x60
025C:  RCALL  020C
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
025E:  MOVLW  30
0260:  MOVWF  x60
0262:  RCALL  020C
....................         lcd_send_byte(0x30); 
0264:  MOVLW  30
0266:  MOVWF  x60
0268:  RCALL  020C
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
026A:  MOVLW  30
026C:  MOVWF  x60
026E:  RCALL  020C
....................         lcd_send_byte(0x20); 
0270:  MOVLW  20
0272:  MOVWF  x60
0274:  RCALL  020C
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
0276:  MOVLW  20
0278:  MOVWF  x60
027A:  RCALL  020C
....................         lcd_send_byte(0x80); 
027C:  MOVLW  80
027E:  MOVWF  x60
0280:  RCALL  020C
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
0282:  CLRF   x60
0284:  RCALL  020C
....................         lcd_send_byte(0xC0); 
0286:  MOVLW  C0
0288:  MOVWF  x60
028A:  RCALL  020C
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
028C:  CLRF   x60
028E:  RCALL  020C
....................         lcd_send_byte(0x60); 
0290:  MOVLW  60
0292:  MOVWF  x60
0294:  RCALL  020C
....................            //clears the display 
....................         lcd_clear(); 
0296:  RCALL  022E
0298:  GOTO   03A4 (RETURN)
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
029C:  MOVF   5F,W
029E:  XORLW  01
02A0:  BZ    02B0
02A2:  XORLW  03
02A4:  BZ    02B6
02A6:  XORLW  01
02A8:  BZ    02BC
02AA:  XORLW  07
02AC:  BZ    02C2
02AE:  BRA    02C8
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
02B0:  MOVLW  80
02B2:  MOVWF  1F
02B4:  BRA    02CC
....................       case 2:  address= lcd_line_two;     break; 
02B6:  MOVLW  C0
02B8:  MOVWF  1F
02BA:  BRA    02CC
....................       case 3:  address= lcd_line_three;   break; 
02BC:  MOVLW  94
02BE:  MOVWF  1F
02C0:  BRA    02CC
....................       case 4:  address= lcd_line_four;    break; 
02C2:  MOVLW  D4
02C4:  MOVWF  1F
02C6:  BRA    02CC
....................       default: address= lcd_line_one;     break;  
02C8:  MOVLW  80
02CA:  MOVWF  1F
....................    } 
....................   
....................    address+=x-1; 
02CC:  MOVLW  01
02CE:  SUBWF  5E,W
02D0:  ADDWF  1F,F
....................    data=address&0xF0; 
02D2:  MOVF   1F,W
02D4:  ANDLW  F0
02D6:  MOVWF  26
....................    lcd_send_byte(data); 
02D8:  MOVFF  26,60
02DC:  RCALL  020C
....................    data=address&0x0F; 
02DE:  MOVF   1F,W
02E0:  ANDLW  0F
02E2:  MOVWF  26
....................    data=data<<4; 
02E4:  SWAPF  26,F
02E6:  MOVLW  F0
02E8:  ANDWF  26,F
....................    lcd_send_byte(data); 
02EA:  MOVFF  26,60
02EE:  RCALL  020C
02F0:  RETURN 0
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
02F2:  MOVF   5D,W
02F4:  XORLW  0C
02F6:  BZ    030A
02F8:  XORLW  0D
02FA:  BZ    030E
02FC:  XORLW  03
02FE:  BZ    0318
0300:  XORLW  01
0302:  BZ    0324
0304:  XORLW  07
0306:  BZ    0330
0308:  BRA    033C
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
030A:  RCALL  022E
030C:  BRA    035E
....................      case '\1': lcd_gotoxy(1,1);  break; 
030E:  MOVLW  01
0310:  MOVWF  5E
0312:  MOVWF  5F
0314:  RCALL  029C
0316:  BRA    035E
....................      case '\2': lcd_gotoxy(1,2);  break; 
0318:  MOVLW  01
031A:  MOVWF  5E
031C:  MOVLW  02
031E:  MOVWF  5F
0320:  RCALL  029C
0322:  BRA    035E
....................      case '\3': lcd_gotoxy(1,3);  break; 
0324:  MOVLW  01
0326:  MOVWF  5E
0328:  MOVLW  03
032A:  MOVWF  5F
032C:  RCALL  029C
032E:  BRA    035E
....................      case '\4': lcd_gotoxy(1,4);  break; 
0330:  MOVLW  01
0332:  MOVWF  5E
0334:  MOVLW  04
0336:  MOVWF  5F
0338:  RCALL  029C
033A:  BRA    035E
....................  
....................      default: 
....................         data=in_data&0xF0; 
033C:  MOVF   5D,W
033E:  ANDLW  F0
0340:  MOVWF  5E
....................         data=data|RS; //set RS pin to 1 
0342:  BSF    5E.0
....................         lcd_send_byte(data); 
0344:  MOVFF  5E,60
0348:  RCALL  020C
....................         data=in_data&0x0F; 
034A:  MOVF   5D,W
034C:  ANDLW  0F
034E:  MOVWF  5E
....................         data=data<<4; 
0350:  SWAPF  5E,F
0352:  MOVLW  F0
0354:  ANDWF  5E,F
....................         data=data|RS; //set RS pin to 1 
0356:  BSF    5E.0
....................         lcd_send_byte(data); 
0358:  MOVFF  5E,60
035C:  RCALL  020C
....................      break; 
....................    } 
035E:  RETURN 0
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
0A52:  MOVFF  56,80
0A56:  MOVFF  55,7F
0A5A:  MOVFF  54,7E
0A5E:  MOVFF  53,7D
0A62:  CLRF   x84
0A64:  CLRF   x83
0A66:  CLRF   x82
0A68:  CLRF   x81
0A6A:  RCALL  09DC
0A6C:  BC    0A70
0A6E:  BNZ   0A7A
....................       return(0.0); 
0A70:  CLRF   00
0A72:  CLRF   01
0A74:  CLRF   02
0A76:  CLRF   03
0A78:  BRA    0B5A
....................  
....................    y=x; 
0A7A:  MOVFF  56,5A
0A7E:  MOVFF  55,59
0A82:  MOVFF  54,58
0A86:  MOVFF  53,57
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
0A8A:  CLRF   x60
0A8C:  MOVLW  57
0A8E:  MOVWF  5F
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
0A90:  MOVFF  5F,FE9
0A94:  MOVFF  60,FEA
0A98:  MOVF   FEF,W
0A9A:  CLRF   x64
0A9C:  MOVWF  x63
0A9E:  MOVLW  7F
0AA0:  ADDWF  x63,F
0AA2:  MOVLW  00
0AA4:  ADDWFC x64,F
0AA6:  BCF    FD8.0
0AA8:  RRCF   x64,W
0AAA:  RRCF   x63,W
0AAC:  MOVFF  60,FEA
0AB0:  MOVFF  5F,FE9
0AB4:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0AB6:  MOVFF  5A,5E
0ABA:  MOVFF  59,5D
0ABE:  MOVFF  58,5C
0AC2:  MOVFF  57,5B
....................       y+=(x/y); 
0AC6:  MOVFF  56,64
0ACA:  MOVFF  55,63
0ACE:  MOVFF  54,62
0AD2:  MOVFF  53,61
0AD6:  MOVFF  5A,68
0ADA:  MOVFF  59,67
0ADE:  MOVFF  58,66
0AE2:  MOVFF  57,65
0AE6:  RCALL  0526
0AE8:  BCF    FD8.1
0AEA:  MOVFF  5A,84
0AEE:  MOVFF  59,83
0AF2:  MOVFF  58,82
0AF6:  MOVFF  57,81
0AFA:  MOVFF  03,88
0AFE:  MOVFF  02,87
0B02:  MOVFF  01,86
0B06:  MOVFF  00,85
0B0A:  RCALL  0680
0B0C:  MOVFF  03,5A
0B10:  MOVFF  02,59
0B14:  MOVFF  01,58
0B18:  MOVFF  00,57
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
0B1C:  MOVFF  5F,FE9
0B20:  MOVFF  60,FEA
0B24:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
0B26:  MOVFF  5E,80
0B2A:  MOVFF  5D,7F
0B2E:  MOVFF  5C,7E
0B32:  MOVFF  5B,7D
0B36:  MOVFF  5A,84
0B3A:  MOVFF  59,83
0B3E:  MOVFF  58,82
0B42:  MOVFF  57,81
0B46:  RCALL  09DC
0B48:  BNZ   0AB6
....................  
....................    return(res); 
0B4A:  MOVFF  5B,00
0B4E:  MOVFF  5C,01
0B52:  MOVFF  5D,02
0B56:  MOVFF  5E,03
0B5A:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
0BBA:  CLRF   x62
0BBC:  CLRF   x61
0BBE:  CLRF   x60
0BC0:  MOVLW  7F
0BC2:  MOVWF  5F
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
0BC4:  MOVLW  7E
0BC6:  MOVWF  x69
0BC8:  MOVLW  80
0BCA:  MOVWF  x6A
0BCC:  CLRF   x6B
0BCE:  CLRF   x6C
0BD0:  MOVLW  7A
0BD2:  MOVWF  x6D
0BD4:  MOVLW  2A
0BD6:  MOVWF  x6E
0BD8:  MOVLW  AA
0BDA:  MOVWF  x6F
0BDC:  MOVLW  A3
0BDE:  MOVWF  x70
0BE0:  MOVLW  75
0BE2:  MOVWF  x71
0BE4:  MOVLW  B6
0BE6:  MOVWF  x72
0BE8:  MOVLW  09
0BEA:  MOVWF  x73
0BEC:  MOVLW  B4
0BEE:  MOVWF  x74
0BF0:  MOVLW  6F
0BF2:  MOVWF  x75
0BF4:  MOVLW  4F
0BF6:  MOVWF  x76
0BF8:  MOVLW  B6
0BFA:  MOVWF  x77
0BFC:  MOVLW  AA
0BFE:  MOVWF  x78
0C00:  MOVLW  69
0C02:  MOVWF  x79
0C04:  MOVLW  8B
0C06:  MOVWF  x7A
0C08:  MOVLW  F6
0C0A:  MOVWF  x7B
0C0C:  MOVLW  E8
0C0E:  MOVWF  x7C
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0C10:  MOVFF  56,80
0C14:  MOVFF  55,7F
0C18:  MOVFF  54,7E
0C1C:  MOVFF  53,7D
0C20:  CLRF   x84
0C22:  CLRF   x83
0C24:  CLRF   x82
0C26:  CLRF   x81
0C28:  RCALL  09DC
0C2A:  BNC   0C32
0C2C:  MOVF   54,W
0C2E:  XORLW  80
0C30:  MOVWF  54
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0C32:  MOVFF  56,84
0C36:  MOVFF  55,83
0C3A:  MOVFF  54,82
0C3E:  MOVFF  53,81
0C42:  MOVLW  83
0C44:  MOVWF  x88
0C46:  MOVLW  F9
0C48:  MOVWF  x87
0C4A:  MOVLW  22
0C4C:  MOVWF  x86
0C4E:  MOVLW  7E
0C50:  MOVWF  x85
0C52:  RCALL  08EA
0C54:  MOVFF  03,80
0C58:  MOVFF  02,7F
0C5C:  MOVFF  01,7E
0C60:  MOVFF  00,7D
0C64:  BRA    0B80
0C66:  MOVFF  01,63
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0C6A:  MOVFF  56,84
0C6E:  MOVFF  55,83
0C72:  MOVFF  54,82
0C76:  MOVFF  53,81
0C7A:  MOVLW  83
0C7C:  MOVWF  x88
0C7E:  MOVLW  F9
0C80:  MOVWF  x87
0C82:  MOVLW  22
0C84:  MOVWF  x86
0C86:  MOVLW  7E
0C88:  MOVWF  x85
0C8A:  RCALL  08EA
0C8C:  MOVFF  03,80
0C90:  MOVFF  02,7F
0C94:  MOVFF  01,7E
0C98:  MOVFF  00,7D
0C9C:  CLRF   x82
0C9E:  MOVFF  63,81
0CA2:  RCALL  04F0
0CA4:  BSF    FD8.1
0CA6:  MOVFF  80,84
0CAA:  MOVFF  7F,83
0CAE:  MOVFF  7E,82
0CB2:  MOVFF  7D,81
0CB6:  MOVFF  03,88
0CBA:  MOVFF  02,87
0CBE:  MOVFF  01,86
0CC2:  MOVFF  00,85
0CC6:  RCALL  0680
0CC8:  MOVFF  03,68
0CCC:  MOVFF  02,67
0CD0:  MOVFF  01,66
0CD4:  MOVFF  00,65
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0CD8:  MOVLW  03
0CDA:  ANDWF  x63,F
....................  
....................    if (quad == 0 || quad == 2) 
0CDC:  MOVF   x63,F
0CDE:  BZ    0CE6
0CE0:  MOVF   x63,W
0CE2:  SUBLW  02
0CE4:  BNZ   0D1A
....................       t = frac * PI_DIV_BY_TWO; 
0CE6:  MOVFF  68,84
0CEA:  MOVFF  67,83
0CEE:  MOVFF  66,82
0CF2:  MOVFF  65,81
0CF6:  MOVLW  DB
0CF8:  MOVWF  x88
0CFA:  MOVLW  0F
0CFC:  MOVWF  x87
0CFE:  MOVLW  49
0D00:  MOVWF  x86
0D02:  MOVLW  7F
0D04:  MOVWF  x85
0D06:  RCALL  08EA
0D08:  MOVFF  03,5E
0D0C:  MOVFF  02,5D
0D10:  MOVFF  01,5C
0D14:  MOVFF  00,5B
0D18:  BRA    0DE0
....................    else if (quad == 1) 
0D1A:  DECFSZ x63,W
0D1C:  BRA    0D80
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0D1E:  BSF    FD8.1
0D20:  CLRF   x84
0D22:  CLRF   x83
0D24:  CLRF   x82
0D26:  MOVLW  7F
0D28:  MOVWF  x81
0D2A:  MOVFF  68,88
0D2E:  MOVFF  67,87
0D32:  MOVFF  66,86
0D36:  MOVFF  65,85
0D3A:  RCALL  0680
0D3C:  MOVFF  03,80
0D40:  MOVFF  02,7F
0D44:  MOVFF  01,7E
0D48:  MOVFF  00,7D
0D4C:  MOVFF  03,84
0D50:  MOVFF  02,83
0D54:  MOVFF  01,82
0D58:  MOVFF  00,81
0D5C:  MOVLW  DB
0D5E:  MOVWF  x88
0D60:  MOVLW  0F
0D62:  MOVWF  x87
0D64:  MOVLW  49
0D66:  MOVWF  x86
0D68:  MOVLW  7F
0D6A:  MOVWF  x85
0D6C:  RCALL  08EA
0D6E:  MOVFF  03,5E
0D72:  MOVFF  02,5D
0D76:  MOVFF  01,5C
0D7A:  MOVFF  00,5B
0D7E:  BRA    0DE0
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0D80:  BSF    FD8.1
0D82:  MOVFF  68,84
0D86:  MOVFF  67,83
0D8A:  MOVFF  66,82
0D8E:  MOVFF  65,81
0D92:  CLRF   x88
0D94:  CLRF   x87
0D96:  CLRF   x86
0D98:  MOVLW  7F
0D9A:  MOVWF  x85
0D9C:  RCALL  0680
0D9E:  MOVFF  03,80
0DA2:  MOVFF  02,7F
0DA6:  MOVFF  01,7E
0DAA:  MOVFF  00,7D
0DAE:  MOVFF  03,84
0DB2:  MOVFF  02,83
0DB6:  MOVFF  01,82
0DBA:  MOVFF  00,81
0DBE:  MOVLW  DB
0DC0:  MOVWF  x88
0DC2:  MOVLW  0F
0DC4:  MOVWF  x87
0DC6:  MOVLW  49
0DC8:  MOVWF  x86
0DCA:  MOVLW  7F
0DCC:  MOVWF  x85
0DCE:  RCALL  08EA
0DD0:  MOVFF  03,5E
0DD4:  MOVFF  02,5D
0DD8:  MOVFF  01,5C
0DDC:  MOVFF  00,5B
....................  
....................    y = 1.0; 
0DE0:  CLRF   5A
0DE2:  CLRF   59
0DE4:  CLRF   58
0DE6:  MOVLW  7F
0DE8:  MOVWF  57
....................    t = t * t; 
0DEA:  MOVFF  5E,84
0DEE:  MOVFF  5D,83
0DF2:  MOVFF  5C,82
0DF6:  MOVFF  5B,81
0DFA:  MOVFF  5E,88
0DFE:  MOVFF  5D,87
0E02:  MOVFF  5C,86
0E06:  MOVFF  5B,85
0E0A:  RCALL  08EA
0E0C:  MOVFF  03,5E
0E10:  MOVFF  02,5D
0E14:  MOVFF  01,5C
0E18:  MOVFF  00,5B
....................    for (i = 0; i <= 4; i++) 
0E1C:  CLRF   x64
0E1E:  MOVF   x64,W
0E20:  SUBLW  04
0E22:  BNC   0ED4
....................    { 
....................       t2 = t2 * t; 
0E24:  MOVFF  62,84
0E28:  MOVFF  61,83
0E2C:  MOVFF  60,82
0E30:  MOVFF  5F,81
0E34:  MOVFF  5E,88
0E38:  MOVFF  5D,87
0E3C:  MOVFF  5C,86
0E40:  MOVFF  5B,85
0E44:  RCALL  08EA
0E46:  MOVFF  03,62
0E4A:  MOVFF  02,61
0E4E:  MOVFF  01,60
0E52:  MOVFF  00,5F
....................       y = y + p[i] * t2; 
0E56:  MOVF   x64,W
0E58:  MULLW  04
0E5A:  MOVF   FF3,W
0E5C:  CLRF   03
0E5E:  ADDLW  69
0E60:  MOVWF  FE9
0E62:  MOVLW  00
0E64:  ADDWFC 03,W
0E66:  MOVWF  FEA
0E68:  MOVFF  FEF,81
0E6C:  MOVFF  FEC,82
0E70:  MOVFF  FEC,83
0E74:  MOVFF  FEC,84
0E78:  MOVFF  62,88
0E7C:  MOVFF  61,87
0E80:  MOVFF  60,86
0E84:  MOVFF  5F,85
0E88:  RCALL  08EA
0E8A:  MOVFF  FEA,7E
0E8E:  MOVFF  FE9,7D
0E92:  BCF    FD8.1
0E94:  MOVFF  5A,84
0E98:  MOVFF  59,83
0E9C:  MOVFF  58,82
0EA0:  MOVFF  57,81
0EA4:  MOVFF  03,88
0EA8:  MOVFF  02,87
0EAC:  MOVFF  01,86
0EB0:  MOVFF  00,85
0EB4:  CALL   0680
0EB8:  MOVFF  7E,FEA
0EBC:  MOVFF  7D,FE9
0EC0:  MOVFF  03,5A
0EC4:  MOVFF  02,59
0EC8:  MOVFF  01,58
0ECC:  MOVFF  00,57
0ED0:  INCF   x64,F
0ED2:  BRA    0E1E
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
0ED4:  MOVF   x63,W
0ED6:  SUBLW  02
0ED8:  BZ    0EDE
0EDA:  DECFSZ x63,W
0EDC:  BRA    0EE4
....................       y = -y;  // correct sign 
0EDE:  MOVF   58,W
0EE0:  XORLW  80
0EE2:  MOVWF  58
....................  
....................    return (y); 
0EE4:  MOVFF  57,00
0EE8:  MOVFF  58,01
0EEC:  MOVFF  59,02
0EF0:  MOVFF  5A,03
0EF4:  GOTO   159A (RETURN)
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <Control_ADCs.h> 
.................... /*  
....................  * File:   MAX191.h 
....................  * Author: MARCOS 
....................  * 
....................  * Created on 23 de septiembre de 2016, 08:14 
....................  */ 
....................  
.................... #ifndef Control_ADCs_H 
.................... #define Control_ADCs_H 
....................  
.................... #define ADC_CSCorriente PIN_A0 
.................... #define ADC_CSTension PIN_A1 
.................... #define ADC_SCLK PIN_A2 
.................... #define ADC_DOUT PIN_A3  // por aqui ingresa la info de los ADC, SDATA en AD7450 
.................... #define ADC_DIN PIN_A4 // se envia la informacion al MAX186 
.................... #define ADC_SSTRB PIN_A5 
....................  
.................... //control AD7450 
.................... long leer_Tension(){ 
*
03C6:  CLRF   50
03C8:  CLRF   4F
....................     signed long dato=0x00,dato_t; 
....................     int i; 
....................     output_low (ADC_CSTension); 
03CA:  BCF    F92.1
03CC:  BCF    F89.1
....................     delay_us(1); 
03CE:  BRA    03D0
03D0:  NOP   
....................     output_low (ADC_SCLK); 
03D2:  BCF    F92.2
03D4:  BCF    F89.2
....................     delay_us(1); 
03D6:  BRA    03D8
03D8:  NOP   
....................     output_high (ADC_SCLK); 
03DA:  BCF    F92.2
03DC:  BSF    F89.2
....................     delay_us(1); 
03DE:  BRA    03E0
03E0:  NOP   
....................      
....................         for(i=0;i<15;i++){ 
03E2:  CLRF   53
03E4:  MOVF   53,W
03E6:  SUBLW  0E
03E8:  BNC   040E
....................           shift_left(&dato,2,input(ADC_DOUT)); 
03EA:  BSF    F92.3
03EC:  BTFSC  F80.3
03EE:  BRA    03F4
03F0:  BCF    FD8.0
03F2:  BRA    03F6
03F4:  BSF    FD8.0
03F6:  RLCF   4F,F
03F8:  RLCF   50,F
....................           output_low(ADC_SCLK); 
03FA:  BCF    F92.2
03FC:  BCF    F89.2
....................           delay_us(1);  
03FE:  BRA    0400
0400:  NOP   
....................           output_high(ADC_SCLK);  
0402:  BCF    F92.2
0404:  BSF    F89.2
....................           delay_us(1); 
0406:  BRA    0408
0408:  NOP   
040A:  INCF   53,F
040C:  BRA    03E4
....................         } 
....................  
....................        // output_high (ADC_SCLK); 
....................        // delay_us(1); 
....................         output_high (ADC_CSTension); 
040E:  BCF    F92.1
0410:  BSF    F89.1
....................          
....................        dato_t=(dato&0x0800); 
0412:  CLRF   51
0414:  MOVF   50,W
0416:  ANDLW  08
0418:  MOVWF  52
....................          
....................       if (dato_t==0x0800){ 
041A:  MOVF   51,F
041C:  BNZ   0438
041E:  MOVF   52,W
0420:  SUBLW  08
0422:  BNZ   0438
....................             dato=-2048+(dato&0xF7FF); 
0424:  MOVFF  4F,00
0428:  MOVF   50,W
042A:  ANDLW  F7
042C:  MOVWF  03
042E:  MOVFF  4F,4F
0432:  MOVLW  F8
0434:  ADDWF  03,W
0436:  MOVWF  50
....................         } 
....................         
....................     return(dato); 
0438:  MOVFF  4F,01
043C:  MOVFF  50,02
0440:  GOTO   1194 (RETURN)
.................... } 
....................  
.................... //control MAX186 
.................... long leer_Corriente(){ 
0444:  MOVLW  8E
0446:  MOVWF  51
....................     long dato; 
....................     BYTE config= 0b10001110; 
....................     int i; 
....................     output_low (ADC_CSCorriente); 
0448:  BCF    F92.0
044A:  BCF    F89.0
....................     output_low (ADC_DIN); 
044C:  BCF    F92.4
044E:  BCF    F89.4
....................     delay_us(1); 
0450:  BRA    0452
0452:  NOP   
....................      
....................     for(i=0; i<8; i++) { 
0454:  CLRF   52
0456:  MOVF   52,W
0458:  SUBLW  07
045A:  BNC   047E
....................       output_bit(ADC_DIN, shift_left(&config,1,0)); 
045C:  BCF    FD8.0
045E:  RLCF   51,F
0460:  BC    0466
0462:  BCF    F89.4
0464:  BRA    0468
0466:  BSF    F89.4
0468:  BCF    F92.4
....................       output_high(ADC_SCLK); 
046A:  BCF    F92.2
046C:  BSF    F89.2
....................       delay_us(1); 
046E:  BRA    0470
0470:  NOP   
....................       output_low(ADC_SCLK);	 
0472:  BCF    F92.2
0474:  BCF    F89.2
....................       delay_us(1); 
0476:  BRA    0478
0478:  NOP   
047A:  INCF   52,F
047C:  BRA    0456
....................    } 
....................  
....................     output_high(ADC_CSCorriente); 
047E:  BCF    F92.0
0480:  BSF    F89.0
....................      
....................     while(input(ADC_SSTRB)=='0');    
....................          
....................         output_low (ADC_CSCorriente); 
0482:  BCF    F92.0
0484:  BCF    F89.0
....................         output_high (ADC_SCLK); 
0486:  BCF    F92.2
0488:  BSF    F89.2
....................         delay_us(1); 
048A:  BRA    048C
048C:  NOP   
....................         output_low (ADC_SCLK); 
048E:  BCF    F92.2
0490:  BCF    F89.2
....................         delay_us(1); 
0492:  BRA    0494
0494:  NOP   
....................          
....................         for(i=0;i<15;i++){ 
0496:  CLRF   52
0498:  MOVF   52,W
049A:  SUBLW  0E
049C:  BNC   04C2
....................           output_high(ADC_SCLK); 
049E:  BCF    F92.2
04A0:  BSF    F89.2
....................           delay_us(1); 
04A2:  BRA    04A4
04A4:  NOP   
....................           shift_left(&dato,2,input(ADC_DOUT));  
04A6:  BSF    F92.3
04A8:  BTFSC  F80.3
04AA:  BRA    04B0
04AC:  BCF    FD8.0
04AE:  BRA    04B2
04B0:  BSF    FD8.0
04B2:  RLCF   4F,F
04B4:  RLCF   50,F
....................           output_low(ADC_SCLK); 
04B6:  BCF    F92.2
04B8:  BCF    F89.2
....................           delay_us(1); 
04BA:  BRA    04BC
04BC:  NOP   
04BE:  INCF   52,F
04C0:  BRA    0498
....................         } 
....................   
....................          
....................         output_high (ADC_CSCorriente); 
04C2:  BCF    F92.0
04C4:  BSF    F89.0
....................      
....................  
....................     dato= (dato>>3)& 0x0FFF; 
04C6:  RRCF   50,W
04C8:  MOVWF  54
04CA:  RRCF   4F,W
04CC:  MOVWF  53
04CE:  RRCF   54,F
04D0:  RRCF   53,F
04D2:  RRCF   54,F
04D4:  RRCF   53,F
04D6:  MOVLW  1F
04D8:  ANDWF  54,F
04DA:  MOVFF  53,4F
04DE:  MOVF   54,W
04E0:  ANDLW  0F
04E2:  MOVWF  50
....................     return(dato); 
04E4:  MOVFF  4F,01
04E8:  MOVFF  50,02
04EC:  GOTO   11A0 (RETURN)
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //Implementacion Switch-Case 
....................  
.................... /** 
.................... *	\fn void maquina_estado() 
.................... *	\brief Implementacion Switch-Case 
.................... *	\details  
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
....................  **/ 
.................... unsigned long punto1, punto2; 
.................... int8 pos_V,pos_I,pos_V_A,pos_I_A; 
.................... int control_V, control_I; 
.................... int desfase; 
.................... float tension, corriente, tension_RMS,corriente_RMS, t_desfase, potencia_ins,angulo; 
....................  
.................... const long carga= 0xF485; 
....................  
.................... #INT_RTCC                // interrupcion para demora de 500 us 
.................... void interrtimer_0(){ 
....................     set_timer0(carga);   // interrupcion cada 500 us 
*
00BC:  MOVLW  F4
00BE:  MOVWF  FD7
00C0:  MOVLW  85
00C2:  MOVWF  FD6
....................     pulso_timer++; 
00C4:  INCF   25,F
....................  
00C6:  BCF    FF2.2
00C8:  GOTO   0060
....................    } 
....................  
.................... void maquina_estado() 
.................... { 
.................... 		static int estado = PUNTO_TENS_CORR; 
....................  
.................... 		switch(estado) 
*
1166:  MOVF   4E,W
1168:  XORLW  00
116A:  BZ    1184
116C:  XORLW  01
116E:  BZ    11E8
1170:  XORLW  03
1172:  BTFSC  FD8.2
1174:  BRA    1328
1176:  XORLW  01
1178:  BTFSC  FD8.2
117A:  BRA    13FE
117C:  XORLW  07
117E:  BTFSC  FD8.2
1180:  BRA    15E2
1182:  BRA    16B0
.................... 		{ 
.................... 			case PUNTO_TENS_CORR: 
....................                 set_adc_channel(0);           //Habilitación canal 
1184:  MOVLW  00
1186:  MOVWF  01
1188:  MOVF   FC2,W
118A:  ANDLW  C3
118C:  IORWF  01,W
118E:  MOVWF  FC2
....................                 punto1= leer_Tension(); 
1190:  GOTO   03C6
1194:  MOVFF  02,28
1198:  MOVFF  01,27
....................                 punto2= leer_Corriente(); // comprobar si funciona con el tiempo de demora de la lectura del externo 
119C:  GOTO   0444
11A0:  MOVFF  02,2A
11A4:  MOVFF  01,29
....................                 // convierte los valores de long a float 
....................                 tension=punto1; 
11A8:  MOVFF  28,82
11AC:  MOVFF  27,81
11B0:  CALL   04F0
11B4:  MOVFF  03,35
11B8:  MOVFF  02,34
11BC:  MOVFF  01,33
11C0:  MOVFF  00,32
....................                 corriente=punto2; 
11C4:  MOVFF  2A,82
11C8:  MOVFF  29,81
11CC:  CALL   04F0
11D0:  MOVFF  03,39
11D4:  MOVFF  02,38
11D8:  MOVFF  01,37
11DC:  MOVFF  00,36
....................                 contador++; 
11E0:  INCF   22,F
.................... 					estado = CONVERSION_DESFASE; 
11E2:  MOVLW  01
11E4:  MOVWF  4E
.................... 		 
.................... 				 
....................  
.................... 				break; 
11E6:  BRA    16B2
.................... 			 
.................... 			case CONVERSION_DESFASE: 
....................                 tension= (tension)/1000-2.54; 
11E8:  MOVFF  35,64
11EC:  MOVFF  34,63
11F0:  MOVFF  33,62
11F4:  MOVFF  32,61
11F8:  CLRF   x68
11FA:  CLRF   x67
11FC:  MOVLW  7A
11FE:  MOVWF  x66
1200:  MOVLW  88
1202:  MOVWF  x65
1204:  CALL   0526
1208:  MOVFF  03,52
120C:  MOVFF  02,51
1210:  MOVFF  01,50
1214:  MOVFF  00,4F
1218:  BSF    FD8.1
121A:  MOVFF  03,84
121E:  MOVFF  02,83
1222:  MOVFF  01,82
1226:  MOVFF  00,81
122A:  MOVLW  5C
122C:  MOVWF  x88
122E:  MOVLW  8F
1230:  MOVWF  x87
1232:  MOVLW  22
1234:  MOVWF  x86
1236:  MOVLW  80
1238:  MOVWF  x85
123A:  CALL   0680
123E:  MOVFF  03,35
1242:  MOVFF  02,34
1246:  MOVFF  01,33
124A:  MOVFF  00,32
....................                 corriente= (corriente*5)/1024-2.5; 
124E:  MOVFF  39,84
1252:  MOVFF  38,83
1256:  MOVFF  37,82
125A:  MOVFF  36,81
125E:  CLRF   x88
1260:  CLRF   x87
1262:  MOVLW  20
1264:  MOVWF  x86
1266:  MOVLW  81
1268:  MOVWF  x85
126A:  CALL   08EA
126E:  MOVFF  03,52
1272:  MOVFF  02,51
1276:  MOVFF  01,50
127A:  MOVFF  00,4F
127E:  MOVFF  03,64
1282:  MOVFF  02,63
1286:  MOVFF  01,62
128A:  MOVFF  00,61
128E:  CLRF   x68
1290:  CLRF   x67
1292:  CLRF   x66
1294:  MOVLW  89
1296:  MOVWF  x65
1298:  CALL   0526
129C:  MOVFF  03,52
12A0:  MOVFF  02,51
12A4:  MOVFF  01,50
12A8:  MOVFF  00,4F
12AC:  BSF    FD8.1
12AE:  MOVFF  03,84
12B2:  MOVFF  02,83
12B6:  MOVFF  01,82
12BA:  MOVFF  00,81
12BE:  CLRF   x88
12C0:  CLRF   x87
12C2:  MOVLW  20
12C4:  MOVWF  x86
12C6:  MOVLW  80
12C8:  MOVWF  x85
12CA:  CALL   0680
12CE:  MOVFF  03,39
12D2:  MOVFF  02,38
12D6:  MOVFF  01,37
12DA:  MOVFF  00,36
....................                  
....................                 // Analisis del punto POSITVO O NEGATIVO 
....................                 // valor positivo estado=0-- valor negativo estado=1 
....................                  
....................                 //TENSION 
....................                 #asm 
....................                 clrf &pos_V; 
12DE:  CLRF   2B
....................                 btfsc (&tension + 0x01), 7; 
12E0:  BTFSC  33.7
....................                 bsf &pos_V,0; 
12E2:  BSF    2B.0
....................                 #endasm 
.................... 				 
....................                 //CORRIENTE 
....................                 #asm 
....................                 clrf &pos_I; 
12E4:  CLRF   2C
....................                 btfsc (&corriente + 0x01), 7; // comprueba signo en un bit de los 4 byte del float 
12E6:  BTFSC  37.7
....................                 bsf &pos_I,0; 
12E8:  BSF    2C.0
....................                 #endasm 
....................  
....................                  
....................                  
.................... 				 
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_V==1 && contador!=0 && pos_V_A==0 && control_V != 0){  
12EA:  DECFSZ 2B,W
12EC:  BRA    1302
12EE:  MOVF   22,F
12F0:  BZ    1302
12F2:  MOVF   2D,F
12F4:  BNZ   1302
12F6:  MOVF   2F,F
12F8:  BZ    1302
....................                  control_V= contador; // tiempo en el que cruzó la tension  
12FA:  MOVFF  22,2F
....................                  desfase=1; 
12FE:  MOVLW  01
1300:  MOVWF  31
....................                 } 
....................                  
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_I==1 && contador!=0 && pos_I_A==0 && control_I != 0){ 
1302:  DECFSZ 2C,W
1304:  BRA    131A
1306:  MOVF   22,F
1308:  BZ    131A
130A:  MOVF   2E,F
130C:  BNZ   131A
130E:  MOVF   30,F
1310:  BZ    131A
....................                      
....................                  control_I= contador; // tiempo en el que cruzó la corriente 
1312:  MOVFF  22,30
....................                  desfase=2; 
1316:  MOVLW  02
1318:  MOVWF  31
....................                 } 
....................                  
....................                 pos_V_A=pos_V; 
131A:  MOVFF  2B,2D
....................                 pos_I_A=pos_I; 
131E:  MOVFF  2C,2E
....................                  
....................                  
.................... 					estado = TENS_CORR_RMS; 
1322:  MOVLW  02
1324:  MOVWF  4E
.................... 		 
.................... 				 
....................  
.................... 				break; 
1326:  BRA    16B2
.................... 			 
.................... 			case TENS_CORR_RMS: 
.................... 			 
.................... 				if((contador<30)&& (pulso_timer==1)) 
1328:  MOVF   22,W
132A:  SUBLW  1D
132C:  BNC   13EA
132E:  DECFSZ 25,W
1330:  BRA    13EA
.................... 				{ 
.................... 					tension_RMS=tension_RMS+ tension * tension;       //calcula tension eficaz 
1332:  MOVFF  35,84
1336:  MOVFF  34,83
133A:  MOVFF  33,82
133E:  MOVFF  32,81
1342:  MOVFF  35,88
1346:  MOVFF  34,87
134A:  MOVFF  33,86
134E:  MOVFF  32,85
1352:  CALL   08EA
1356:  BCF    FD8.1
1358:  MOVFF  3D,84
135C:  MOVFF  3C,83
1360:  MOVFF  3B,82
1364:  MOVFF  3A,81
1368:  MOVFF  03,88
136C:  MOVFF  02,87
1370:  MOVFF  01,86
1374:  MOVFF  00,85
1378:  CALL   0680
137C:  MOVFF  03,3D
1380:  MOVFF  02,3C
1384:  MOVFF  01,3B
1388:  MOVFF  00,3A
....................                     corriente_RMS= corriente_RMS+ corriente * corriente; // calcula corriente eficaz 
138C:  MOVFF  39,84
1390:  MOVFF  38,83
1394:  MOVFF  37,82
1398:  MOVFF  36,81
139C:  MOVFF  39,88
13A0:  MOVFF  38,87
13A4:  MOVFF  37,86
13A8:  MOVFF  36,85
13AC:  CALL   08EA
13B0:  BCF    FD8.1
13B2:  MOVFF  41,84
13B6:  MOVFF  40,83
13BA:  MOVFF  3F,82
13BE:  MOVFF  3E,81
13C2:  MOVFF  03,88
13C6:  MOVFF  02,87
13CA:  MOVFF  01,86
13CE:  MOVFF  00,85
13D2:  CALL   0680
13D6:  MOVFF  03,41
13DA:  MOVFF  02,40
13DE:  MOVFF  01,3F
13E2:  MOVFF  00,3E
....................                     pulso_timer=0; 
13E6:  CLRF   25
....................                      
.................... 					estado = PUNTO_TENS_CORR; 
13E8:  CLRF   4E
.................... 		 
.................... 				} 
.................... 				if((contador== 29)) 
13EA:  MOVF   22,W
13EC:  SUBLW  1D
13EE:  BNZ   13FC
.................... 				{ 
.................... 					disable_interrupts(GLOBAL); 
13F0:  BCF    FF2.6
13F2:  BCF    FF2.7
13F4:  BTFSC  FF2.7
13F6:  BRA    13F2
.................... 					estado = CALCULO_POT_ENER; 
13F8:  MOVLW  03
13FA:  MOVWF  4E
....................                       // lcd_gotoxy(1,1);   
....................                       // printf(LCD_PUTC,"entro timer \%d",contador); 
.................... 				} 
....................  
.................... 				break; 
13FC:  BRA    16B2
.................... 			 
.................... 			case CALCULO_POT_ENER: // falta calculo de energia 
....................                 //calcula las raices para completar el calculo RMS 
.................... 				tension_RMS= sqrt(tension_RMS/30); 
13FE:  MOVFF  3D,64
1402:  MOVFF  3C,63
1406:  MOVFF  3B,62
140A:  MOVFF  3A,61
140E:  CLRF   x68
1410:  CLRF   x67
1412:  MOVLW  70
1414:  MOVWF  x66
1416:  MOVLW  83
1418:  MOVWF  x65
141A:  CALL   0526
141E:  MOVFF  03,52
1422:  MOVFF  02,51
1426:  MOVFF  01,50
142A:  MOVFF  00,4F
142E:  MOVFF  03,56
1432:  MOVFF  02,55
1436:  MOVFF  01,54
143A:  MOVFF  00,53
143E:  CALL   0A52
1442:  MOVFF  03,3D
1446:  MOVFF  02,3C
144A:  MOVFF  01,3B
144E:  MOVFF  00,3A
....................                 corriente_RMS= sqrt(corriente_RMS/30); 
1452:  MOVFF  41,64
1456:  MOVFF  40,63
145A:  MOVFF  3F,62
145E:  MOVFF  3E,61
1462:  CLRF   x68
1464:  CLRF   x67
1466:  MOVLW  70
1468:  MOVWF  x66
146A:  MOVLW  83
146C:  MOVWF  x65
146E:  CALL   0526
1472:  MOVFF  03,52
1476:  MOVFF  02,51
147A:  MOVFF  01,50
147E:  MOVFF  00,4F
1482:  MOVFF  03,56
1486:  MOVFF  02,55
148A:  MOVFF  01,54
148E:  MOVFF  00,53
1492:  CALL   0A52
1496:  MOVFF  03,41
149A:  MOVFF  02,40
149E:  MOVFF  01,3F
14A2:  MOVFF  00,3E
....................                  
....................                 // se controla si se pudo calcular desfase en el estado anterior  
....................                 // se realiza las diferencia de cruce por cero y se convierte de tiempo a radianes 
....................                 if (desfase==2){ 
14A6:  MOVF   31,W
14A8:  SUBLW  02
14AA:  BNZ   1552
....................                     t_desfase= (control_I-control_V); 
14AC:  MOVF   2F,W
14AE:  SUBWF  30,W
14B0:  CLRF   x82
14B2:  MOVWF  x81
14B4:  CALL   04F0
14B8:  MOVFF  03,45
14BC:  MOVFF  02,44
14C0:  MOVFF  01,43
14C4:  MOVFF  00,42
....................                     angulo= (t_desfase*pi)/20;      // angulo de desfase en radianes. 
14C8:  MOVFF  45,84
14CC:  MOVFF  44,83
14D0:  MOVFF  43,82
14D4:  MOVFF  42,81
14D8:  MOVLW  DB
14DA:  MOVWF  x88
14DC:  MOVLW  0F
14DE:  MOVWF  x87
14E0:  MOVLW  49
14E2:  MOVWF  x86
14E4:  MOVLW  80
14E6:  MOVWF  x85
14E8:  CALL   08EA
14EC:  MOVFF  03,52
14F0:  MOVFF  02,51
14F4:  MOVFF  01,50
14F8:  MOVFF  00,4F
14FC:  MOVFF  03,64
1500:  MOVFF  02,63
1504:  MOVFF  01,62
1508:  MOVFF  00,61
150C:  CLRF   x68
150E:  CLRF   x67
1510:  MOVLW  20
1512:  MOVWF  x66
1514:  MOVLW  83
1516:  MOVWF  x65
1518:  CALL   0526
151C:  MOVFF  03,4D
1520:  MOVFF  02,4C
1524:  MOVFF  01,4B
1528:  MOVFF  00,4A
....................                      lcd_gotoxy(1,1); 
152C:  MOVLW  01
152E:  MOVWF  5E
1530:  MOVWF  5F
1532:  CALL   029C
....................                      printf(LCD_PUTC,"Se midio desfase"); 
1536:  MOVLW  CC
1538:  MOVWF  FF6
153A:  MOVLW  00
153C:  MOVWF  FF7
153E:  GOTO   0B5C
....................                      delay_ms(1000); 
1542:  MOVLW  04
1544:  MOVWF  4F
1546:  MOVLW  FA
1548:  MOVWF  5E
154A:  CALL   00FE
154E:  DECFSZ 4F,F
1550:  BRA    1546
....................                 }                 
....................                // calculo de potencia  
....................                 potencia_ins= tension_RMS*corriente_RMS* cos(angulo); 
1552:  MOVFF  3D,84
1556:  MOVFF  3C,83
155A:  MOVFF  3B,82
155E:  MOVFF  3A,81
1562:  MOVFF  41,88
1566:  MOVFF  40,87
156A:  MOVFF  3F,86
156E:  MOVFF  3E,85
1572:  CALL   08EA
1576:  MOVFF  03,52
157A:  MOVFF  02,51
157E:  MOVFF  01,50
1582:  MOVFF  00,4F
1586:  MOVFF  4D,56
158A:  MOVFF  4C,55
158E:  MOVFF  4B,54
1592:  MOVFF  4A,53
1596:  GOTO   0BBA
159A:  MOVFF  52,84
159E:  MOVFF  51,83
15A2:  MOVFF  50,82
15A6:  MOVFF  4F,81
15AA:  MOVFF  03,88
15AE:  MOVFF  02,87
15B2:  MOVFF  01,86
15B6:  MOVFF  00,85
15BA:  CALL   08EA
15BE:  MOVFF  03,49
15C2:  MOVFF  02,48
15C6:  MOVFF  01,47
15CA:  MOVFF  00,46
....................                 //se limpian las variables para la próxima tanta de muestreo 
....................                 control_V=0;       
15CE:  CLRF   2F
....................                 control_I=0; 
15D0:  CLRF   30
....................                 angulo=0; 
15D2:  CLRF   4D
15D4:  CLRF   4C
15D6:  CLRF   4B
15D8:  CLRF   4A
....................                 desfase=0;  
15DA:  CLRF   31
....................                  
.................... 					estado = MOSTRAR_DATOS; 
15DC:  MOVLW  04
15DE:  MOVWF  4E
.................... 				break; 
15E0:  BRA    16B2
.................... 			 
.................... 			case MOSTRAR_DATOS: 
....................                 //este estado solo muestra los datos en la pantalla LCD 
....................                 lcd_gotoxy(1,1); 
15E2:  MOVLW  01
15E4:  MOVWF  5E
15E6:  MOVWF  5F
15E8:  CALL   029C
....................                 printf(LCD_PUTC,"Potencia= \%f W",potencia_ins); 
15EC:  MOVLW  DE
15EE:  MOVWF  FF6
15F0:  MOVLW  00
15F2:  MOVWF  FF7
15F4:  MOVLW  0A
15F6:  MOVWF  4F
15F8:  RCALL  0EF8
15FA:  MOVLW  89
15FC:  MOVWF  FE9
15FE:  MOVFF  49,52
1602:  MOVFF  48,51
1606:  MOVFF  47,50
160A:  MOVFF  46,4F
160E:  MOVLW  02
1610:  MOVWF  53
1612:  RCALL  0FE6
1614:  MOVLW  20
1616:  MOVWF  5D
1618:  CALL   02F2
161C:  MOVLW  57
161E:  MOVWF  5D
1620:  CALL   02F2
....................                 lcd_gotoxy(1,2); 
1624:  MOVLW  01
1626:  MOVWF  5E
1628:  MOVLW  02
162A:  MOVWF  5F
162C:  CALL   029C
....................                 printf (LCD_PUTC, "T=\%f V  I=\%f A",tension_RMS,corriente_RMS); 
1630:  MOVLW  54
1632:  MOVWF  5D
1634:  CALL   02F2
1638:  MOVLW  3D
163A:  MOVWF  5D
163C:  CALL   02F2
1640:  MOVLW  89
1642:  MOVWF  FE9
1644:  MOVFF  3D,52
1648:  MOVFF  3C,51
164C:  MOVFF  3B,50
1650:  MOVFF  3A,4F
1654:  MOVLW  02
1656:  MOVWF  53
1658:  RCALL  0FE6
165A:  MOVLW  F2
165C:  MOVWF  FF6
165E:  MOVLW  00
1660:  MOVWF  FF7
1662:  MOVLW  06
1664:  MOVWF  4F
1666:  RCALL  0EF8
1668:  MOVLW  89
166A:  MOVWF  FE9
166C:  MOVFF  41,52
1670:  MOVFF  40,51
1674:  MOVFF  3F,50
1678:  MOVFF  3E,4F
167C:  MOVLW  02
167E:  MOVWF  53
1680:  RCALL  0FE6
1682:  MOVLW  20
1684:  MOVWF  5D
1686:  CALL   02F2
168A:  MOVLW  41
168C:  MOVWF  5D
168E:  CALL   02F2
....................                 delay_ms(1000); 
1692:  MOVLW  04
1694:  MOVWF  4F
1696:  MOVLW  FA
1698:  MOVWF  5E
169A:  CALL   00FE
169E:  DECFSZ 4F,F
16A0:  BRA    1696
....................                 enable_interrupts(GLOBAL); 
16A2:  MOVLW  C0
16A4:  IORWF  FF2,F
....................                 set_timer0(0x1D);   // se carga 29 para un desborde en 500 us teniendo en cuenta los tiempos en C 
16A6:  CLRF   FD7
16A8:  MOVLW  1D
16AA:  MOVWF  FD6
.................... 					 
.................... 					estado = PUNTO_TENS_CORR; 
16AC:  CLRF   4E
.................... 		 
....................  
.................... 				break; 
16AE:  BRA    16B2
.................... 			 
.................... 			default: estado = PUNTO_TENS_CORR; 
16B0:  CLRF   4E
.................... 		} 
16B2:  GOTO   16F4 (RETURN)
....................  
....................  
.................... } 
....................  
.................... //Funciones asociadas a los eventos 
....................  
.................... /** 
.................... *	\fn int -(void) 
.................... *	\brief Resumen 
.................... *	\details Detalles 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 4C02   PLL3 CPUDIV1 NOUSBDIV HS FCMEN NOIESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
