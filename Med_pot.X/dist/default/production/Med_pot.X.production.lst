CCS PCH C Compiler, Version 5.048, 5967               06-nov-16 16:05

               Filename:   C:\Users\MARCOS\Proyecto_final\Med_pot.X\dist\default\production\Med_pot.X.production.lst

               ROM used:   7010 bytes (21%)
                           Largest free fragment is 25754
               RAM used:   99 (5%) at main() level
                           168 (8%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   1B0A
*
0008:  GOTO   0250
000C:  NOP   
000E:  NOP   
0010:  NOP   
0012:  NOP   
0014:  NOP   
0016:  NOP   
0018:  MOVWF  04
001A:  MOVFF  FD8,05
001E:  MOVFF  FE0,06
0022:  MOVLB  0
0024:  MOVFF  FE9,0C
0028:  MOVFF  FEA,07
002C:  MOVFF  FE1,08
0030:  MOVFF  FE2,09
0034:  MOVFF  FD9,0A
0038:  MOVFF  FDA,0B
003C:  MOVFF  FF3,12
0040:  MOVFF  FF4,13
0044:  MOVFF  FFA,14
0048:  MOVFF  FF5,15
004C:  MOVFF  FF6,16
0050:  MOVFF  FF7,17
0054:  MOVFF  00,0E
0058:  MOVFF  01,0F
005C:  MOVFF  02,10
0060:  MOVFF  03,11
0064:  BTFSS  FF0.3
0066:  GOTO   0070
006A:  BTFSC  FF0.0
006C:  GOTO   00CC
0070:  MOVFF  0E,00
0074:  MOVFF  0F,01
0078:  MOVFF  10,02
007C:  MOVFF  11,03
0080:  MOVFF  0C,FE9
0084:  MOVFF  07,FEA
0088:  BSF    07.7
008A:  MOVFF  08,FE1
008E:  MOVFF  09,FE2
0092:  MOVFF  0A,FD9
0096:  MOVFF  0B,FDA
009A:  MOVFF  12,FF3
009E:  MOVFF  13,FF4
00A2:  MOVFF  14,FFA
00A6:  MOVFF  15,FF5
00AA:  MOVFF  16,FF6
00AE:  MOVFF  17,FF7
00B2:  MOVF   04,W
00B4:  MOVFF  06,FE0
00B8:  MOVFF  05,FD8
00BC:  RETFIE 0
.................... #import(file="build/default/production/main.o") 
.................... #import(file="build/default/production/funciones.o") 
.................... /** 
.................... *	\file main.c 
.................... *	\brief Resumen del contenido del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00BE:  DATA 50,72
00C0:  DATA 69,6D
00C2:  DATA 65,72
00C4:  DATA 20,70
00C6:  DATA 72,75
00C8:  DATA 65,62
00CA:  DATA 61,00
*
05AE:  TBLRD*+
05B0:  MOVF   FF5,F
05B2:  BZ    05CC
05B4:  MOVFF  FF6,63
05B8:  MOVFF  FF7,64
05BC:  MOVFF  FF5,71
05C0:  RCALL  0540
05C2:  MOVFF  63,FF6
05C6:  MOVFF  64,FF7
05CA:  BRA    05AE
05CC:  GOTO   05FA (RETURN)
*
0656:  MOVLW  8E
0658:  MOVWF  00
065A:  MOVFF  92,01
065E:  MOVFF  91,02
0662:  CLRF   03
0664:  MOVF   01,F
0666:  BNZ   067A
0668:  MOVFF  02,01
066C:  CLRF   02
066E:  MOVLW  08
0670:  SUBWF  00,F
0672:  MOVF   01,F
0674:  BNZ   067A
0676:  CLRF   00
0678:  BRA    068A
067A:  BCF    FD8.0
067C:  BTFSC  01.7
067E:  BRA    0688
0680:  RLCF   02,F
0682:  RLCF   01,F
0684:  DECF   00,F
0686:  BRA    067A
0688:  BCF    01.7
068A:  RETURN 0
068C:  MOVF   x91,W
068E:  BTFSC  FD8.2
0690:  BRA    0774
0692:  MOVWF  00
0694:  MOVF   x95,W
0696:  BTFSC  FD8.2
0698:  BRA    0774
069A:  ADDWF  00,F
069C:  BNC   06A6
069E:  MOVLW  81
06A0:  ADDWF  00,F
06A2:  BC    0774
06A4:  BRA    06AE
06A6:  MOVLW  7F
06A8:  SUBWF  00,F
06AA:  BNC   0774
06AC:  BZ    0774
06AE:  MOVFF  92,99
06B2:  MOVF   x96,W
06B4:  XORWF  x99,F
06B6:  BSF    x92.7
06B8:  BSF    x96.7
06BA:  MOVF   x94,W
06BC:  MULWF  x98
06BE:  MOVFF  FF4,9B
06C2:  MOVF   x93,W
06C4:  MULWF  x97
06C6:  MOVFF  FF4,03
06CA:  MOVFF  FF3,9A
06CE:  MULWF  x98
06D0:  MOVF   FF3,W
06D2:  ADDWF  x9B,F
06D4:  MOVF   FF4,W
06D6:  ADDWFC x9A,F
06D8:  MOVLW  00
06DA:  ADDWFC 03,F
06DC:  MOVF   x94,W
06DE:  MULWF  x97
06E0:  MOVF   FF3,W
06E2:  ADDWF  x9B,F
06E4:  MOVF   FF4,W
06E6:  ADDWFC x9A,F
06E8:  MOVLW  00
06EA:  CLRF   02
06EC:  ADDWFC 03,F
06EE:  ADDWFC 02,F
06F0:  MOVF   x92,W
06F2:  MULWF  x98
06F4:  MOVF   FF3,W
06F6:  ADDWF  x9A,F
06F8:  MOVF   FF4,W
06FA:  ADDWFC 03,F
06FC:  MOVLW  00
06FE:  ADDWFC 02,F
0700:  MOVF   x92,W
0702:  MULWF  x97
0704:  MOVF   FF3,W
0706:  ADDWF  03,F
0708:  MOVF   FF4,W
070A:  ADDWFC 02,F
070C:  MOVLW  00
070E:  CLRF   01
0710:  ADDWFC 01,F
0712:  MOVF   x94,W
0714:  MULWF  x96
0716:  MOVF   FF3,W
0718:  ADDWF  x9A,F
071A:  MOVF   FF4,W
071C:  ADDWFC 03,F
071E:  MOVLW  00
0720:  ADDWFC 02,F
0722:  ADDWFC 01,F
0724:  MOVF   x93,W
0726:  MULWF  x96
0728:  MOVF   FF3,W
072A:  ADDWF  03,F
072C:  MOVF   FF4,W
072E:  ADDWFC 02,F
0730:  MOVLW  00
0732:  ADDWFC 01,F
0734:  MOVF   x92,W
0736:  MULWF  x96
0738:  MOVF   FF3,W
073A:  ADDWF  02,F
073C:  MOVF   FF4,W
073E:  ADDWFC 01,F
0740:  INCF   00,F
0742:  BTFSC  01.7
0744:  BRA    0750
0746:  RLCF   x9A,F
0748:  RLCF   03,F
074A:  RLCF   02,F
074C:  RLCF   01,F
074E:  DECF   00,F
0750:  MOVLW  00
0752:  BTFSS  x9A.7
0754:  BRA    076A
0756:  INCF   03,F
0758:  ADDWFC 02,F
075A:  ADDWFC 01,F
075C:  MOVF   01,W
075E:  BNZ   076A
0760:  MOVF   02,W
0762:  BNZ   076A
0764:  MOVF   03,W
0766:  BNZ   076A
0768:  INCF   00,F
076A:  BTFSC  x99.7
076C:  BSF    01.7
076E:  BTFSS  x99.7
0770:  BCF    01.7
0772:  BRA    077C
0774:  CLRF   00
0776:  CLRF   01
0778:  CLRF   02
077A:  CLRF   03
077C:  RETURN 0
077E:  MOVF   x75,W
0780:  BTFSC  FD8.2
0782:  BRA    08CE
0784:  MOVWF  x81
0786:  MOVF   x79,W
0788:  BTFSC  FD8.2
078A:  BRA    08CE
078C:  SUBWF  x81,F
078E:  BNC   079A
0790:  MOVLW  7F
0792:  ADDWF  x81,F
0794:  BTFSC  FD8.0
0796:  BRA    08CE
0798:  BRA    07A6
079A:  MOVLW  81
079C:  SUBWF  x81,F
079E:  BTFSS  FD8.0
07A0:  BRA    08CE
07A2:  BTFSC  FD8.2
07A4:  BRA    08CE
07A6:  MOVFF  81,00
07AA:  CLRF   01
07AC:  CLRF   02
07AE:  CLRF   03
07B0:  CLRF   x80
07B2:  MOVFF  76,7F
07B6:  BSF    x7F.7
07B8:  MOVFF  77,7E
07BC:  MOVFF  78,7D
07C0:  MOVLW  19
07C2:  MOVWF  x81
07C4:  MOVF   x7C,W
07C6:  SUBWF  x7D,F
07C8:  BC    07E4
07CA:  MOVLW  01
07CC:  SUBWF  x7E,F
07CE:  BC    07E4
07D0:  SUBWF  x7F,F
07D2:  BC    07E4
07D4:  SUBWF  x80,F
07D6:  BC    07E4
07D8:  INCF   x80,F
07DA:  INCF   x7F,F
07DC:  INCF   x7E,F
07DE:  MOVF   x7C,W
07E0:  ADDWF  x7D,F
07E2:  BRA    0834
07E4:  MOVF   x7B,W
07E6:  SUBWF  x7E,F
07E8:  BC    080E
07EA:  MOVLW  01
07EC:  SUBWF  x7F,F
07EE:  BC    080E
07F0:  SUBWF  x80,F
07F2:  BC    080E
07F4:  INCF   x80,F
07F6:  INCF   x7F,F
07F8:  MOVF   x7B,W
07FA:  ADDWF  x7E,F
07FC:  MOVF   x7C,W
07FE:  ADDWF  x7D,F
0800:  BNC   0834
0802:  INCF   x7E,F
0804:  BNZ   0834
0806:  INCF   x7F,F
0808:  BNZ   0834
080A:  INCF   x80,F
080C:  BRA    0834
080E:  MOVF   x7A,W
0810:  IORLW  80
0812:  SUBWF  x7F,F
0814:  BC    0832
0816:  MOVLW  01
0818:  SUBWF  x80,F
081A:  BC    0832
081C:  INCF   x80,F
081E:  MOVF   x7A,W
0820:  IORLW  80
0822:  ADDWF  x7F,F
0824:  MOVF   x7B,W
0826:  ADDWF  x7E,F
0828:  BNC   07FC
082A:  INCF   x7F,F
082C:  BNZ   07FC
082E:  INCF   x80,F
0830:  BRA    07FC
0832:  BSF    03.0
0834:  DECFSZ x81,F
0836:  BRA    083A
0838:  BRA    0850
083A:  BCF    FD8.0
083C:  RLCF   x7D,F
083E:  RLCF   x7E,F
0840:  RLCF   x7F,F
0842:  RLCF   x80,F
0844:  BCF    FD8.0
0846:  RLCF   03,F
0848:  RLCF   02,F
084A:  RLCF   01,F
084C:  RLCF   x82,F
084E:  BRA    07C4
0850:  BTFSS  x82.0
0852:  BRA    0860
0854:  BCF    FD8.0
0856:  RRCF   01,F
0858:  RRCF   02,F
085A:  RRCF   03,F
085C:  RRCF   x82,F
085E:  BRA    0864
0860:  DECF   00,F
0862:  BZ    08CE
0864:  BTFSC  x82.7
0866:  BRA    08A4
0868:  BCF    FD8.0
086A:  RLCF   x7D,F
086C:  RLCF   x7E,F
086E:  RLCF   x7F,F
0870:  RLCF   x80,F
0872:  MOVF   x7C,W
0874:  SUBWF  x7D,F
0876:  BC    0886
0878:  MOVLW  01
087A:  SUBWF  x7E,F
087C:  BC    0886
087E:  SUBWF  x7F,F
0880:  BC    0886
0882:  SUBWF  x80,F
0884:  BNC   08BA
0886:  MOVF   x7B,W
0888:  SUBWF  x7E,F
088A:  BC    0896
088C:  MOVLW  01
088E:  SUBWF  x7F,F
0890:  BC    0896
0892:  SUBWF  x80,F
0894:  BNC   08BA
0896:  MOVF   x7A,W
0898:  IORLW  80
089A:  SUBWF  x7F,F
089C:  BC    08A4
089E:  MOVLW  01
08A0:  SUBWF  x80,F
08A2:  BNC   08BA
08A4:  INCF   03,F
08A6:  BNZ   08BA
08A8:  INCF   02,F
08AA:  BNZ   08BA
08AC:  INCF   01,F
08AE:  BNZ   08BA
08B0:  INCF   00,F
08B2:  BZ    08CE
08B4:  RRCF   01,F
08B6:  RRCF   02,F
08B8:  RRCF   03,F
08BA:  MOVFF  76,81
08BE:  MOVF   x7A,W
08C0:  XORWF  x81,F
08C2:  BTFSS  x81.7
08C4:  BRA    08CA
08C6:  BSF    01.7
08C8:  BRA    08D6
08CA:  BCF    01.7
08CC:  BRA    08D6
08CE:  CLRF   00
08D0:  CLRF   01
08D2:  CLRF   02
08D4:  CLRF   03
08D6:  RETURN 0
08D8:  MOVLW  80
08DA:  BTFSC  FD8.1
08DC:  XORWF  x96,F
08DE:  CLRF   x9B
08E0:  CLRF   x9C
08E2:  MOVFF  92,9A
08E6:  MOVF   x96,W
08E8:  XORWF  x9A,F
08EA:  MOVF   x91,W
08EC:  BTFSC  FD8.2
08EE:  BRA    0AA8
08F0:  MOVWF  x99
08F2:  MOVWF  00
08F4:  MOVF   x95,W
08F6:  BTFSC  FD8.2
08F8:  BRA    0ABA
08FA:  SUBWF  x99,F
08FC:  BTFSC  FD8.2
08FE:  BRA    0A02
0900:  BNC   097C
0902:  MOVFF  96,9F
0906:  BSF    x9F.7
0908:  MOVFF  97,9E
090C:  MOVFF  98,9D
0910:  CLRF   x9C
0912:  BCF    FD8.0
0914:  RRCF   x9F,F
0916:  RRCF   x9E,F
0918:  RRCF   x9D,F
091A:  RRCF   x9C,F
091C:  DECFSZ x99,F
091E:  BRA    0910
0920:  BTFSS  x9A.7
0922:  BRA    092A
0924:  BSF    x9B.0
0926:  BRA    0AE2
0928:  BCF    x9B.0
092A:  BCF    x99.0
092C:  BSF    x9B.4
092E:  CLRF   FEA
0930:  MOVLW  94
0932:  MOVWF  FE9
0934:  BRA    0B08
0936:  BCF    x9B.4
0938:  BTFSC  x9A.7
093A:  BRA    0950
093C:  BTFSS  x99.0
093E:  BRA    0966
0940:  RRCF   x9F,F
0942:  RRCF   x9E,F
0944:  RRCF   x9D,F
0946:  RRCF   x9C,F
0948:  INCF   00,F
094A:  BTFSC  FD8.2
094C:  BRA    0AD8
094E:  BRA    0966
0950:  BTFSC  x9F.7
0952:  BRA    096C
0954:  BCF    FD8.0
0956:  RLCF   x9C,F
0958:  RLCF   x9D,F
095A:  RLCF   x9E,F
095C:  RLCF   x9F,F
095E:  DECF   00,F
0960:  BTFSC  FD8.2
0962:  BRA    0AD8
0964:  BRA    0950
0966:  BSF    x9B.6
0968:  BRA    0A40
096A:  BCF    x9B.6
096C:  MOVFF  92,9A
0970:  BTFSS  x92.7
0972:  BRA    0978
0974:  BSF    x9F.7
0976:  BRA    0ACA
0978:  BCF    x9F.7
097A:  BRA    0ACA
097C:  MOVFF  95,99
0980:  MOVFF  95,00
0984:  MOVF   x91,W
0986:  SUBWF  x99,F
0988:  MOVFF  92,9F
098C:  BSF    x9F.7
098E:  MOVFF  93,9E
0992:  MOVFF  94,9D
0996:  CLRF   x9C
0998:  BCF    FD8.0
099A:  RRCF   x9F,F
099C:  RRCF   x9E,F
099E:  RRCF   x9D,F
09A0:  RRCF   x9C,F
09A2:  DECFSZ x99,F
09A4:  BRA    0996
09A6:  BTFSS  x9A.7
09A8:  BRA    09B0
09AA:  BSF    x9B.1
09AC:  BRA    0AE2
09AE:  BCF    x9B.1
09B0:  BCF    x99.0
09B2:  BSF    x9B.5
09B4:  CLRF   FEA
09B6:  MOVLW  98
09B8:  MOVWF  FE9
09BA:  BRA    0B08
09BC:  BCF    x9B.5
09BE:  BTFSC  x9A.7
09C0:  BRA    09D6
09C2:  BTFSS  x99.0
09C4:  BRA    09EC
09C6:  RRCF   x9F,F
09C8:  RRCF   x9E,F
09CA:  RRCF   x9D,F
09CC:  RRCF   x9C,F
09CE:  INCF   00,F
09D0:  BTFSC  FD8.2
09D2:  BRA    0AD8
09D4:  BRA    09EC
09D6:  BTFSC  x9F.7
09D8:  BRA    09F2
09DA:  BCF    FD8.0
09DC:  RLCF   x9C,F
09DE:  RLCF   x9D,F
09E0:  RLCF   x9E,F
09E2:  RLCF   x9F,F
09E4:  DECF   00,F
09E6:  BTFSC  FD8.2
09E8:  BRA    0AD8
09EA:  BRA    09D6
09EC:  BSF    x9B.7
09EE:  BRA    0A40
09F0:  BCF    x9B.7
09F2:  MOVFF  96,9A
09F6:  BTFSS  x96.7
09F8:  BRA    09FE
09FA:  BSF    x9F.7
09FC:  BRA    0ACA
09FE:  BCF    x9F.7
0A00:  BRA    0ACA
0A02:  MOVFF  96,9F
0A06:  BSF    x9F.7
0A08:  MOVFF  97,9E
0A0C:  MOVFF  98,9D
0A10:  BTFSS  x9A.7
0A12:  BRA    0A1C
0A14:  BCF    x9F.7
0A16:  BSF    x9B.2
0A18:  BRA    0AE2
0A1A:  BCF    x9B.2
0A1C:  CLRF   x9C
0A1E:  BCF    x99.0
0A20:  CLRF   FEA
0A22:  MOVLW  94
0A24:  MOVWF  FE9
0A26:  BRA    0B08
0A28:  BTFSC  x9A.7
0A2A:  BRA    0A64
0A2C:  MOVFF  92,9A
0A30:  BTFSS  x99.0
0A32:  BRA    0A40
0A34:  RRCF   x9F,F
0A36:  RRCF   x9E,F
0A38:  RRCF   x9D,F
0A3A:  RRCF   x9C,F
0A3C:  INCF   00,F
0A3E:  BZ    0AD8
0A40:  BTFSS  x9C.7
0A42:  BRA    0A5A
0A44:  INCF   x9D,F
0A46:  BNZ   0A5A
0A48:  INCF   x9E,F
0A4A:  BNZ   0A5A
0A4C:  INCF   x9F,F
0A4E:  BNZ   0A5A
0A50:  RRCF   x9F,F
0A52:  RRCF   x9E,F
0A54:  RRCF   x9D,F
0A56:  INCF   00,F
0A58:  BZ    0AD8
0A5A:  BTFSC  x9B.6
0A5C:  BRA    096A
0A5E:  BTFSC  x9B.7
0A60:  BRA    09F0
0A62:  BRA    0A9C
0A64:  MOVLW  80
0A66:  XORWF  x9F,F
0A68:  BTFSS  x9F.7
0A6A:  BRA    0A74
0A6C:  BRA    0AE2
0A6E:  MOVFF  96,9A
0A72:  BRA    0A88
0A74:  MOVFF  92,9A
0A78:  MOVF   x9F,F
0A7A:  BNZ   0A88
0A7C:  MOVF   x9E,F
0A7E:  BNZ   0A88
0A80:  MOVF   x9D,F
0A82:  BNZ   0A88
0A84:  CLRF   00
0A86:  BRA    0ACA
0A88:  BTFSC  x9F.7
0A8A:  BRA    0A9C
0A8C:  BCF    FD8.0
0A8E:  RLCF   x9C,F
0A90:  RLCF   x9D,F
0A92:  RLCF   x9E,F
0A94:  RLCF   x9F,F
0A96:  DECFSZ 00,F
0A98:  BRA    0A88
0A9A:  BRA    0AD8
0A9C:  BTFSS  x9A.7
0A9E:  BRA    0AA4
0AA0:  BSF    x9F.7
0AA2:  BRA    0ACA
0AA4:  BCF    x9F.7
0AA6:  BRA    0ACA
0AA8:  MOVFF  95,00
0AAC:  MOVFF  96,9F
0AB0:  MOVFF  97,9E
0AB4:  MOVFF  98,9D
0AB8:  BRA    0ACA
0ABA:  MOVFF  91,00
0ABE:  MOVFF  92,9F
0AC2:  MOVFF  93,9E
0AC6:  MOVFF  94,9D
0ACA:  MOVFF  9F,01
0ACE:  MOVFF  9E,02
0AD2:  MOVFF  9D,03
0AD6:  BRA    0B40
0AD8:  CLRF   00
0ADA:  CLRF   01
0ADC:  CLRF   02
0ADE:  CLRF   03
0AE0:  BRA    0B40
0AE2:  CLRF   x9C
0AE4:  COMF   x9D,F
0AE6:  COMF   x9E,F
0AE8:  COMF   x9F,F
0AEA:  COMF   x9C,F
0AEC:  INCF   x9C,F
0AEE:  BNZ   0AFA
0AF0:  INCF   x9D,F
0AF2:  BNZ   0AFA
0AF4:  INCF   x9E,F
0AF6:  BNZ   0AFA
0AF8:  INCF   x9F,F
0AFA:  BTFSC  x9B.0
0AFC:  BRA    0928
0AFE:  BTFSC  x9B.1
0B00:  BRA    09AE
0B02:  BTFSC  x9B.2
0B04:  BRA    0A1A
0B06:  BRA    0A6E
0B08:  MOVF   FEF,W
0B0A:  ADDWF  x9D,F
0B0C:  BNC   0B18
0B0E:  INCF   x9E,F
0B10:  BNZ   0B18
0B12:  INCF   x9F,F
0B14:  BTFSC  FD8.2
0B16:  BSF    x99.0
0B18:  MOVF   FED,F
0B1A:  MOVF   FEF,W
0B1C:  ADDWF  x9E,F
0B1E:  BNC   0B26
0B20:  INCF   x9F,F
0B22:  BTFSC  FD8.2
0B24:  BSF    x99.0
0B26:  MOVF   FED,F
0B28:  MOVF   FEF,W
0B2A:  BTFSC  FEF.7
0B2C:  BRA    0B30
0B2E:  XORLW  80
0B30:  ADDWF  x9F,F
0B32:  BTFSC  FD8.0
0B34:  BSF    x99.0
0B36:  BTFSC  x9B.4
0B38:  BRA    0936
0B3A:  BTFSC  x9B.5
0B3C:  BRA    09BC
0B3E:  BRA    0A28
0B40:  RETURN 0
....................  
.................... #list 
....................  
.................... #device HIGH_INTS = TRUE 
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
*
034C:  CLRF   FEA
034E:  MOVLW  72
0350:  MOVWF  FE9
0352:  MOVF   FEF,W
0354:  BZ    0372
0356:  MOVLW  0F
0358:  MOVWF  01
035A:  CLRF   00
035C:  DECFSZ 00,F
035E:  BRA    035C
0360:  DECFSZ 01,F
0362:  BRA    035A
0364:  MOVLW  8F
0366:  MOVWF  00
0368:  DECFSZ 00,F
036A:  BRA    0368
036C:  NOP   
036E:  DECFSZ FEF,F
0370:  BRA    0356
0372:  RETURN 0
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
0374:  MOVLW  08
0376:  MOVWF  01
0378:  MOVLW  11
037A:  MOVWF  00
037C:  DECFSZ 00,F
037E:  BRA    037C
0380:  BCF    F8C.7
0382:  BCF    F95.7
0384:  MOVLW  11
0386:  MOVWF  00
0388:  DECFSZ 00,F
038A:  BRA    0388
038C:  RLCF   x76,F
038E:  BCF    F8C.6
0390:  BTFSC  FD8.0
0392:  BSF    F95.6
0394:  BTFSS  FD8.0
0396:  BCF    F95.6
0398:  BSF    F95.7
039A:  BTFSS  F83.7
039C:  BRA    039A
039E:  DECFSZ 01,F
03A0:  BRA    0378
03A2:  MOVLW  11
03A4:  MOVWF  00
03A6:  DECFSZ 00,F
03A8:  BRA    03A6
03AA:  BCF    F8C.7
03AC:  BCF    F95.7
03AE:  NOP   
03B0:  BSF    F95.6
03B2:  MOVLW  11
03B4:  MOVWF  00
03B6:  DECFSZ 00,F
03B8:  BRA    03B6
03BA:  MOVLW  11
03BC:  MOVWF  00
03BE:  DECFSZ 00,F
03C0:  BRA    03BE
03C2:  BSF    F95.7
03C4:  BTFSS  F83.7
03C6:  BRA    03C4
03C8:  CLRF   01
03CA:  MOVLW  11
03CC:  MOVWF  00
03CE:  DECFSZ 00,F
03D0:  BRA    03CE
03D2:  BTFSC  F83.6
03D4:  BSF    01.0
03D6:  BCF    F8C.7
03D8:  BCF    F95.7
03DA:  BCF    F8C.6
03DC:  BCF    F95.6
03DE:  RETURN 0
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
*
1B1E:  CLRF   19
1B20:  CLRF   1A
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
*
1B44:  CLRF   26
1B46:  MOVF   FC1,W
1B48:  ANDLW  C0
1B4A:  IORLW  0F
1B4C:  MOVWF  FC1
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
....................         delay_us(20); 
....................         i2c_write(LCD_ADDR); //the slave addresse 
....................         delay_us(20); 
....................         i2c_write(data); 
....................         delay_us(20); 
....................         i2c_stop(); 
....................         delay_us(20); 
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
....................         i2c_send_nibble(data); 
....................         data=data-4;       //toggle EN back to 0 
....................         i2c_send_nibble(data); 
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
....................     lcd_send_byte(0x10); 
....................     delay_ms(2); 
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x30); 
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x20); 
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
....................         lcd_send_byte(0x80); 
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0xC0); 
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x60); 
....................            //clears the display 
....................         lcd_clear(); 
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
*
1B22:  CLRF   21
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
....................       case 2:  address= lcd_line_two;     break; 
....................       case 3:  address= lcd_line_three;   break; 
....................       case 4:  address= lcd_line_four;    break; 
....................       default: address= lcd_line_one;     break;  
....................    } 
....................   
....................    address+=x-1; 
....................    data=address&0xF0; 
....................    lcd_send_byte(data); 
....................    data=address&0x0F; 
....................    data=data<<4; 
....................    lcd_send_byte(data); 
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
....................      case '\1': lcd_gotoxy(1,1);  break; 
....................      case '\2': lcd_gotoxy(1,2);  break; 
....................      case '\3': lcd_gotoxy(1,3);  break; 
....................      case '\4': lcd_gotoxy(1,4);  break; 
....................  
....................      default: 
....................         data=in_data&0xF0; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................         data=in_data&0x0F; 
....................         data=data<<4; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................      break; 
....................    } 
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
....................  
.................... const long carga= 0xE877; 
.................... extern int contador; 
.................... extern long pulso_timer; 
....................  
.................... void inicializar(); 
....................  
.................... void main() 
*
1B0A:  CLRF   FF8
1B0C:  BSF    F9F.0
1B0E:  BCF    FF0.6
1B10:  BSF    FD0.7
1B12:  BSF    07.7
1B14:  BSF    20.0
1B16:  CLRF   24
1B18:  CLRF   23
1B1A:  BSF    20.0
1B1C:  BSF    20.0
*
1B24:  CLRF   22
1B26:  CLRF   25
1B28:  BSF    20.0
1B2A:  MOVLW  14
1B2C:  MOVWF  38
1B2E:  CLRF   58
1B30:  CLRF   57
1B32:  CLRF   56
1B34:  CLRF   55
1B36:  CLRF   5C
1B38:  CLRF   5B
1B3A:  CLRF   5A
1B3C:  CLRF   59
1B3E:  CLRF   x62
1B40:  CLRF   24
1B42:  CLRF   23
*
1B4E:  MOVLW  07
1B50:  MOVWF  FB4
.................... { 
....................  
.................... //declaracion de variables 
.................... //inicializacion de perifericos 
....................  
.................... 	inicializar() ; 
1B52:  GOTO   05D0
....................      
....................     set_timer1(carga); 
1B56:  MOVLW  E8
1B58:  MOVWF  FCF
1B5A:  MOVLW  77
1B5C:  MOVWF  FCE
.................... 	while(1) 
.................... 	{ 
....................  
.................... 		maquina_estado(); 
1B5E:  GOTO   12D4
1B62:  BRA    1B5E
....................  
.................... 	} 
.................... } 
....................  
1B64:  SLEEP 
.................... void Inicializar(){ 
....................     setup_timer_1( T1_INTERNAL|T1_DIV_BY_2); 
*
05D0:  MOVLW  95
05D2:  MOVWF  FCD
....................     setup_timer_0(T0_INTERNAL |T0_DIV_32); 
05D4:  MOVLW  84
05D6:  MOVWF  FD5
....................     set_timer0(0x0000); 
05D8:  CLRF   FD7
05DA:  CLRF   FD6
....................     set_tris_a(0xE8);// configuracion portA necesaria para la libreria control_ADC 
05DC:  MOVLW  E8
05DE:  MOVWF  F92
....................     set_tris_b(0xFE); 
05E0:  MOVLW  FE
05E2:  MOVWF  F93
....................     contador=0; 
05E4:  CLRF   22
....................  
....................     lcd_init(); 
05E6:  BRA    048E
....................     lcd_gotoxy(1,1); 
05E8:  MOVLW  01
05EA:  MOVWF  x72
05EC:  MOVWF  x73
05EE:  RCALL  04EA
....................     printf(LCD_PUTC,"Primer prueba"); 
05F0:  MOVLW  BE
05F2:  MOVWF  FF6
05F4:  MOVLW  00
05F6:  MOVWF  FF7
05F8:  BRA    05AE
....................     lcd_backlight=ON; 
05FA:  BSF    20.0
....................     enable_interrupts (INT_TIMER1); 
05FC:  BSF    F9D.0
....................     enable_interrupts (INT_EXT1); 
05FE:  BSF    FF0.3
....................     //ext_int_edge(L_TO_H); //configura interrupcion RB0 control de pantalla 
....................     enable_interrupts (GLOBAL); 
0600:  MOVLW  C0
0602:  IORWF  FF2,F
....................     output_high (PIN_A0); //pone en alto el chipselect del AD7450 
0604:  BSF    F89.0
....................     output_high (PIN_A1); // pone en alto el chipselect del MAX186 
0606:  BSF    F89.1
0608:  GOTO   1B56 (RETURN)
.................... } 
....................  
....................  
.................... /** 
.................... *	\file funciones.c 
.................... *	\brief  
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
0272:  DATA 20,20
0274:  DATA 45,4E
0276:  DATA 45,52
0278:  DATA 47,49
027A:  DATA 41,20
027C:  DATA 6B,57
027E:  DATA 68,20
0280:  DATA 20,20
0282:  DATA 00,00
0284:  DATA 25,66
0286:  DATA 20,6B
0288:  DATA 57,68
028A:  DATA 20,20
028C:  DATA 20,20
028E:  DATA 20,20
0290:  DATA 20,20
0292:  DATA 20,20
0294:  DATA 20,20
0296:  DATA 20,20
0298:  DATA 20,20
029A:  DATA 20,20
029C:  DATA 20,00
029E:  DATA 20,20
02A0:  DATA 20,45
02A2:  DATA 4E,45
02A4:  DATA 52,47
02A6:  DATA 49,41
02A8:  DATA 20,57
02AA:  DATA 68,20
02AC:  DATA 20,20
02AE:  DATA 20,00
02B0:  DATA 25,66
02B2:  DATA 20,57
02B4:  DATA 68,20
02B6:  DATA 20,20
02B8:  DATA 20,20
02BA:  DATA 20,20
02BC:  DATA 20,20
02BE:  DATA 20,20
02C0:  DATA 20,20
02C2:  DATA 20,20
02C4:  DATA 20,20
02C6:  DATA 00,00
02C8:  DATA 20,20
02CA:  DATA 20,54
02CC:  DATA 65,6E
02CE:  DATA 73,69
02D0:  DATA 6F,6E
02D2:  DATA 20,52
02D4:  DATA 4D,53
02D6:  DATA 20,20
02D8:  DATA 00,00
02DA:  DATA 25,66
02DC:  DATA 20,56
02DE:  DATA 20,20
02E0:  DATA 20,20
02E2:  DATA 20,20
02E4:  DATA 20,20
02E6:  DATA 20,20
02E8:  DATA 20,20
02EA:  DATA 20,20
02EC:  DATA 20,20
02EE:  DATA 20,20
02F0:  DATA 00,00
02F2:  DATA 20,43
02F4:  DATA 6F,72
02F6:  DATA 72,69
02F8:  DATA 65,6E
02FA:  DATA 74,65
02FC:  DATA 20,52
02FE:  DATA 4D,53
0300:  DATA 20,20
0302:  DATA 00,00
0304:  DATA 25,66
0306:  DATA 20,41
0308:  DATA 20,20
030A:  DATA 20,20
030C:  DATA 20,20
030E:  DATA 20,20
0310:  DATA 20,20
0312:  DATA 20,20
0314:  DATA 20,20
0316:  DATA 20,20
0318:  DATA 20,20
031A:  DATA 00,00
031C:  DATA 46,61
031E:  DATA 63,74
0320:  DATA 6F,72
0322:  DATA 20,70
0324:  DATA 6F,74
0326:  DATA 65,6E
0328:  DATA 63,69
032A:  DATA 61,20
032C:  DATA 00,00
032E:  DATA 43,6F
0330:  DATA 73,28
0332:  DATA 66,69
0334:  DATA 29,3D
0336:  DATA 25,66
0338:  DATA 20,20
033A:  DATA 20,20
033C:  DATA 20,20
033E:  DATA 20,20
0340:  DATA 20,20
0342:  DATA 20,20
0344:  DATA 20,20
0346:  DATA 20,20
0348:  DATA 20,20
034A:  DATA 20,00
*
060C:  MOVLW  8E
060E:  MOVWF  00
0610:  MOVFF  64,01
0614:  MOVFF  63,02
0618:  CLRF   03
061A:  BTFSS  x64.7
061C:  BRA    0628
061E:  COMF   01,F
0620:  COMF   02,F
0622:  INCF   02,F
0624:  BNZ   0628
0626:  INCF   01,F
0628:  MOVF   01,F
062A:  BNZ   063E
062C:  MOVFF  02,01
0630:  CLRF   02
0632:  MOVLW  08
0634:  SUBWF  00,F
0636:  MOVF   01,F
0638:  BNZ   063E
063A:  CLRF   00
063C:  BRA    0652
063E:  BCF    FD8.0
0640:  BTFSC  01.7
0642:  BRA    064C
0644:  RLCF   02,F
0646:  RLCF   01,F
0648:  DECF   00,F
064A:  BRA    063E
064C:  BTFSC  x64.7
064E:  BRA    0652
0650:  BCF    01.7
0652:  GOTO   1304 (RETURN)
*
0B42:  MOVFF  8E,95
0B46:  MOVF   x92,W
0B48:  XORWF  x95,F
0B4A:  BTFSS  x95.7
0B4C:  BRA    0B58
0B4E:  BCF    FD8.2
0B50:  BCF    FD8.0
0B52:  BTFSC  x8E.7
0B54:  BSF    FD8.0
0B56:  BRA    0BB6
0B58:  MOVFF  8E,95
0B5C:  MOVFF  91,96
0B60:  MOVF   x8D,W
0B62:  SUBWF  x96,F
0B64:  BZ    0B72
0B66:  BTFSS  x95.7
0B68:  BRA    0BB6
0B6A:  MOVF   FD8,W
0B6C:  XORLW  01
0B6E:  MOVWF  FD8
0B70:  BRA    0BB6
0B72:  MOVFF  92,96
0B76:  MOVF   x8E,W
0B78:  SUBWF  x96,F
0B7A:  BZ    0B88
0B7C:  BTFSS  x95.7
0B7E:  BRA    0BB6
0B80:  MOVF   FD8,W
0B82:  XORLW  01
0B84:  MOVWF  FD8
0B86:  BRA    0BB6
0B88:  MOVFF  93,96
0B8C:  MOVF   x8F,W
0B8E:  SUBWF  x96,F
0B90:  BZ    0B9E
0B92:  BTFSS  x95.7
0B94:  BRA    0BB6
0B96:  MOVF   FD8,W
0B98:  XORLW  01
0B9A:  MOVWF  FD8
0B9C:  BRA    0BB6
0B9E:  MOVFF  94,96
0BA2:  MOVF   x90,W
0BA4:  SUBWF  x96,F
0BA6:  BZ    0BB4
0BA8:  BTFSS  x95.7
0BAA:  BRA    0BB6
0BAC:  MOVF   FD8,W
0BAE:  XORLW  01
0BB0:  MOVWF  FD8
0BB2:  BRA    0BB6
0BB4:  BCF    FD8.0
0BB6:  RETURN 0
*
0CC2:  MOVLW  8E
0CC4:  MOVWF  00
0CC6:  MOVF   x8D,W
0CC8:  SUBWF  00,F
0CCA:  MOVFF  8E,02
0CCE:  MOVFF  8F,01
0CD2:  BSF    02.7
0CD4:  MOVF   00,F
0CD6:  BZ    0CEA
0CD8:  BCF    FD8.0
0CDA:  MOVF   02,F
0CDC:  BNZ   0CE2
0CDE:  MOVF   01,F
0CE0:  BZ    0CEA
0CE2:  RRCF   02,F
0CE4:  RRCF   01,F
0CE6:  DECFSZ 00,F
0CE8:  BRA    0CD8
0CEA:  BTFSS  x8E.7
0CEC:  BRA    0CF8
0CEE:  COMF   01,F
0CF0:  COMF   02,F
0CF2:  INCF   01,F
0CF4:  BTFSC  FD8.2
0CF6:  INCF   02,F
0CF8:  GOTO   0DA8 (RETURN)
*
1042:  TBLRD*+
1044:  MOVF   FF5,F
1046:  BZ    1062
1048:  MOVFF  FF6,63
104C:  MOVFF  FF7,64
1050:  MOVFF  FF5,71
1054:  CALL   0540
1058:  MOVFF  63,FF6
105C:  MOVFF  64,FF7
1060:  BRA    1042
1062:  RETURN 0
1064:  MOVF   x70,W
1066:  SUBLW  B6
1068:  MOVWF  x70
106A:  CLRF   03
106C:  MOVFF  71,74
1070:  BSF    x71.7
1072:  BCF    FD8.0
1074:  RRCF   x71,F
1076:  RRCF   x72,F
1078:  RRCF   x73,F
107A:  RRCF   03,F
107C:  RRCF   02,F
107E:  RRCF   01,F
1080:  RRCF   00,F
1082:  DECFSZ x70,F
1084:  BRA    1072
1086:  BTFSS  x74.7
1088:  BRA    10A0
108A:  COMF   00,F
108C:  COMF   01,F
108E:  COMF   02,F
1090:  COMF   03,F
1092:  INCF   00,F
1094:  BTFSC  FD8.2
1096:  INCF   01,F
1098:  BTFSC  FD8.2
109A:  INCF   02,F
109C:  BTFSC  FD8.2
109E:  INCF   03,F
10A0:  GOTO   1182 (RETURN)
10A4:  BTFSC  FD8.1
10A6:  BRA    10AE
10A8:  CLRF   FEA
10AA:  MOVLW  78
10AC:  MOVWF  FE9
10AE:  CLRF   00
10B0:  CLRF   01
10B2:  CLRF   02
10B4:  CLRF   03
10B6:  CLRF   x78
10B8:  CLRF   x79
10BA:  CLRF   x7A
10BC:  CLRF   x7B
10BE:  MOVF   x77,W
10C0:  IORWF  x76,W
10C2:  IORWF  x75,W
10C4:  IORWF  x74,W
10C6:  BZ    1120
10C8:  MOVLW  20
10CA:  MOVWF  x7C
10CC:  BCF    FD8.0
10CE:  RLCF   x70,F
10D0:  RLCF   x71,F
10D2:  RLCF   x72,F
10D4:  RLCF   x73,F
10D6:  RLCF   x78,F
10D8:  RLCF   x79,F
10DA:  RLCF   x7A,F
10DC:  RLCF   x7B,F
10DE:  MOVF   x77,W
10E0:  SUBWF  x7B,W
10E2:  BNZ   10F4
10E4:  MOVF   x76,W
10E6:  SUBWF  x7A,W
10E8:  BNZ   10F4
10EA:  MOVF   x75,W
10EC:  SUBWF  x79,W
10EE:  BNZ   10F4
10F0:  MOVF   x74,W
10F2:  SUBWF  x78,W
10F4:  BNC   1114
10F6:  MOVF   x74,W
10F8:  SUBWF  x78,F
10FA:  MOVF   x75,W
10FC:  BTFSS  FD8.0
10FE:  INCFSZ x75,W
1100:  SUBWF  x79,F
1102:  MOVF   x76,W
1104:  BTFSS  FD8.0
1106:  INCFSZ x76,W
1108:  SUBWF  x7A,F
110A:  MOVF   x77,W
110C:  BTFSS  FD8.0
110E:  INCFSZ x77,W
1110:  SUBWF  x7B,F
1112:  BSF    FD8.0
1114:  RLCF   00,F
1116:  RLCF   01,F
1118:  RLCF   02,F
111A:  RLCF   03,F
111C:  DECFSZ x7C,F
111E:  BRA    10CC
1120:  MOVFF  78,FEF
1124:  MOVFF  79,FEC
1128:  MOVFF  7A,FEC
112C:  MOVFF  7B,FEC
1130:  RETURN 0
1132:  MOVF   FE9,W
1134:  MOVWF  x68
1136:  MOVF   x67,W
1138:  MOVWF  x6A
113A:  BZ    1170
113C:  MOVFF  66,94
1140:  MOVFF  65,93
1144:  MOVFF  64,92
1148:  MOVFF  63,91
114C:  CLRF   x98
114E:  CLRF   x97
1150:  MOVLW  20
1152:  MOVWF  x96
1154:  MOVLW  82
1156:  MOVWF  x95
1158:  CALL   068C
115C:  MOVFF  03,66
1160:  MOVFF  02,65
1164:  MOVFF  01,64
1168:  MOVFF  00,63
116C:  DECFSZ x6A,F
116E:  BRA    113C
1170:  MOVFF  66,73
1174:  MOVFF  65,72
1178:  MOVFF  64,71
117C:  MOVFF  63,70
1180:  BRA    1064
1182:  MOVFF  03,66
1186:  MOVFF  02,65
118A:  MOVFF  01,64
118E:  MOVFF  00,63
1192:  BTFSS  x66.7
1194:  BRA    11B0
1196:  DECF   x68,F
1198:  BSF    x68.5
119A:  COMF   x63,F
119C:  COMF   x64,F
119E:  COMF   x65,F
11A0:  COMF   x66,F
11A2:  INCF   x63,F
11A4:  BTFSC  FD8.2
11A6:  INCF   x64,F
11A8:  BTFSC  FD8.2
11AA:  INCF   x65,F
11AC:  BTFSC  FD8.2
11AE:  INCF   x66,F
11B0:  MOVLW  3B
11B2:  MOVWF  x6F
11B4:  MOVLW  9A
11B6:  MOVWF  x6E
11B8:  MOVLW  CA
11BA:  MOVWF  x6D
11BC:  CLRF   x6C
11BE:  MOVLW  0A
11C0:  MOVWF  x6A
11C2:  MOVF   x67,W
11C4:  BTFSC  FD8.2
11C6:  INCF   x68,F
11C8:  BSF    FD8.1
11CA:  CLRF   FEA
11CC:  MOVLW  63
11CE:  MOVWF  FE9
11D0:  MOVFF  66,73
11D4:  MOVFF  65,72
11D8:  MOVFF  64,71
11DC:  MOVFF  63,70
11E0:  MOVFF  6F,77
11E4:  MOVFF  6E,76
11E8:  MOVFF  6D,75
11EC:  MOVFF  6C,74
11F0:  RCALL  10A4
11F2:  MOVF   01,W
11F4:  MOVF   00,F
11F6:  BNZ   1216
11F8:  INCF   x67,W
11FA:  SUBWF  x6A,W
11FC:  BZ    1216
11FE:  MOVF   x68,W
1200:  BZ    121A
1202:  ANDLW  0F
1204:  SUBWF  x6A,W
1206:  BZ    120A
1208:  BC    1280
120A:  BTFSC  x68.7
120C:  BRA    1280
120E:  BTFSC  x68.6
1210:  BRA    121A
1212:  MOVLW  20
1214:  BRA    1276
1216:  MOVLW  20
1218:  ANDWF  x68,F
121A:  BTFSS  x68.5
121C:  BRA    1238
121E:  BCF    x68.5
1220:  MOVF   x67,W
1222:  BTFSS  FD8.2
1224:  DECF   x68,F
1226:  MOVF   00,W
1228:  MOVWF  x68
122A:  MOVLW  2D
122C:  MOVWF  x71
122E:  CALL   0540
1232:  MOVF   x68,W
1234:  MOVWF  00
1236:  CLRF   x68
1238:  MOVF   x67,W
123A:  SUBWF  x6A,W
123C:  BNZ   1254
123E:  MOVF   00,W
1240:  MOVWF  x68
1242:  MOVLW  2E
1244:  MOVWF  x71
1246:  CALL   0540
124A:  MOVF   x68,W
124C:  MOVWF  00
124E:  MOVLW  20
1250:  ANDWF  x68,F
1252:  MOVLW  00
1254:  MOVLW  30
1256:  BTFSS  x68.5
1258:  BRA    1276
125A:  BCF    x68.5
125C:  MOVF   x67,W
125E:  BTFSS  FD8.2
1260:  DECF   x68,F
1262:  MOVF   00,W
1264:  MOVWF  x68
1266:  MOVLW  2D
1268:  MOVWF  x71
126A:  CALL   0540
126E:  MOVF   x68,W
1270:  MOVWF  00
1272:  CLRF   x68
1274:  MOVLW  30
1276:  ADDWF  00,F
1278:  MOVFF  00,71
127C:  CALL   0540
1280:  BCF    FD8.1
1282:  MOVFF  6F,73
1286:  MOVFF  6E,72
128A:  MOVFF  6D,71
128E:  MOVFF  6C,70
1292:  CLRF   x77
1294:  CLRF   x76
1296:  CLRF   x75
1298:  MOVLW  0A
129A:  MOVWF  x74
129C:  RCALL  10A4
129E:  MOVFF  03,6F
12A2:  MOVFF  02,6E
12A6:  MOVFF  01,6D
12AA:  MOVFF  00,6C
12AE:  DECFSZ x6A,F
12B0:  BRA    11C8
12B2:  RETURN 0
12B4:  TBLRD*+
12B6:  MOVFF  FF6,64
12BA:  MOVFF  FF7,65
12BE:  MOVFF  FF5,71
12C2:  CALL   0540
12C6:  MOVFF  64,FF6
12CA:  MOVFF  65,FF7
12CE:  DECFSZ x63,F
12D0:  BRA    12B4
12D2:  RETURN 0
*
1AE6:  ADDWF  FE8,W
1AE8:  CLRF   FF7
1AEA:  RLCF   FF7,F
1AEC:  ADDLW  01
1AEE:  MOVWF  FF6
1AF0:  MOVLW  1B
1AF2:  ADDWFC FF7,F
1AF4:  TBLRD*-
1AF6:  MOVF   FF5,W
1AF8:  MOVWF  FFA
1AFA:  TBLRD*
1AFC:  MOVF   FF5,W
1AFE:  MOVWF  FF9
1B00:  DATA 28,19
1B02:  DATA 76,19
1B04:  DATA C4,19
1B06:  DATA 12,1A
1B08:  DATA 60,1A
....................  
.................... #list 
....................  
.................... #device HIGH_INTS = TRUE 
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
.................... int contador = 0 ;int pulso_timer = 0 ; 
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
0BB8:  MOVFF  6A,90
0BBC:  MOVFF  69,8F
0BC0:  MOVFF  68,8E
0BC4:  MOVFF  67,8D
0BC8:  CLRF   x94
0BCA:  CLRF   x93
0BCC:  CLRF   x92
0BCE:  CLRF   x91
0BD0:  RCALL  0B42
0BD2:  BC    0BD6
0BD4:  BNZ   0BE0
....................       return(0.0); 
0BD6:  CLRF   00
0BD8:  CLRF   01
0BDA:  CLRF   02
0BDC:  CLRF   03
0BDE:  BRA    0CC0
....................  
....................    y=x; 
0BE0:  MOVFF  6A,6E
0BE4:  MOVFF  69,6D
0BE8:  MOVFF  68,6C
0BEC:  MOVFF  67,6B
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
0BF0:  CLRF   x74
0BF2:  MOVLW  6B
0BF4:  MOVWF  x73
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
0BF6:  MOVFF  73,FE9
0BFA:  MOVFF  74,FEA
0BFE:  MOVF   FEF,W
0C00:  CLRF   x78
0C02:  MOVWF  x77
0C04:  MOVLW  7F
0C06:  ADDWF  x77,F
0C08:  MOVLW  00
0C0A:  ADDWFC x78,F
0C0C:  BCF    FD8.0
0C0E:  RRCF   x78,W
0C10:  RRCF   x77,W
0C12:  MOVFF  74,FEA
0C16:  MOVFF  73,FE9
0C1A:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0C1C:  MOVFF  6E,72
0C20:  MOVFF  6D,71
0C24:  MOVFF  6C,70
0C28:  MOVFF  6B,6F
....................       y+=(x/y); 
0C2C:  MOVFF  6A,78
0C30:  MOVFF  69,77
0C34:  MOVFF  68,76
0C38:  MOVFF  67,75
0C3C:  MOVFF  6E,7C
0C40:  MOVFF  6D,7B
0C44:  MOVFF  6C,7A
0C48:  MOVFF  6B,79
0C4C:  RCALL  077E
0C4E:  BCF    FD8.1
0C50:  MOVFF  6E,94
0C54:  MOVFF  6D,93
0C58:  MOVFF  6C,92
0C5C:  MOVFF  6B,91
0C60:  MOVFF  03,98
0C64:  MOVFF  02,97
0C68:  MOVFF  01,96
0C6C:  MOVFF  00,95
0C70:  RCALL  08D8
0C72:  MOVFF  03,6E
0C76:  MOVFF  02,6D
0C7A:  MOVFF  01,6C
0C7E:  MOVFF  00,6B
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
0C82:  MOVFF  73,FE9
0C86:  MOVFF  74,FEA
0C8A:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
0C8C:  MOVFF  72,90
0C90:  MOVFF  71,8F
0C94:  MOVFF  70,8E
0C98:  MOVFF  6F,8D
0C9C:  MOVFF  6E,94
0CA0:  MOVFF  6D,93
0CA4:  MOVFF  6C,92
0CA8:  MOVFF  6B,91
0CAC:  RCALL  0B42
0CAE:  BNZ   0C1C
....................  
....................    return(res); 
0CB0:  MOVFF  6F,00
0CB4:  MOVFF  70,01
0CB8:  MOVFF  71,02
0CBC:  MOVFF  72,03
0CC0:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
0CFC:  CLRF   x72
0CFE:  CLRF   x71
0D00:  CLRF   x70
0D02:  MOVLW  7F
0D04:  MOVWF  x6F
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
0D06:  MOVLW  7E
0D08:  MOVWF  x79
0D0A:  MOVLW  80
0D0C:  MOVWF  x7A
0D0E:  CLRF   x7B
0D10:  CLRF   x7C
0D12:  MOVLW  7A
0D14:  MOVWF  x7D
0D16:  MOVLW  2A
0D18:  MOVWF  x7E
0D1A:  MOVLW  AA
0D1C:  MOVWF  x7F
0D1E:  MOVLW  A3
0D20:  MOVWF  x80
0D22:  MOVLW  75
0D24:  MOVWF  x81
0D26:  MOVLW  B6
0D28:  MOVWF  x82
0D2A:  MOVLW  09
0D2C:  MOVWF  x83
0D2E:  MOVLW  B4
0D30:  MOVWF  x84
0D32:  MOVLW  6F
0D34:  MOVWF  x85
0D36:  MOVLW  4F
0D38:  MOVWF  x86
0D3A:  MOVLW  B6
0D3C:  MOVWF  x87
0D3E:  MOVLW  AA
0D40:  MOVWF  x88
0D42:  MOVLW  69
0D44:  MOVWF  x89
0D46:  MOVLW  8B
0D48:  MOVWF  x8A
0D4A:  MOVLW  F6
0D4C:  MOVWF  x8B
0D4E:  MOVLW  E8
0D50:  MOVWF  x8C
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0D52:  MOVFF  66,90
0D56:  MOVFF  65,8F
0D5A:  MOVFF  64,8E
0D5E:  MOVFF  63,8D
0D62:  CLRF   x94
0D64:  CLRF   x93
0D66:  CLRF   x92
0D68:  CLRF   x91
0D6A:  RCALL  0B42
0D6C:  BNC   0D74
0D6E:  MOVF   x64,W
0D70:  XORLW  80
0D72:  MOVWF  x64
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0D74:  MOVFF  66,94
0D78:  MOVFF  65,93
0D7C:  MOVFF  64,92
0D80:  MOVFF  63,91
0D84:  MOVLW  83
0D86:  MOVWF  x98
0D88:  MOVLW  F9
0D8A:  MOVWF  x97
0D8C:  MOVLW  22
0D8E:  MOVWF  x96
0D90:  MOVLW  7E
0D92:  MOVWF  x95
0D94:  RCALL  068C
0D96:  MOVFF  03,90
0D9A:  MOVFF  02,8F
0D9E:  MOVFF  01,8E
0DA2:  MOVFF  00,8D
0DA6:  BRA    0CC2
0DA8:  MOVFF  01,73
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0DAC:  MOVFF  66,94
0DB0:  MOVFF  65,93
0DB4:  MOVFF  64,92
0DB8:  MOVFF  63,91
0DBC:  MOVLW  83
0DBE:  MOVWF  x98
0DC0:  MOVLW  F9
0DC2:  MOVWF  x97
0DC4:  MOVLW  22
0DC6:  MOVWF  x96
0DC8:  MOVLW  7E
0DCA:  MOVWF  x95
0DCC:  RCALL  068C
0DCE:  MOVFF  03,90
0DD2:  MOVFF  02,8F
0DD6:  MOVFF  01,8E
0DDA:  MOVFF  00,8D
0DDE:  CLRF   x92
0DE0:  MOVFF  73,91
0DE4:  RCALL  0656
0DE6:  BSF    FD8.1
0DE8:  MOVFF  90,94
0DEC:  MOVFF  8F,93
0DF0:  MOVFF  8E,92
0DF4:  MOVFF  8D,91
0DF8:  MOVFF  03,98
0DFC:  MOVFF  02,97
0E00:  MOVFF  01,96
0E04:  MOVFF  00,95
0E08:  RCALL  08D8
0E0A:  MOVFF  03,78
0E0E:  MOVFF  02,77
0E12:  MOVFF  01,76
0E16:  MOVFF  00,75
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0E1A:  MOVLW  03
0E1C:  ANDWF  x73,F
....................  
....................    if (quad == 0 || quad == 2) 
0E1E:  MOVF   x73,F
0E20:  BZ    0E28
0E22:  MOVF   x73,W
0E24:  SUBLW  02
0E26:  BNZ   0E5C
....................       t = frac * PI_DIV_BY_TWO; 
0E28:  MOVFF  78,94
0E2C:  MOVFF  77,93
0E30:  MOVFF  76,92
0E34:  MOVFF  75,91
0E38:  MOVLW  DB
0E3A:  MOVWF  x98
0E3C:  MOVLW  0F
0E3E:  MOVWF  x97
0E40:  MOVLW  49
0E42:  MOVWF  x96
0E44:  MOVLW  7F
0E46:  MOVWF  x95
0E48:  RCALL  068C
0E4A:  MOVFF  03,6E
0E4E:  MOVFF  02,6D
0E52:  MOVFF  01,6C
0E56:  MOVFF  00,6B
0E5A:  BRA    0F26
....................    else if (quad == 1) 
0E5C:  DECFSZ x73,W
0E5E:  BRA    0EC4
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0E60:  BSF    FD8.1
0E62:  CLRF   x94
0E64:  CLRF   x93
0E66:  CLRF   x92
0E68:  MOVLW  7F
0E6A:  MOVWF  x91
0E6C:  MOVFF  78,98
0E70:  MOVFF  77,97
0E74:  MOVFF  76,96
0E78:  MOVFF  75,95
0E7C:  RCALL  08D8
0E7E:  MOVFF  03,90
0E82:  MOVFF  02,8F
0E86:  MOVFF  01,8E
0E8A:  MOVFF  00,8D
0E8E:  MOVFF  03,94
0E92:  MOVFF  02,93
0E96:  MOVFF  01,92
0E9A:  MOVFF  00,91
0E9E:  MOVLW  DB
0EA0:  MOVWF  x98
0EA2:  MOVLW  0F
0EA4:  MOVWF  x97
0EA6:  MOVLW  49
0EA8:  MOVWF  x96
0EAA:  MOVLW  7F
0EAC:  MOVWF  x95
0EAE:  CALL   068C
0EB2:  MOVFF  03,6E
0EB6:  MOVFF  02,6D
0EBA:  MOVFF  01,6C
0EBE:  MOVFF  00,6B
0EC2:  BRA    0F26
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0EC4:  BSF    FD8.1
0EC6:  MOVFF  78,94
0ECA:  MOVFF  77,93
0ECE:  MOVFF  76,92
0ED2:  MOVFF  75,91
0ED6:  CLRF   x98
0ED8:  CLRF   x97
0EDA:  CLRF   x96
0EDC:  MOVLW  7F
0EDE:  MOVWF  x95
0EE0:  RCALL  08D8
0EE2:  MOVFF  03,90
0EE6:  MOVFF  02,8F
0EEA:  MOVFF  01,8E
0EEE:  MOVFF  00,8D
0EF2:  MOVFF  03,94
0EF6:  MOVFF  02,93
0EFA:  MOVFF  01,92
0EFE:  MOVFF  00,91
0F02:  MOVLW  DB
0F04:  MOVWF  x98
0F06:  MOVLW  0F
0F08:  MOVWF  x97
0F0A:  MOVLW  49
0F0C:  MOVWF  x96
0F0E:  MOVLW  7F
0F10:  MOVWF  x95
0F12:  CALL   068C
0F16:  MOVFF  03,6E
0F1A:  MOVFF  02,6D
0F1E:  MOVFF  01,6C
0F22:  MOVFF  00,6B
....................  
....................    y = 1.0; 
0F26:  CLRF   x6A
0F28:  CLRF   x69
0F2A:  CLRF   x68
0F2C:  MOVLW  7F
0F2E:  MOVWF  x67
....................    t = t * t; 
0F30:  MOVFF  6E,94
0F34:  MOVFF  6D,93
0F38:  MOVFF  6C,92
0F3C:  MOVFF  6B,91
0F40:  MOVFF  6E,98
0F44:  MOVFF  6D,97
0F48:  MOVFF  6C,96
0F4C:  MOVFF  6B,95
0F50:  CALL   068C
0F54:  MOVFF  03,6E
0F58:  MOVFF  02,6D
0F5C:  MOVFF  01,6C
0F60:  MOVFF  00,6B
....................    for (i = 0; i <= 4; i++) 
0F64:  CLRF   x74
0F66:  MOVF   x74,W
0F68:  SUBLW  04
0F6A:  BNC   101E
....................    { 
....................       t2 = t2 * t; 
0F6C:  MOVFF  72,94
0F70:  MOVFF  71,93
0F74:  MOVFF  70,92
0F78:  MOVFF  6F,91
0F7C:  MOVFF  6E,98
0F80:  MOVFF  6D,97
0F84:  MOVFF  6C,96
0F88:  MOVFF  6B,95
0F8C:  CALL   068C
0F90:  MOVFF  03,72
0F94:  MOVFF  02,71
0F98:  MOVFF  01,70
0F9C:  MOVFF  00,6F
....................       y = y + p[i] * t2; 
0FA0:  MOVF   x74,W
0FA2:  MULLW  04
0FA4:  MOVF   FF3,W
0FA6:  CLRF   03
0FA8:  ADDLW  79
0FAA:  MOVWF  FE9
0FAC:  MOVLW  00
0FAE:  ADDWFC 03,W
0FB0:  MOVWF  FEA
0FB2:  MOVFF  FEF,91
0FB6:  MOVFF  FEC,92
0FBA:  MOVFF  FEC,93
0FBE:  MOVFF  FEC,94
0FC2:  MOVFF  72,98
0FC6:  MOVFF  71,97
0FCA:  MOVFF  70,96
0FCE:  MOVFF  6F,95
0FD2:  CALL   068C
0FD6:  MOVFF  FEA,8E
0FDA:  MOVFF  FE9,8D
0FDE:  BCF    FD8.1
0FE0:  MOVFF  6A,94
0FE4:  MOVFF  69,93
0FE8:  MOVFF  68,92
0FEC:  MOVFF  67,91
0FF0:  MOVFF  03,98
0FF4:  MOVFF  02,97
0FF8:  MOVFF  01,96
0FFC:  MOVFF  00,95
1000:  RCALL  08D8
1002:  MOVFF  8E,FEA
1006:  MOVFF  8D,FE9
100A:  MOVFF  03,6A
100E:  MOVFF  02,69
1012:  MOVFF  01,68
1016:  MOVFF  00,67
101A:  INCF   x74,F
101C:  BRA    0F66
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
101E:  MOVF   x73,W
1020:  SUBLW  02
1022:  BZ    1028
1024:  DECFSZ x73,W
1026:  BRA    102E
....................       y = -y;  // correct sign 
1028:  MOVF   x68,W
102A:  XORLW  80
102C:  MOVWF  x68
....................  
....................    return (y); 
102E:  MOVFF  67,00
1032:  MOVFF  68,01
1036:  MOVFF  69,02
103A:  MOVFF  6A,03
103E:  GOTO   16C8 (RETURN)
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
*
03E0:  BSF    F95.6
03E2:  MOVLW  11
03E4:  MOVWF  00
03E6:  DECFSZ 00,F
03E8:  BRA    03E6
03EA:  BSF    F95.7
03EC:  MOVLW  11
03EE:  MOVWF  00
03F0:  DECFSZ 00,F
03F2:  BRA    03F0
03F4:  BCF    F8C.6
03F6:  BCF    F95.6
03F8:  MOVLW  11
03FA:  MOVWF  00
03FC:  DECFSZ 00,F
03FE:  BRA    03FC
0400:  BCF    F8C.7
0402:  BCF    F95.7
....................         delay_us(20); 
0404:  MOVLW  4F
0406:  MOVWF  00
0408:  DECFSZ 00,F
040A:  BRA    0408
040C:  BRA    040E
....................         i2c_write(LCD_ADDR); //the slave addresse 
040E:  MOVLW  4E
0410:  MOVWF  x76
0412:  RCALL  0374
....................         delay_us(20); 
0414:  MOVLW  4F
0416:  MOVWF  00
0418:  DECFSZ 00,F
041A:  BRA    0418
041C:  BRA    041E
....................         i2c_write(data); 
041E:  MOVFF  75,76
0422:  RCALL  0374
....................         delay_us(20); 
0424:  MOVLW  4F
0426:  MOVWF  00
0428:  DECFSZ 00,F
042A:  BRA    0428
042C:  BRA    042E
....................         i2c_stop(); 
042E:  BCF    F95.6
0430:  NOP   
0432:  BSF    F95.7
0434:  BTFSS  F83.7
0436:  BRA    0434
0438:  MOVLW  11
043A:  MOVWF  00
043C:  DECFSZ 00,F
043E:  BRA    043C
0440:  BRA    0442
0442:  NOP   
0444:  BSF    F95.6
0446:  MOVLW  11
0448:  MOVWF  00
044A:  DECFSZ 00,F
044C:  BRA    044A
....................         delay_us(20); 
044E:  MOVLW  4F
0450:  MOVWF  00
0452:  DECFSZ 00,F
0454:  BRA    0452
0456:  BRA    0458
0458:  RETURN 0
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
045A:  BTFSS  20.0
045C:  BRA    0468
045E:  MOVF   x74,W
0460:  IORLW  04
0462:  IORLW  08
0464:  MOVWF  x74
0466:  BRA    046A
0468:  BSF    x74.2
....................         i2c_send_nibble(data); 
046A:  MOVFF  74,75
046E:  RCALL  03E0
....................         data=data-4;       //toggle EN back to 0 
0470:  MOVLW  04
0472:  SUBWF  x74,F
....................         i2c_send_nibble(data); 
0474:  MOVFF  74,75
0478:  RCALL  03E0
047A:  RETURN 0
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
047C:  CLRF   x74
047E:  RCALL  045A
....................     lcd_send_byte(0x10); 
0480:  MOVLW  10
0482:  MOVWF  x74
0484:  RCALL  045A
....................     delay_ms(2); 
0486:  MOVLW  02
0488:  MOVWF  x72
048A:  RCALL  034C
048C:  RETURN 0
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
048E:  MOVLW  C8
0490:  MOVWF  x72
0492:  RCALL  034C
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
0494:  CLRF   x74
0496:  RCALL  045A
....................         lcd_send_byte(0x10); 
0498:  MOVLW  10
049A:  MOVWF  x74
049C:  RCALL  045A
....................         lcd_send_byte(0x00); 
049E:  CLRF   x74
04A0:  RCALL  045A
....................         lcd_send_byte(0x00); 
04A2:  CLRF   x74
04A4:  RCALL  045A
....................         lcd_send_byte(0x10); 
04A6:  MOVLW  10
04A8:  MOVWF  x74
04AA:  RCALL  045A
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
04AC:  MOVLW  30
04AE:  MOVWF  x74
04B0:  RCALL  045A
....................         lcd_send_byte(0x30); 
04B2:  MOVLW  30
04B4:  MOVWF  x74
04B6:  RCALL  045A
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
04B8:  MOVLW  30
04BA:  MOVWF  x74
04BC:  RCALL  045A
....................         lcd_send_byte(0x20); 
04BE:  MOVLW  20
04C0:  MOVWF  x74
04C2:  RCALL  045A
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
04C4:  MOVLW  20
04C6:  MOVWF  x74
04C8:  RCALL  045A
....................         lcd_send_byte(0x80); 
04CA:  MOVLW  80
04CC:  MOVWF  x74
04CE:  RCALL  045A
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
04D0:  CLRF   x74
04D2:  RCALL  045A
....................         lcd_send_byte(0xC0); 
04D4:  MOVLW  C0
04D6:  MOVWF  x74
04D8:  RCALL  045A
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
04DA:  CLRF   x74
04DC:  RCALL  045A
....................         lcd_send_byte(0x60); 
04DE:  MOVLW  60
04E0:  MOVWF  x74
04E2:  RCALL  045A
....................            //clears the display 
....................         lcd_clear(); 
04E4:  RCALL  047C
04E6:  GOTO   05E8 (RETURN)
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
04EA:  MOVF   x73,W
04EC:  XORLW  01
04EE:  BZ    04FE
04F0:  XORLW  03
04F2:  BZ    0504
04F4:  XORLW  01
04F6:  BZ    050A
04F8:  XORLW  07
04FA:  BZ    0510
04FC:  BRA    0516
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
04FE:  MOVLW  80
0500:  MOVWF  1F
0502:  BRA    051A
....................       case 2:  address= lcd_line_two;     break; 
0504:  MOVLW  C0
0506:  MOVWF  1F
0508:  BRA    051A
....................       case 3:  address= lcd_line_three;   break; 
050A:  MOVLW  94
050C:  MOVWF  1F
050E:  BRA    051A
....................       case 4:  address= lcd_line_four;    break; 
0510:  MOVLW  D4
0512:  MOVWF  1F
0514:  BRA    051A
....................       default: address= lcd_line_one;     break;  
0516:  MOVLW  80
0518:  MOVWF  1F
....................    } 
....................   
....................    address+=x-1; 
051A:  MOVLW  01
051C:  SUBWF  x72,W
051E:  ADDWF  1F,F
....................    data=address&0xF0; 
0520:  MOVF   1F,W
0522:  ANDLW  F0
0524:  MOVWF  26
....................    lcd_send_byte(data); 
0526:  MOVFF  26,74
052A:  RCALL  045A
....................    data=address&0x0F; 
052C:  MOVF   1F,W
052E:  ANDLW  0F
0530:  MOVWF  26
....................    data=data<<4; 
0532:  SWAPF  26,F
0534:  MOVLW  F0
0536:  ANDWF  26,F
....................    lcd_send_byte(data); 
0538:  MOVFF  26,74
053C:  RCALL  045A
053E:  RETURN 0
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
0540:  MOVF   x71,W
0542:  XORLW  0C
0544:  BZ    0558
0546:  XORLW  0D
0548:  BZ    055C
054A:  XORLW  03
054C:  BZ    0566
054E:  XORLW  01
0550:  BZ    0572
0552:  XORLW  07
0554:  BZ    057E
0556:  BRA    058A
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
0558:  RCALL  047C
055A:  BRA    05AC
....................      case '\1': lcd_gotoxy(1,1);  break; 
055C:  MOVLW  01
055E:  MOVWF  x72
0560:  MOVWF  x73
0562:  RCALL  04EA
0564:  BRA    05AC
....................      case '\2': lcd_gotoxy(1,2);  break; 
0566:  MOVLW  01
0568:  MOVWF  x72
056A:  MOVLW  02
056C:  MOVWF  x73
056E:  RCALL  04EA
0570:  BRA    05AC
....................      case '\3': lcd_gotoxy(1,3);  break; 
0572:  MOVLW  01
0574:  MOVWF  x72
0576:  MOVLW  03
0578:  MOVWF  x73
057A:  RCALL  04EA
057C:  BRA    05AC
....................      case '\4': lcd_gotoxy(1,4);  break; 
057E:  MOVLW  01
0580:  MOVWF  x72
0582:  MOVLW  04
0584:  MOVWF  x73
0586:  RCALL  04EA
0588:  BRA    05AC
....................  
....................      default: 
....................         data=in_data&0xF0; 
058A:  MOVF   x71,W
058C:  ANDLW  F0
058E:  MOVWF  x72
....................         data=data|RS; //set RS pin to 1 
0590:  BSF    x72.0
....................         lcd_send_byte(data); 
0592:  MOVFF  72,74
0596:  RCALL  045A
....................         data=in_data&0x0F; 
0598:  MOVF   x71,W
059A:  ANDLW  0F
059C:  MOVWF  x72
....................         data=data<<4; 
059E:  SWAPF  x72,F
05A0:  MOVLW  F0
05A2:  ANDWF  x72,F
....................         data=data|RS; //set RS pin to 1 
05A4:  BSF    x72.0
....................         lcd_send_byte(data); 
05A6:  MOVFF  72,74
05AA:  RCALL  045A
....................      break; 
....................    } 
05AC:  RETURN 0
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #include <Control_ADCs.h> 
.................... /*  
....................  * File:   MAX191.h 
....................  * Author: MARCOS 
....................  * 
....................  * Created on 23 de septiembre de 2016, 08:14 
....................  */ 
....................  
.................... #ifndef Control_ADCs_H 
.................... #define Control_ADCs_H 
....................  
.................... #define ADC_CSCorriente PIN_A0  // salida 
.................... #define ADC_CSTension PIN_A1 // salida 
.................... #define ADC_SCLK PIN_A2 // salida clock tension 
.................... #define ADC_SCLKcorr PIN_B0 
.................... #define ADC_DOUT PIN_B2  // entrada, por aqui ingresa la info del MAX186 
.................... #define ADC_DIN PIN_A4 //salida, se envia la informacion al MAX186 
.................... #define ADC_SSTRB PIN_A5//entrada 
.................... #define ADC_SDATA PIN_A3//entrada SDATA en AD7450 
....................  
.................... //control AD7450 
.................... signed long leer_Tension(){ 
*
00DA:  CLRF   xA3
00DC:  CLRF   xA2
....................     signed long dato=0,dato_t; 
....................     int i; 
....................     output_low (ADC_CSTension); 
00DE:  BCF    F92.1
00E0:  BCF    F89.1
....................     delay_us(1); 
00E2:  MOVLW  03
00E4:  MOVWF  00
00E6:  DECFSZ 00,F
00E8:  BRA    00E6
00EA:  BRA    00EC
....................     output_low (ADC_SCLK); 
00EC:  BCF    F92.2
00EE:  BCF    F89.2
....................     delay_us(1); 
00F0:  MOVLW  03
00F2:  MOVWF  00
00F4:  DECFSZ 00,F
00F6:  BRA    00F4
00F8:  BRA    00FA
....................     output_high (ADC_SCLK); 
00FA:  BCF    F92.2
00FC:  BSF    F89.2
....................     delay_us(1); 
00FE:  MOVLW  03
0100:  MOVWF  00
0102:  DECFSZ 00,F
0104:  BRA    0102
0106:  BRA    0108
....................      
....................         for(i=0;i<15;i++){ 
0108:  CLRF   xA6
010A:  MOVF   xA6,W
010C:  SUBLW  0E
010E:  BNC   0140
....................           shift_left(&dato,2,input(ADC_SDATA)); 
0110:  BSF    F92.3
0112:  BTFSC  F80.3
0114:  BRA    011A
0116:  BCF    FD8.0
0118:  BRA    011C
011A:  BSF    FD8.0
011C:  RLCF   xA2,F
011E:  RLCF   xA3,F
....................           output_low(ADC_SCLK); 
0120:  BCF    F92.2
0122:  BCF    F89.2
....................           delay_us(1);  
0124:  MOVLW  03
0126:  MOVWF  00
0128:  DECFSZ 00,F
012A:  BRA    0128
012C:  BRA    012E
....................           output_high(ADC_SCLK);  
012E:  BCF    F92.2
0130:  BSF    F89.2
....................           delay_us(1); 
0132:  MOVLW  03
0134:  MOVWF  00
0136:  DECFSZ 00,F
0138:  BRA    0136
013A:  BRA    013C
013C:  INCF   xA6,F
013E:  BRA    010A
....................         } 
....................  
....................        // output_high (ADC_SCLK); 
....................        // delay_us(1); 
....................         output_high (ADC_CSTension); 
0140:  BCF    F92.1
0142:  BSF    F89.1
....................          
....................        dato_t=(dato&0x0800); 
0144:  CLRF   xA4
0146:  MOVF   xA3,W
0148:  ANDLW  08
014A:  MOVWF  xA5
....................          
....................       if (dato_t==0x0800){ 
014C:  MOVF   xA4,F
014E:  BNZ   016A
0150:  MOVF   xA5,W
0152:  SUBLW  08
0154:  BNZ   016A
....................             dato=-2048+(dato&0xF7FF); 
0156:  MOVFF  A2,00
015A:  MOVF   xA3,W
015C:  ANDLW  F7
015E:  MOVWF  03
0160:  MOVFF  A2,A2
0164:  MOVLW  F8
0166:  ADDWF  03,W
0168:  MOVWF  xA3
....................       } 
....................     return(dato); 
016A:  MOVFF  A2,01
016E:  MOVFF  A3,02
0172:  GOTO   0252 (RETURN)
.................... } 
....................  
.................... //control MAX186 
.................... long leer_Corriente(){ 
0176:  CLRF   xA3
0178:  CLRF   xA2
017A:  MOVLW  8E
017C:  MOVWF  xA4
....................     long dato=0; 
....................     BYTE config= 0b10001110; 
....................     int i; 
....................     output_low (ADC_CSCorriente); 
017E:  BCF    F92.0
0180:  BCF    F89.0
....................     output_low (ADC_DIN); 
0182:  BCF    F92.4
0184:  BCF    F89.4
....................     delay_us(1); 
0186:  MOVLW  03
0188:  MOVWF  00
018A:  DECFSZ 00,F
018C:  BRA    018A
018E:  BRA    0190
....................      
....................     for(i=0; i<8; i++) { 
0190:  CLRF   xA5
0192:  MOVF   xA5,W
0194:  SUBLW  07
0196:  BNC   01C6
....................       output_bit(ADC_DIN, shift_left(&config,1,0)); 
0198:  BCF    FD8.0
019A:  RLCF   xA4,F
019C:  BC    01A2
019E:  BCF    F89.4
01A0:  BRA    01A4
01A2:  BSF    F89.4
01A4:  BCF    F92.4
....................       output_high(ADC_SCLKcorr); 
01A6:  BCF    F93.0
01A8:  BSF    F8A.0
....................       delay_us(1); 
01AA:  MOVLW  03
01AC:  MOVWF  00
01AE:  DECFSZ 00,F
01B0:  BRA    01AE
01B2:  BRA    01B4
....................       output_low(ADC_SCLKcorr);	 
01B4:  BCF    F93.0
01B6:  BCF    F8A.0
....................       delay_us(1); 
01B8:  MOVLW  03
01BA:  MOVWF  00
01BC:  DECFSZ 00,F
01BE:  BRA    01BC
01C0:  BRA    01C2
01C2:  INCF   xA5,F
01C4:  BRA    0192
....................    } 
....................  
....................     output_high(ADC_CSCorriente); 
01C6:  BCF    F92.0
01C8:  BSF    F89.0
....................      
....................     while(input(ADC_SSTRB)=='0');    
....................          
....................         output_low (ADC_CSCorriente); 
01CA:  BCF    F92.0
01CC:  BCF    F89.0
....................         output_high (ADC_SCLKcorr); 
01CE:  BCF    F93.0
01D0:  BSF    F8A.0
....................         delay_us(1); 
01D2:  MOVLW  03
01D4:  MOVWF  00
01D6:  DECFSZ 00,F
01D8:  BRA    01D6
01DA:  BRA    01DC
....................         output_low (ADC_SCLKcorr); 
01DC:  BCF    F93.0
01DE:  BCF    F8A.0
....................         delay_us(1); 
01E0:  MOVLW  03
01E2:  MOVWF  00
01E4:  DECFSZ 00,F
01E6:  BRA    01E4
01E8:  BRA    01EA
....................          
....................         for(i=0;i<15;i++){ 
01EA:  CLRF   xA5
01EC:  MOVF   xA5,W
01EE:  SUBLW  0E
01F0:  BNC   0222
....................           output_high(ADC_SCLKcorr); 
01F2:  BCF    F93.0
01F4:  BSF    F8A.0
....................           delay_us(1); 
01F6:  MOVLW  03
01F8:  MOVWF  00
01FA:  DECFSZ 00,F
01FC:  BRA    01FA
01FE:  BRA    0200
....................           shift_left(&dato,2,input(ADC_DOUT));  
0200:  BSF    F93.2
0202:  BTFSC  F81.2
0204:  BRA    020A
0206:  BCF    FD8.0
0208:  BRA    020C
020A:  BSF    FD8.0
020C:  RLCF   xA2,F
020E:  RLCF   xA3,F
....................           output_low(ADC_SCLKcorr); 
0210:  BCF    F93.0
0212:  BCF    F8A.0
....................           delay_us(1); 
0214:  MOVLW  03
0216:  MOVWF  00
0218:  DECFSZ 00,F
021A:  BRA    0218
021C:  BRA    021E
021E:  INCF   xA5,F
0220:  BRA    01EC
....................         } 
....................   
....................          
....................         output_high (ADC_CSCorriente); 
0222:  BCF    F92.0
0224:  BSF    F89.0
....................      
....................        
....................     dato= (dato>>3)& 0x0FFF; 
0226:  RRCF   xA3,W
0228:  MOVWF  xA7
022A:  RRCF   xA2,W
022C:  MOVWF  xA6
022E:  RRCF   xA7,F
0230:  RRCF   xA6,F
0232:  RRCF   xA7,F
0234:  RRCF   xA6,F
0236:  MOVLW  1F
0238:  ANDWF  xA7,F
023A:  MOVFF  A6,A2
023E:  MOVF   xA7,W
0240:  ANDLW  0F
0242:  MOVWF  xA3
....................     return(dato); 
0244:  MOVFF  A2,01
0248:  MOVFF  A3,02
024C:  GOTO   025C (RETURN)
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... //Implementacion Switch-Case 
....................  
.................... /** 
.................... *	\fn void maquina_estado() 
.................... *	\brief Implementacion Switch-Case 
.................... *	\details  
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
....................  **/ 
.................... signed long punto1; 
.................... long punto2; 
.................... float tiempo_potencia; 
.................... int16 tiempo_pottimer; 
.................... BYTE pos_V,pos_I,pos_V_A,pos_I_A; 
.................... int control_V; 
.................... int control_I; 
.................... int desfase; 
.................... int puntos=20;//puntos por periodo 
.................... float tension, corriente, tension_RMS,corriente_RMS, t_desfase, potencia_ins,angulo; 
.................... float Energia_Wms=0;//, Energia_Wh=0, Energia_kWh=0; 
.................... float Energia_Wh=0, Energia_kWh; 
.................... const long carga= 0xE877; 
.................... int control_pantalla; 
....................  
....................  
....................  
.................... #INT_EXT1  
.................... void interrupcion_ext(){ 
....................     control_pantalla++; 
*
00CC:  INCF   x61,F
....................     while(input(PIN_B1)==1); 
00CE:  BSF    F93.1
00D0:  BTFSC  F81.1
00D2:  BRA    00CE
.................... } 
....................  
00D4:  BCF    FF0.0
00D6:  GOTO   0070
.................... #INT_TIMER1 FAST          // interrupcion para demora de 1 ms, ALTA PRIORIDAD 
.................... void interrtimer_0(){ 
....................     punto1= leer_Tension(); 
*
0250:  BRA    00DA
0252:  MOVFF  02,28
0256:  MOVFF  01,27
....................     punto2= leer_Corriente(); // comprobar si funciona con el tiempo de demora de la lectura del externo 
025A:  BRA    0176
025C:  MOVFF  02,2A
0260:  MOVFF  01,29
....................     set_timer1(carga);   // interrupcion cada 1 ms 
0264:  MOVLW  E8
0266:  MOVWF  FCF
0268:  MOVLW  77
026A:  MOVWF  FCE
....................     pulso_timer++; 
026C:  INCF   25,F
....................  
026E:  BCF    F9E.0
0270:  RETFIE 1
....................    } 
....................  
....................  
....................  
.................... void maquina_estado() 
.................... { 
.................... 		static int estado = PUNTO_TENS_CORR; 
....................  
.................... 		switch(estado) 
*
12D4:  MOVF   x62,W
12D6:  XORLW  00
12D8:  BZ    12F4
12DA:  XORLW  01
12DC:  BZ    133C
12DE:  XORLW  03
12E0:  BTFSC  FD8.2
12E2:  BRA    14B2
12E4:  XORLW  01
12E6:  BTFSC  FD8.2
12E8:  BRA    157E
12EA:  XORLW  07
12EC:  BTFSC  FD8.2
12EE:  BRA    1912
12F0:  GOTO   1AE0
.................... 		{ 
.................... 			case PUNTO_TENS_CORR: 
....................                 //punto1= leer_Tension(); 
....................                // punto2= leer_Corriente(); // comprobar si funciona con el tiempo de demora de la lectura del externo 
....................                 // convierte los valores de long a float 
....................             if (pulso_timer==1){  
12F4:  DECFSZ 25,W
12F6:  BRA    1338
....................                 tension=punto1; 
12F8:  MOVFF  28,64
12FC:  MOVFF  27,63
1300:  GOTO   060C
1304:  MOVFF  03,3C
1308:  MOVFF  02,3B
130C:  MOVFF  01,3A
1310:  MOVFF  00,39
....................                 corriente=punto2; 
1314:  MOVFF  2A,92
1318:  MOVFF  29,91
131C:  CALL   0656
1320:  MOVFF  03,40
1324:  MOVFF  02,3F
1328:  MOVFF  01,3E
132C:  MOVFF  00,3D
....................                 contador++; 
1330:  INCF   22,F
....................                 pulso_timer=0; 
1332:  CLRF   25
.................... 					estado = CONVERSION_DESFASE; 
1334:  MOVLW  01
1336:  MOVWF  x62
....................             } 
.................... 				break; 
1338:  GOTO   1AE2
.................... 			 
.................... 			case CONVERSION_DESFASE: 
....................                 tension= (tension)*2.5/2048; 
133C:  MOVFF  3C,94
1340:  MOVFF  3B,93
1344:  MOVFF  3A,92
1348:  MOVFF  39,91
134C:  CLRF   x98
134E:  CLRF   x97
1350:  MOVLW  20
1352:  MOVWF  x96
1354:  MOVLW  80
1356:  MOVWF  x95
1358:  CALL   068C
135C:  MOVFF  03,66
1360:  MOVFF  02,65
1364:  MOVFF  01,64
1368:  MOVFF  00,63
136C:  MOVFF  03,78
1370:  MOVFF  02,77
1374:  MOVFF  01,76
1378:  MOVFF  00,75
137C:  CLRF   x7C
137E:  CLRF   x7B
1380:  CLRF   x7A
1382:  MOVLW  8A
1384:  MOVWF  x79
1386:  CALL   077E
138A:  MOVFF  03,3C
138E:  MOVFF  02,3B
1392:  MOVFF  01,3A
1396:  MOVFF  00,39
....................                 corriente= (corriente)/1000-2.5; 
139A:  MOVFF  40,78
139E:  MOVFF  3F,77
13A2:  MOVFF  3E,76
13A6:  MOVFF  3D,75
13AA:  CLRF   x7C
13AC:  CLRF   x7B
13AE:  MOVLW  7A
13B0:  MOVWF  x7A
13B2:  MOVLW  88
13B4:  MOVWF  x79
13B6:  CALL   077E
13BA:  MOVFF  03,66
13BE:  MOVFF  02,65
13C2:  MOVFF  01,64
13C6:  MOVFF  00,63
13CA:  BSF    FD8.1
13CC:  MOVFF  03,94
13D0:  MOVFF  02,93
13D4:  MOVFF  01,92
13D8:  MOVFF  00,91
13DC:  CLRF   x98
13DE:  CLRF   x97
13E0:  MOVLW  20
13E2:  MOVWF  x96
13E4:  MOVLW  80
13E6:  MOVWF  x95
13E8:  CALL   08D8
13EC:  MOVFF  03,40
13F0:  MOVFF  02,3F
13F4:  MOVFF  01,3E
13F8:  MOVFF  00,3D
....................                 //se convierte a la tension y corriente real 
....................                 tension= tension*155.57; // conversion con 2 V igual a 311.13 V 
13FC:  MOVFF  3C,94
1400:  MOVFF  3B,93
1404:  MOVFF  3A,92
1408:  MOVFF  39,91
140C:  MOVLW  EC
140E:  MOVWF  x98
1410:  MOVLW  91
1412:  MOVWF  x97
1414:  MOVLW  1B
1416:  MOVWF  x96
1418:  MOVLW  86
141A:  MOVWF  x95
141C:  CALL   068C
1420:  MOVFF  03,3C
1424:  MOVFF  02,3B
1428:  MOVFF  01,3A
142C:  MOVFF  00,39
....................                 corriente= corriente*12; // 2.5 V es igual a +30 A (recordar que el sensor mide 30A) 
1430:  MOVFF  40,94
1434:  MOVFF  3F,93
1438:  MOVFF  3E,92
143C:  MOVFF  3D,91
1440:  CLRF   x98
1442:  CLRF   x97
1444:  MOVLW  40
1446:  MOVWF  x96
1448:  MOVLW  82
144A:  MOVWF  x95
144C:  CALL   068C
1450:  MOVFF  03,40
1454:  MOVFF  02,3F
1458:  MOVFF  01,3E
145C:  MOVFF  00,3D
....................                  
....................                 // Analisis del punto POSITVO O NEGATIVO 
....................                 // valor positivo estado=0-- valor negativo estado=1 
....................                  
....................                 //TENSION 
....................                 #asm 
....................                 clrf &pos_V; 
1460:  CLRF   31
....................                 btfsc (&tension + 0x01), 7; 
1462:  BTFSC  3A.7
....................                 bsf &pos_V,0; 
1464:  BSF    31.0
....................                 #endasm 
.................... 				 
....................                 //CORRIENTE 
....................                 #asm 
....................                 clrf &pos_I; 
1466:  CLRF   32
....................                 btfsc (&corriente + 0x01), 7; // comprueba signo en un bit de los 4 byte del float 
1468:  BTFSC  3E.7
....................                 bsf &pos_I,0; 
146A:  BSF    32.0
....................                 #endasm 
....................  
....................                  
....................                  
.................... 				 
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contador distinto de cero) 
....................                 if (pos_V==1 && contador>=2 && pos_V_A==0 && desfase!=1){  
146C:  DECFSZ 31,W
146E:  BRA    1488
1470:  MOVF   22,W
1472:  SUBLW  01
1474:  BC    1488
1476:  MOVF   33,F
1478:  BNZ   1488
147A:  DECFSZ 37,W
147C:  BRA    1480
147E:  BRA    1488
....................                  control_V= contador; // tiempo en el que cruz la tension  
1480:  MOVFF  22,35
....................                  desfase=1; 
1484:  MOVLW  01
1486:  MOVWF  37
....................                 } 
....................                  
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_I==1 && contador>=2 && pos_I_A==0 && desfase!=2){ 
1488:  DECFSZ 32,W
148A:  BRA    14A4
148C:  MOVF   22,W
148E:  SUBLW  01
1490:  BC    14A4
1492:  MOVF   34,F
1494:  BNZ   14A4
1496:  MOVF   37,W
1498:  SUBLW  02
149A:  BZ    14A4
....................                      
....................                  control_I= contador; // tiempo en el que cruz la corriente 
149C:  MOVFF  22,36
....................                  desfase=2; 
14A0:  MOVLW  02
14A2:  MOVWF  37
....................                 } 
....................                 // guarda el signo de los puntos anteriores 
....................                 pos_V_A=pos_V; 
14A4:  MOVFF  31,33
....................                 pos_I_A=pos_I; 
14A8:  MOVFF  32,34
....................                  
....................                  
.................... 					estado = TENS_CORR_RMS; 
14AC:  MOVLW  02
14AE:  MOVWF  x62
.................... 		 
.................... 				 
....................  
.................... 				break; 
14B0:  BRA    1AE2
.................... //---------------------------------------------------------------------------------------------------- 
....................                  
.................... 			case TENS_CORR_RMS: 
.................... 			 
.................... 				if((contador<30)) 
14B2:  MOVF   22,W
14B4:  SUBLW  1D
14B6:  BNC   157C
.................... 				{ 
.................... 					tension_RMS=tension_RMS+ tension * tension;       //calcula tension eficaz 
14B8:  MOVFF  3C,94
14BC:  MOVFF  3B,93
14C0:  MOVFF  3A,92
14C4:  MOVFF  39,91
14C8:  MOVFF  3C,98
14CC:  MOVFF  3B,97
14D0:  MOVFF  3A,96
14D4:  MOVFF  39,95
14D8:  CALL   068C
14DC:  BCF    FD8.1
14DE:  MOVFF  44,94
14E2:  MOVFF  43,93
14E6:  MOVFF  42,92
14EA:  MOVFF  41,91
14EE:  MOVFF  03,98
14F2:  MOVFF  02,97
14F6:  MOVFF  01,96
14FA:  MOVFF  00,95
14FE:  CALL   08D8
1502:  MOVFF  03,44
1506:  MOVFF  02,43
150A:  MOVFF  01,42
150E:  MOVFF  00,41
....................                     corriente_RMS= corriente_RMS+ corriente * corriente; // calcula corriente eficaz 
1512:  MOVFF  40,94
1516:  MOVFF  3F,93
151A:  MOVFF  3E,92
151E:  MOVFF  3D,91
1522:  MOVFF  40,98
1526:  MOVFF  3F,97
152A:  MOVFF  3E,96
152E:  MOVFF  3D,95
1532:  CALL   068C
1536:  BCF    FD8.1
1538:  MOVFF  48,94
153C:  MOVFF  47,93
1540:  MOVFF  46,92
1544:  MOVFF  45,91
1548:  MOVFF  03,98
154C:  MOVFF  02,97
1550:  MOVFF  01,96
1554:  MOVFF  00,95
1558:  CALL   08D8
155C:  MOVFF  03,48
1560:  MOVFF  02,47
1564:  MOVFF  01,46
1568:  MOVFF  00,45
....................                     //pulso_timer=0; 
....................                      
.................... 					estado = PUNTO_TENS_CORR; 
156C:  CLRF   x62
....................                      
....................                     if((contador== 29)){ 
156E:  MOVF   22,W
1570:  SUBLW  1D
1572:  BNZ   157C
.................... 					disable_interrupts(INT_TIMER1);// deshabilita la interrupcion para no entrar al timer 
1574:  BCF    F9D.0
....................                     contador=0; //se reinicia el contador, para comenzar nuevamente  
1576:  CLRF   22
.................... 					estado = CALCULO_POT_ENER; 
1578:  MOVLW  03
157A:  MOVWF  x62
.................... 				} 
.................... 				} 
.................... 				 
....................  
.................... 				break; 
157C:  BRA    1AE2
....................                  
.................... //--------------------------------------------------------------------------------------------------------------------                 
.................... 			 
.................... 			case CALCULO_POT_ENER: // falta calculo de energia 
....................                 //calcula las raices para completar el calculo RMS 
.................... 				tension_RMS= sqrt(tension_RMS/30); 
157E:  MOVFF  44,78
1582:  MOVFF  43,77
1586:  MOVFF  42,76
158A:  MOVFF  41,75
158E:  CLRF   x7C
1590:  CLRF   x7B
1592:  MOVLW  70
1594:  MOVWF  x7A
1596:  MOVLW  83
1598:  MOVWF  x79
159A:  CALL   077E
159E:  MOVFF  03,66
15A2:  MOVFF  02,65
15A6:  MOVFF  01,64
15AA:  MOVFF  00,63
15AE:  MOVFF  03,6A
15B2:  MOVFF  02,69
15B6:  MOVFF  01,68
15BA:  MOVFF  00,67
15BE:  CALL   0BB8
15C2:  MOVFF  03,44
15C6:  MOVFF  02,43
15CA:  MOVFF  01,42
15CE:  MOVFF  00,41
....................                 corriente_RMS= sqrt(corriente_RMS/30); 
15D2:  MOVFF  48,78
15D6:  MOVFF  47,77
15DA:  MOVFF  46,76
15DE:  MOVFF  45,75
15E2:  CLRF   x7C
15E4:  CLRF   x7B
15E6:  MOVLW  70
15E8:  MOVWF  x7A
15EA:  MOVLW  83
15EC:  MOVWF  x79
15EE:  CALL   077E
15F2:  MOVFF  03,66
15F6:  MOVFF  02,65
15FA:  MOVFF  01,64
15FE:  MOVFF  00,63
1602:  MOVFF  03,6A
1606:  MOVFF  02,69
160A:  MOVFF  01,68
160E:  MOVFF  00,67
1612:  CALL   0BB8
1616:  MOVFF  03,48
161A:  MOVFF  02,47
161E:  MOVFF  01,46
1622:  MOVFF  00,45
....................                  
....................                 
....................                 // se controla si se pudo calcular desfase en el estado anterior  
....................                 // se realiza las diferencia de cruce por cero y se convierte de tiempo a radianes 
....................                 angulo=0; 
1626:  CLRF   54
1628:  CLRF   53
162A:  CLRF   52
162C:  CLRF   51
....................                 if (desfase==2){ 
162E:  MOVF   37,W
1630:  SUBLW  02
1632:  BNZ   16B4
....................                     t_desfase= (control_I-control_V); 
1634:  MOVF   35,W
1636:  SUBWF  36,W
1638:  CLRF   x92
163A:  MOVWF  x91
163C:  CALL   0656
1640:  MOVFF  03,4C
1644:  MOVFF  02,4B
1648:  MOVFF  01,4A
164C:  MOVFF  00,49
....................                     angulo= (t_desfase*pi)/10;      // angulo de desfase en radianes. 20 puntos por periodo 
1650:  MOVFF  4C,94
1654:  MOVFF  4B,93
1658:  MOVFF  4A,92
165C:  MOVFF  49,91
1660:  MOVLW  DB
1662:  MOVWF  x98
1664:  MOVLW  0F
1666:  MOVWF  x97
1668:  MOVLW  49
166A:  MOVWF  x96
166C:  MOVLW  80
166E:  MOVWF  x95
1670:  CALL   068C
1674:  MOVFF  03,66
1678:  MOVFF  02,65
167C:  MOVFF  01,64
1680:  MOVFF  00,63
1684:  MOVFF  03,78
1688:  MOVFF  02,77
168C:  MOVFF  01,76
1690:  MOVFF  00,75
1694:  CLRF   x7C
1696:  CLRF   x7B
1698:  MOVLW  20
169A:  MOVWF  x7A
169C:  MOVLW  82
169E:  MOVWF  x79
16A0:  CALL   077E
16A4:  MOVFF  03,54
16A8:  MOVFF  02,53
16AC:  MOVFF  01,52
16B0:  MOVFF  00,51
....................                    /*  lcd_gotoxy(1,1); 
....................                      printf(LCD_PUTC,"desfase= %f       ",t_desfase); 
....................                      lcd_gotoxy(1,2); 
....................                      printf(LCD_PUTC,"angulo=%f        ",angulo); 
....................                      delay_ms(1000);*/ 
....................                 }                 
....................                  
....................                 angulo=cos(angulo); 
16B4:  MOVFF  54,66
16B8:  MOVFF  53,65
16BC:  MOVFF  52,64
16C0:  MOVFF  51,63
16C4:  GOTO   0CFC
16C8:  MOVFF  03,54
16CC:  MOVFF  02,53
16D0:  MOVFF  01,52
16D4:  MOVFF  00,51
....................                // calculo de potencia  
....................                 potencia_ins= tension_RMS*corriente_RMS*angulo; 
16D8:  MOVFF  44,94
16DC:  MOVFF  43,93
16E0:  MOVFF  42,92
16E4:  MOVFF  41,91
16E8:  MOVFF  48,98
16EC:  MOVFF  47,97
16F0:  MOVFF  46,96
16F4:  MOVFF  45,95
16F8:  CALL   068C
16FC:  MOVFF  03,66
1700:  MOVFF  02,65
1704:  MOVFF  01,64
1708:  MOVFF  00,63
170C:  MOVFF  03,94
1710:  MOVFF  02,93
1714:  MOVFF  01,92
1718:  MOVFF  00,91
171C:  MOVFF  54,98
1720:  MOVFF  53,97
1724:  MOVFF  52,96
1728:  MOVFF  51,95
172C:  CALL   068C
1730:  MOVFF  03,50
1734:  MOVFF  02,4F
1738:  MOVFF  01,4E
173C:  MOVFF  00,4D
....................                 //se limpian las variables para la prxima etapa de muestreo 
....................                 control_V=0;       
1740:  CLRF   35
....................                 control_I=0; 
1742:  CLRF   36
....................                 //angulo=0; 
....................                 desfase=0;  
1744:  CLRF   37
....................                  
....................                 //Calculo de Energia 
....................                 tiempo_pottimer=get_timer0(); 
1746:  MOVF   FD6,W
1748:  MOVWF  2F
174A:  MOVFF  FD7,30
....................                 tiempo_potencia=(float)65536 - tiempo_pottimer;    //variable para calcular energia segun tiempo de potencia 
174E:  MOVFF  30,92
1752:  MOVFF  2F,91
1756:  CALL   0656
175A:  BSF    FD8.1
175C:  CLRF   x94
175E:  CLRF   x93
1760:  CLRF   x92
1762:  MOVLW  8F
1764:  MOVWF  x91
1766:  MOVFF  03,98
176A:  MOVFF  02,97
176E:  MOVFF  01,96
1772:  MOVFF  00,95
1776:  CALL   08D8
177A:  MOVFF  03,2E
177E:  MOVFF  02,2D
1782:  MOVFF  01,2C
1786:  MOVFF  00,2B
....................                 tiempo_potencia=tiempo_potencia/375; 
178A:  MOVFF  2E,78
178E:  MOVFF  2D,77
1792:  MOVFF  2C,76
1796:  MOVFF  2B,75
179A:  CLRF   x7C
179C:  MOVLW  80
179E:  MOVWF  x7B
17A0:  MOVLW  3B
17A2:  MOVWF  x7A
17A4:  MOVLW  87
17A6:  MOVWF  x79
17A8:  CALL   077E
17AC:  MOVFF  03,2E
17B0:  MOVFF  02,2D
17B4:  MOVFF  01,2C
17B8:  MOVFF  00,2B
....................                 Energia_Wms=Energia_Wms+potencia_ins*tiempo_potencia;             //Energia en Watt por milisegundo 
17BC:  MOVFF  50,94
17C0:  MOVFF  4F,93
17C4:  MOVFF  4E,92
17C8:  MOVFF  4D,91
17CC:  MOVFF  2E,98
17D0:  MOVFF  2D,97
17D4:  MOVFF  2C,96
17D8:  MOVFF  2B,95
17DC:  CALL   068C
17E0:  BCF    FD8.1
17E2:  MOVFF  58,94
17E6:  MOVFF  57,93
17EA:  MOVFF  56,92
17EE:  MOVFF  55,91
17F2:  MOVFF  03,98
17F6:  MOVFF  02,97
17FA:  MOVFF  01,96
17FE:  MOVFF  00,95
1802:  CALL   08D8
1806:  MOVFF  03,58
180A:  MOVFF  02,57
180E:  MOVFF  01,56
1812:  MOVFF  00,55
....................                  
....................                  
....................                 
....................                 if(Energia_Wms>=3600000){ 
1816:  CLRF   x90
1818:  MOVLW  BA
181A:  MOVWF  x8F
181C:  MOVLW  5B
181E:  MOVWF  x8E
1820:  MOVLW  94
1822:  MOVWF  x8D
1824:  MOVFF  58,94
1828:  MOVFF  57,93
182C:  MOVFF  56,92
1830:  MOVFF  55,91
1834:  CALL   0B42
1838:  BC    183C
183A:  BNZ   18AC
....................                     Energia_Wms=Energia_Wms/3600000; 
183C:  MOVFF  58,78
1840:  MOVFF  57,77
1844:  MOVFF  56,76
1848:  MOVFF  55,75
184C:  CLRF   x7C
184E:  MOVLW  BA
1850:  MOVWF  x7B
1852:  MOVLW  5B
1854:  MOVWF  x7A
1856:  MOVLW  94
1858:  MOVWF  x79
185A:  CALL   077E
185E:  MOVFF  03,58
1862:  MOVFF  02,57
1866:  MOVFF  01,56
186A:  MOVFF  00,55
....................                     Energia_Wh=Energia_Wh+Energia_Wms;  // relacion watt ms a watt hora 
186E:  BCF    FD8.1
1870:  MOVFF  5C,94
1874:  MOVFF  5B,93
1878:  MOVFF  5A,92
187C:  MOVFF  59,91
1880:  MOVFF  58,98
1884:  MOVFF  57,97
1888:  MOVFF  56,96
188C:  MOVFF  55,95
1890:  CALL   08D8
1894:  MOVFF  03,5C
1898:  MOVFF  02,5B
189C:  MOVFF  01,5A
18A0:  MOVFF  00,59
....................                     Energia_Wms=0;                 
18A4:  CLRF   58
18A6:  CLRF   57
18A8:  CLRF   56
18AA:  CLRF   55
....................                 } 
....................                  
....................                 if (Energia_Wh>=1000){ 
18AC:  CLRF   x90
18AE:  CLRF   x8F
18B0:  MOVLW  7A
18B2:  MOVWF  x8E
18B4:  MOVLW  88
18B6:  MOVWF  x8D
18B8:  MOVFF  5C,94
18BC:  MOVFF  5B,93
18C0:  MOVFF  5A,92
18C4:  MOVFF  59,91
18C8:  CALL   0B42
18CC:  BC    18D0
18CE:  BNZ   1908
....................                     Energia_kWh=Energia_kWh+1; 
18D0:  BCF    FD8.1
18D2:  MOVFF  60,94
18D6:  MOVFF  5F,93
18DA:  MOVFF  5E,92
18DE:  MOVFF  5D,91
18E2:  CLRF   x98
18E4:  CLRF   x97
18E6:  CLRF   x96
18E8:  MOVLW  7F
18EA:  MOVWF  x95
18EC:  CALL   08D8
18F0:  MOVFF  03,60
18F4:  MOVFF  02,5F
18F8:  MOVFF  01,5E
18FC:  MOVFF  00,5D
....................                     Energia_Wh=0; 
1900:  CLRF   5C
1902:  CLRF   5B
1904:  CLRF   5A
1906:  CLRF   59
....................                 } 
....................                  
....................                  
....................                  
....................                 // Se reinicia timer 0 nuevamente, para volver a calcular energia 
....................                   
....................                 set_timer0(0x0000); 
1908:  CLRF   FD7
190A:  CLRF   FD6
....................                  
.................... 					estado = MOSTRAR_DATOS; 
190C:  MOVLW  04
190E:  MOVWF  x62
.................... 				break; 
1910:  BRA    1AE2
....................                  
.................... //------------------------------------------------------------------------------------- 
....................                  
.................... 			case MOSTRAR_DATOS: 
....................                 //este estado solo muestra los datos en la pantalla LCD 
....................               if (control_pantalla>4){ 
1912:  MOVF   x61,W
1914:  SUBLW  04
1916:  BC    191A
....................                     control_pantalla=0; 
1918:  CLRF   x61
....................                 } 
....................                  
....................                 switch(control_pantalla) 
191A:  MOVF   x61,W
191C:  ADDLW  FB
191E:  BTFSC  FD8.0
1920:  BRA    1ABC
1922:  ADDLW  05
1924:  GOTO   1AE6
....................                 { 
....................                     case 0: 
....................                         lcd_gotoxy(1,1); 
1928:  MOVLW  01
192A:  MOVWF  x72
192C:  MOVWF  x73
192E:  CALL   04EA
....................                         printf(LCD_PUTC,"  ENERGIA kWh   "); 
1932:  MOVLW  72
1934:  MOVWF  FF6
1936:  MOVLW  02
1938:  MOVWF  FF7
193A:  CALL   1042
....................                         lcd_gotoxy(1,2); 
193E:  MOVLW  01
1940:  MOVWF  x72
1942:  MOVLW  02
1944:  MOVWF  x73
1946:  CALL   04EA
....................                         printf (LCD_PUTC, "%f kWh                   ",Energia_kWh); 
194A:  MOVLW  89
194C:  MOVWF  FE9
194E:  MOVFF  60,66
1952:  MOVFF  5F,65
1956:  MOVFF  5E,64
195A:  MOVFF  5D,63
195E:  MOVLW  02
1960:  MOVWF  x67
1962:  CALL   1132
1966:  MOVLW  86
1968:  MOVWF  FF6
196A:  MOVLW  02
196C:  MOVWF  FF7
196E:  MOVLW  17
1970:  MOVWF  x63
1972:  RCALL  12B4
....................                     break; 
1974:  BRA    1ABC
....................                      
....................                     case 1: 
....................                         lcd_gotoxy(1,1); 
1976:  MOVLW  01
1978:  MOVWF  x72
197A:  MOVWF  x73
197C:  CALL   04EA
....................                         printf(LCD_PUTC,"   ENERGIA Wh    "); 
1980:  MOVLW  9E
1982:  MOVWF  FF6
1984:  MOVLW  02
1986:  MOVWF  FF7
1988:  CALL   1042
....................                         lcd_gotoxy(1,2); 
198C:  MOVLW  01
198E:  MOVWF  x72
1990:  MOVLW  02
1992:  MOVWF  x73
1994:  CALL   04EA
....................                         printf (LCD_PUTC, "%f Wh                 ",Energia_Wh); 
1998:  MOVLW  89
199A:  MOVWF  FE9
199C:  MOVFF  5C,66
19A0:  MOVFF  5B,65
19A4:  MOVFF  5A,64
19A8:  MOVFF  59,63
19AC:  MOVLW  02
19AE:  MOVWF  x67
19B0:  CALL   1132
19B4:  MOVLW  B2
19B6:  MOVWF  FF6
19B8:  MOVLW  02
19BA:  MOVWF  FF7
19BC:  MOVLW  14
19BE:  MOVWF  x63
19C0:  RCALL  12B4
....................                     break; 
19C2:  BRA    1ABC
....................                      
....................                     case 2: 
....................                         lcd_gotoxy(1,1); 
19C4:  MOVLW  01
19C6:  MOVWF  x72
19C8:  MOVWF  x73
19CA:  CALL   04EA
....................                         printf(LCD_PUTC,"   Tension RMS  "); 
19CE:  MOVLW  C8
19D0:  MOVWF  FF6
19D2:  MOVLW  02
19D4:  MOVWF  FF7
19D6:  CALL   1042
....................                         lcd_gotoxy(1,2); 
19DA:  MOVLW  01
19DC:  MOVWF  x72
19DE:  MOVLW  02
19E0:  MOVWF  x73
19E2:  CALL   04EA
....................                         printf (LCD_PUTC, "%f V                  ",tension_RMS); 
19E6:  MOVLW  89
19E8:  MOVWF  FE9
19EA:  MOVFF  44,66
19EE:  MOVFF  43,65
19F2:  MOVFF  42,64
19F6:  MOVFF  41,63
19FA:  MOVLW  02
19FC:  MOVWF  x67
19FE:  CALL   1132
1A02:  MOVLW  DC
1A04:  MOVWF  FF6
1A06:  MOVLW  02
1A08:  MOVWF  FF7
1A0A:  MOVLW  14
1A0C:  MOVWF  x63
1A0E:  RCALL  12B4
....................                     break; 
1A10:  BRA    1ABC
....................                      
....................                     case 3: 
....................                         lcd_gotoxy(1,1); 
1A12:  MOVLW  01
1A14:  MOVWF  x72
1A16:  MOVWF  x73
1A18:  CALL   04EA
....................                         printf(LCD_PUTC," Corriente RMS  "); 
1A1C:  MOVLW  F2
1A1E:  MOVWF  FF6
1A20:  MOVLW  02
1A22:  MOVWF  FF7
1A24:  CALL   1042
....................                         lcd_gotoxy(1,2); 
1A28:  MOVLW  01
1A2A:  MOVWF  x72
1A2C:  MOVLW  02
1A2E:  MOVWF  x73
1A30:  CALL   04EA
....................                         printf (LCD_PUTC, "%f A                  ",corriente_RMS); 
1A34:  MOVLW  89
1A36:  MOVWF  FE9
1A38:  MOVFF  48,66
1A3C:  MOVFF  47,65
1A40:  MOVFF  46,64
1A44:  MOVFF  45,63
1A48:  MOVLW  02
1A4A:  MOVWF  x67
1A4C:  CALL   1132
1A50:  MOVLW  06
1A52:  MOVWF  FF6
1A54:  MOVLW  03
1A56:  MOVWF  FF7
1A58:  MOVLW  14
1A5A:  MOVWF  x63
1A5C:  RCALL  12B4
....................                     break; 
1A5E:  BRA    1ABC
....................                      
....................                     case 4: 
....................                         lcd_gotoxy(1,1); 
1A60:  MOVLW  01
1A62:  MOVWF  x72
1A64:  MOVWF  x73
1A66:  CALL   04EA
....................                         printf(LCD_PUTC,"Factor potencia "); 
1A6A:  MOVLW  1C
1A6C:  MOVWF  FF6
1A6E:  MOVLW  03
1A70:  MOVWF  FF7
1A72:  CALL   1042
....................                         lcd_gotoxy(1,2); 
1A76:  MOVLW  01
1A78:  MOVWF  x72
1A7A:  MOVLW  02
1A7C:  MOVWF  x73
1A7E:  CALL   04EA
....................                         printf (LCD_PUTC, "Cos(fi)=%f                   ",angulo); 
1A82:  MOVLW  2E
1A84:  MOVWF  FF6
1A86:  MOVLW  03
1A88:  MOVWF  FF7
1A8A:  MOVLW  08
1A8C:  MOVWF  x63
1A8E:  RCALL  12B4
1A90:  MOVLW  89
1A92:  MOVWF  FE9
1A94:  MOVFF  54,66
1A98:  MOVFF  53,65
1A9C:  MOVFF  52,64
1AA0:  MOVFF  51,63
1AA4:  MOVLW  02
1AA6:  MOVWF  x67
1AA8:  CALL   1132
1AAC:  MOVLW  38
1AAE:  MOVWF  FF6
1AB0:  MOVLW  03
1AB2:  MOVWF  FF7
1AB4:  MOVLW  13
1AB6:  MOVWF  x63
1AB8:  CALL   12B4
....................                     break; 
....................                  
....................                      
....................                 } 
....................                  
....................                  
....................                  
....................               /*  lcd_gotoxy(1,1); 
....................                 printf(LCD_PUTC,"%f Wh %f kWh              ",Energia_Wh,Energia_kWh); 
....................                 lcd_gotoxy(1,2); 
....................                 printf (LCD_PUTC, "T=\%f  I=\%f     ",tension_RMS,corriente_RMS);*/ 
....................                  
....................                  
....................                  
....................                 //Configuraciones para volver a tomar puntos 
....................                 enable_interrupts(INT_TIMER1); 
1ABC:  BSF    F9D.0
....................                 enable_interrupts(GLOBAL); 
1ABE:  MOVLW  C0
1AC0:  IORWF  FF2,F
....................                 pulso_timer=0; 
1AC2:  CLRF   25
....................                 set_timer1(carga);    
1AC4:  MOVLW  E8
1AC6:  MOVWF  FCF
1AC8:  MOVLW  77
1ACA:  MOVWF  FCE
.................... 				//reinicia todo 
....................                 corriente_RMS=0; 
1ACC:  CLRF   48
1ACE:  CLRF   47
1AD0:  CLRF   46
1AD2:  CLRF   45
....................                 tension_RMS=0; 
1AD4:  CLRF   44
1AD6:  CLRF   43
1AD8:  CLRF   42
1ADA:  CLRF   41
....................                  
.................... 				estado = PUNTO_TENS_CORR; 
1ADC:  CLRF   x62
.................... 		 
....................  
.................... 				break; 
1ADE:  BRA    1AE2
.................... 			 
.................... 			default: estado = PUNTO_TENS_CORR; 
1AE0:  CLRF   x62
.................... 		} 
1AE2:  GOTO   1B62 (RETURN)
....................  
....................  
.................... } 
....................  
.................... //Funciones asociadas a los eventos 
....................  
.................... /** 
.................... *	\fn int -(void) 
.................... *	\brief Resumen 
.................... *	\details Detalles 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 4C07   PLL12 CPUDIV1 NOUSBDIV HS FCMEN NOIESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
