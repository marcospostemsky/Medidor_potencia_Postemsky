CCS PCH C Compiler, Version 5.048, 5967               03-nov-16 20:51

               Filename:   C:\Users\MARCOS\Proyecto_final\Med_pot.X\dist\default\production\Med_pot.X.production.lst

               ROM used:   6450 bytes (20%)
                           Largest free fragment is 26314
               RAM used:   98 (5%) at main() level
                           160 (8%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   18E4
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   00BC
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #import(file="build/default/production/main.o") 
.................... #import(file="build/default/production/funciones.o") 
.................... /** 
.................... *	\file main.c 
.................... *	\brief Resumen del contenido del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  DATA 50,72
00B0:  DATA 69,6D
00B2:  DATA 65,72
00B4:  DATA 20,70
00B6:  DATA 72,75
00B8:  DATA 65,62
00BA:  DATA 61,00
*
035A:  TBLRD*+
035C:  MOVF   FF5,F
035E:  BZ    0378
0360:  MOVFF  FF6,62
0364:  MOVFF  FF7,63
0368:  MOVFF  FF5,70
036C:  RCALL  02EC
036E:  MOVFF  62,FF6
0372:  MOVFF  63,FF7
0376:  BRA    035A
0378:  GOTO   03A6 (RETURN)
*
0576:  MOVLW  8E
0578:  MOVWF  00
057A:  MOVFF  91,01
057E:  MOVFF  90,02
0582:  CLRF   03
0584:  MOVF   01,F
0586:  BNZ   059A
0588:  MOVFF  02,01
058C:  CLRF   02
058E:  MOVLW  08
0590:  SUBWF  00,F
0592:  MOVF   01,F
0594:  BNZ   059A
0596:  CLRF   00
0598:  BRA    05AA
059A:  BCF    FD8.0
059C:  BTFSC  01.7
059E:  BRA    05A8
05A0:  RLCF   02,F
05A2:  RLCF   01,F
05A4:  DECF   00,F
05A6:  BRA    059A
05A8:  BCF    01.7
05AA:  RETURN 0
05AC:  MOVF   x90,W
05AE:  BTFSC  FD8.2
05B0:  BRA    0694
05B2:  MOVWF  00
05B4:  MOVF   x94,W
05B6:  BTFSC  FD8.2
05B8:  BRA    0694
05BA:  ADDWF  00,F
05BC:  BNC   05C6
05BE:  MOVLW  81
05C0:  ADDWF  00,F
05C2:  BC    0694
05C4:  BRA    05CE
05C6:  MOVLW  7F
05C8:  SUBWF  00,F
05CA:  BNC   0694
05CC:  BZ    0694
05CE:  MOVFF  91,98
05D2:  MOVF   x95,W
05D4:  XORWF  x98,F
05D6:  BSF    x91.7
05D8:  BSF    x95.7
05DA:  MOVF   x93,W
05DC:  MULWF  x97
05DE:  MOVFF  FF4,9A
05E2:  MOVF   x92,W
05E4:  MULWF  x96
05E6:  MOVFF  FF4,03
05EA:  MOVFF  FF3,99
05EE:  MULWF  x97
05F0:  MOVF   FF3,W
05F2:  ADDWF  x9A,F
05F4:  MOVF   FF4,W
05F6:  ADDWFC x99,F
05F8:  MOVLW  00
05FA:  ADDWFC 03,F
05FC:  MOVF   x93,W
05FE:  MULWF  x96
0600:  MOVF   FF3,W
0602:  ADDWF  x9A,F
0604:  MOVF   FF4,W
0606:  ADDWFC x99,F
0608:  MOVLW  00
060A:  CLRF   02
060C:  ADDWFC 03,F
060E:  ADDWFC 02,F
0610:  MOVF   x91,W
0612:  MULWF  x97
0614:  MOVF   FF3,W
0616:  ADDWF  x99,F
0618:  MOVF   FF4,W
061A:  ADDWFC 03,F
061C:  MOVLW  00
061E:  ADDWFC 02,F
0620:  MOVF   x91,W
0622:  MULWF  x96
0624:  MOVF   FF3,W
0626:  ADDWF  03,F
0628:  MOVF   FF4,W
062A:  ADDWFC 02,F
062C:  MOVLW  00
062E:  CLRF   01
0630:  ADDWFC 01,F
0632:  MOVF   x93,W
0634:  MULWF  x95
0636:  MOVF   FF3,W
0638:  ADDWF  x99,F
063A:  MOVF   FF4,W
063C:  ADDWFC 03,F
063E:  MOVLW  00
0640:  ADDWFC 02,F
0642:  ADDWFC 01,F
0644:  MOVF   x92,W
0646:  MULWF  x95
0648:  MOVF   FF3,W
064A:  ADDWF  03,F
064C:  MOVF   FF4,W
064E:  ADDWFC 02,F
0650:  MOVLW  00
0652:  ADDWFC 01,F
0654:  MOVF   x91,W
0656:  MULWF  x95
0658:  MOVF   FF3,W
065A:  ADDWF  02,F
065C:  MOVF   FF4,W
065E:  ADDWFC 01,F
0660:  INCF   00,F
0662:  BTFSC  01.7
0664:  BRA    0670
0666:  RLCF   x99,F
0668:  RLCF   03,F
066A:  RLCF   02,F
066C:  RLCF   01,F
066E:  DECF   00,F
0670:  MOVLW  00
0672:  BTFSS  x99.7
0674:  BRA    068A
0676:  INCF   03,F
0678:  ADDWFC 02,F
067A:  ADDWFC 01,F
067C:  MOVF   01,W
067E:  BNZ   068A
0680:  MOVF   02,W
0682:  BNZ   068A
0684:  MOVF   03,W
0686:  BNZ   068A
0688:  INCF   00,F
068A:  BTFSC  x98.7
068C:  BSF    01.7
068E:  BTFSS  x98.7
0690:  BCF    01.7
0692:  BRA    069C
0694:  CLRF   00
0696:  CLRF   01
0698:  CLRF   02
069A:  CLRF   03
069C:  RETURN 0
069E:  MOVF   x74,W
06A0:  BTFSC  FD8.2
06A2:  BRA    07EE
06A4:  MOVWF  x80
06A6:  MOVF   x78,W
06A8:  BTFSC  FD8.2
06AA:  BRA    07EE
06AC:  SUBWF  x80,F
06AE:  BNC   06BA
06B0:  MOVLW  7F
06B2:  ADDWF  x80,F
06B4:  BTFSC  FD8.0
06B6:  BRA    07EE
06B8:  BRA    06C6
06BA:  MOVLW  81
06BC:  SUBWF  x80,F
06BE:  BTFSS  FD8.0
06C0:  BRA    07EE
06C2:  BTFSC  FD8.2
06C4:  BRA    07EE
06C6:  MOVFF  80,00
06CA:  CLRF   01
06CC:  CLRF   02
06CE:  CLRF   03
06D0:  CLRF   x7F
06D2:  MOVFF  75,7E
06D6:  BSF    x7E.7
06D8:  MOVFF  76,7D
06DC:  MOVFF  77,7C
06E0:  MOVLW  19
06E2:  MOVWF  x80
06E4:  MOVF   x7B,W
06E6:  SUBWF  x7C,F
06E8:  BC    0704
06EA:  MOVLW  01
06EC:  SUBWF  x7D,F
06EE:  BC    0704
06F0:  SUBWF  x7E,F
06F2:  BC    0704
06F4:  SUBWF  x7F,F
06F6:  BC    0704
06F8:  INCF   x7F,F
06FA:  INCF   x7E,F
06FC:  INCF   x7D,F
06FE:  MOVF   x7B,W
0700:  ADDWF  x7C,F
0702:  BRA    0754
0704:  MOVF   x7A,W
0706:  SUBWF  x7D,F
0708:  BC    072E
070A:  MOVLW  01
070C:  SUBWF  x7E,F
070E:  BC    072E
0710:  SUBWF  x7F,F
0712:  BC    072E
0714:  INCF   x7F,F
0716:  INCF   x7E,F
0718:  MOVF   x7A,W
071A:  ADDWF  x7D,F
071C:  MOVF   x7B,W
071E:  ADDWF  x7C,F
0720:  BNC   0754
0722:  INCF   x7D,F
0724:  BNZ   0754
0726:  INCF   x7E,F
0728:  BNZ   0754
072A:  INCF   x7F,F
072C:  BRA    0754
072E:  MOVF   x79,W
0730:  IORLW  80
0732:  SUBWF  x7E,F
0734:  BC    0752
0736:  MOVLW  01
0738:  SUBWF  x7F,F
073A:  BC    0752
073C:  INCF   x7F,F
073E:  MOVF   x79,W
0740:  IORLW  80
0742:  ADDWF  x7E,F
0744:  MOVF   x7A,W
0746:  ADDWF  x7D,F
0748:  BNC   071C
074A:  INCF   x7E,F
074C:  BNZ   071C
074E:  INCF   x7F,F
0750:  BRA    071C
0752:  BSF    03.0
0754:  DECFSZ x80,F
0756:  BRA    075A
0758:  BRA    0770
075A:  BCF    FD8.0
075C:  RLCF   x7C,F
075E:  RLCF   x7D,F
0760:  RLCF   x7E,F
0762:  RLCF   x7F,F
0764:  BCF    FD8.0
0766:  RLCF   03,F
0768:  RLCF   02,F
076A:  RLCF   01,F
076C:  RLCF   x81,F
076E:  BRA    06E4
0770:  BTFSS  x81.0
0772:  BRA    0780
0774:  BCF    FD8.0
0776:  RRCF   01,F
0778:  RRCF   02,F
077A:  RRCF   03,F
077C:  RRCF   x81,F
077E:  BRA    0784
0780:  DECF   00,F
0782:  BZ    07EE
0784:  BTFSC  x81.7
0786:  BRA    07C4
0788:  BCF    FD8.0
078A:  RLCF   x7C,F
078C:  RLCF   x7D,F
078E:  RLCF   x7E,F
0790:  RLCF   x7F,F
0792:  MOVF   x7B,W
0794:  SUBWF  x7C,F
0796:  BC    07A6
0798:  MOVLW  01
079A:  SUBWF  x7D,F
079C:  BC    07A6
079E:  SUBWF  x7E,F
07A0:  BC    07A6
07A2:  SUBWF  x7F,F
07A4:  BNC   07DA
07A6:  MOVF   x7A,W
07A8:  SUBWF  x7D,F
07AA:  BC    07B6
07AC:  MOVLW  01
07AE:  SUBWF  x7E,F
07B0:  BC    07B6
07B2:  SUBWF  x7F,F
07B4:  BNC   07DA
07B6:  MOVF   x79,W
07B8:  IORLW  80
07BA:  SUBWF  x7E,F
07BC:  BC    07C4
07BE:  MOVLW  01
07C0:  SUBWF  x7F,F
07C2:  BNC   07DA
07C4:  INCF   03,F
07C6:  BNZ   07DA
07C8:  INCF   02,F
07CA:  BNZ   07DA
07CC:  INCF   01,F
07CE:  BNZ   07DA
07D0:  INCF   00,F
07D2:  BZ    07EE
07D4:  RRCF   01,F
07D6:  RRCF   02,F
07D8:  RRCF   03,F
07DA:  MOVFF  75,80
07DE:  MOVF   x79,W
07E0:  XORWF  x80,F
07E2:  BTFSS  x80.7
07E4:  BRA    07EA
07E6:  BSF    01.7
07E8:  BRA    07F6
07EA:  BCF    01.7
07EC:  BRA    07F6
07EE:  CLRF   00
07F0:  CLRF   01
07F2:  CLRF   02
07F4:  CLRF   03
07F6:  RETURN 0
07F8:  MOVLW  80
07FA:  BTFSC  FD8.1
07FC:  XORWF  x95,F
07FE:  CLRF   x9A
0800:  CLRF   x9B
0802:  MOVFF  91,99
0806:  MOVF   x95,W
0808:  XORWF  x99,F
080A:  MOVF   x90,W
080C:  BTFSC  FD8.2
080E:  BRA    09C8
0810:  MOVWF  x98
0812:  MOVWF  00
0814:  MOVF   x94,W
0816:  BTFSC  FD8.2
0818:  BRA    09DA
081A:  SUBWF  x98,F
081C:  BTFSC  FD8.2
081E:  BRA    0922
0820:  BNC   089C
0822:  MOVFF  95,9E
0826:  BSF    x9E.7
0828:  MOVFF  96,9D
082C:  MOVFF  97,9C
0830:  CLRF   x9B
0832:  BCF    FD8.0
0834:  RRCF   x9E,F
0836:  RRCF   x9D,F
0838:  RRCF   x9C,F
083A:  RRCF   x9B,F
083C:  DECFSZ x98,F
083E:  BRA    0830
0840:  BTFSS  x99.7
0842:  BRA    084A
0844:  BSF    x9A.0
0846:  BRA    0A02
0848:  BCF    x9A.0
084A:  BCF    x98.0
084C:  BSF    x9A.4
084E:  CLRF   FEA
0850:  MOVLW  93
0852:  MOVWF  FE9
0854:  BRA    0A28
0856:  BCF    x9A.4
0858:  BTFSC  x99.7
085A:  BRA    0870
085C:  BTFSS  x98.0
085E:  BRA    0886
0860:  RRCF   x9E,F
0862:  RRCF   x9D,F
0864:  RRCF   x9C,F
0866:  RRCF   x9B,F
0868:  INCF   00,F
086A:  BTFSC  FD8.2
086C:  BRA    09F8
086E:  BRA    0886
0870:  BTFSC  x9E.7
0872:  BRA    088C
0874:  BCF    FD8.0
0876:  RLCF   x9B,F
0878:  RLCF   x9C,F
087A:  RLCF   x9D,F
087C:  RLCF   x9E,F
087E:  DECF   00,F
0880:  BTFSC  FD8.2
0882:  BRA    09F8
0884:  BRA    0870
0886:  BSF    x9A.6
0888:  BRA    0960
088A:  BCF    x9A.6
088C:  MOVFF  91,99
0890:  BTFSS  x91.7
0892:  BRA    0898
0894:  BSF    x9E.7
0896:  BRA    09EA
0898:  BCF    x9E.7
089A:  BRA    09EA
089C:  MOVFF  94,98
08A0:  MOVFF  94,00
08A4:  MOVF   x90,W
08A6:  SUBWF  x98,F
08A8:  MOVFF  91,9E
08AC:  BSF    x9E.7
08AE:  MOVFF  92,9D
08B2:  MOVFF  93,9C
08B6:  CLRF   x9B
08B8:  BCF    FD8.0
08BA:  RRCF   x9E,F
08BC:  RRCF   x9D,F
08BE:  RRCF   x9C,F
08C0:  RRCF   x9B,F
08C2:  DECFSZ x98,F
08C4:  BRA    08B6
08C6:  BTFSS  x99.7
08C8:  BRA    08D0
08CA:  BSF    x9A.1
08CC:  BRA    0A02
08CE:  BCF    x9A.1
08D0:  BCF    x98.0
08D2:  BSF    x9A.5
08D4:  CLRF   FEA
08D6:  MOVLW  97
08D8:  MOVWF  FE9
08DA:  BRA    0A28
08DC:  BCF    x9A.5
08DE:  BTFSC  x99.7
08E0:  BRA    08F6
08E2:  BTFSS  x98.0
08E4:  BRA    090C
08E6:  RRCF   x9E,F
08E8:  RRCF   x9D,F
08EA:  RRCF   x9C,F
08EC:  RRCF   x9B,F
08EE:  INCF   00,F
08F0:  BTFSC  FD8.2
08F2:  BRA    09F8
08F4:  BRA    090C
08F6:  BTFSC  x9E.7
08F8:  BRA    0912
08FA:  BCF    FD8.0
08FC:  RLCF   x9B,F
08FE:  RLCF   x9C,F
0900:  RLCF   x9D,F
0902:  RLCF   x9E,F
0904:  DECF   00,F
0906:  BTFSC  FD8.2
0908:  BRA    09F8
090A:  BRA    08F6
090C:  BSF    x9A.7
090E:  BRA    0960
0910:  BCF    x9A.7
0912:  MOVFF  95,99
0916:  BTFSS  x95.7
0918:  BRA    091E
091A:  BSF    x9E.7
091C:  BRA    09EA
091E:  BCF    x9E.7
0920:  BRA    09EA
0922:  MOVFF  95,9E
0926:  BSF    x9E.7
0928:  MOVFF  96,9D
092C:  MOVFF  97,9C
0930:  BTFSS  x99.7
0932:  BRA    093C
0934:  BCF    x9E.7
0936:  BSF    x9A.2
0938:  BRA    0A02
093A:  BCF    x9A.2
093C:  CLRF   x9B
093E:  BCF    x98.0
0940:  CLRF   FEA
0942:  MOVLW  93
0944:  MOVWF  FE9
0946:  BRA    0A28
0948:  BTFSC  x99.7
094A:  BRA    0984
094C:  MOVFF  91,99
0950:  BTFSS  x98.0
0952:  BRA    0960
0954:  RRCF   x9E,F
0956:  RRCF   x9D,F
0958:  RRCF   x9C,F
095A:  RRCF   x9B,F
095C:  INCF   00,F
095E:  BZ    09F8
0960:  BTFSS  x9B.7
0962:  BRA    097A
0964:  INCF   x9C,F
0966:  BNZ   097A
0968:  INCF   x9D,F
096A:  BNZ   097A
096C:  INCF   x9E,F
096E:  BNZ   097A
0970:  RRCF   x9E,F
0972:  RRCF   x9D,F
0974:  RRCF   x9C,F
0976:  INCF   00,F
0978:  BZ    09F8
097A:  BTFSC  x9A.6
097C:  BRA    088A
097E:  BTFSC  x9A.7
0980:  BRA    0910
0982:  BRA    09BC
0984:  MOVLW  80
0986:  XORWF  x9E,F
0988:  BTFSS  x9E.7
098A:  BRA    0994
098C:  BRA    0A02
098E:  MOVFF  95,99
0992:  BRA    09A8
0994:  MOVFF  91,99
0998:  MOVF   x9E,F
099A:  BNZ   09A8
099C:  MOVF   x9D,F
099E:  BNZ   09A8
09A0:  MOVF   x9C,F
09A2:  BNZ   09A8
09A4:  CLRF   00
09A6:  BRA    09EA
09A8:  BTFSC  x9E.7
09AA:  BRA    09BC
09AC:  BCF    FD8.0
09AE:  RLCF   x9B,F
09B0:  RLCF   x9C,F
09B2:  RLCF   x9D,F
09B4:  RLCF   x9E,F
09B6:  DECFSZ 00,F
09B8:  BRA    09A8
09BA:  BRA    09F8
09BC:  BTFSS  x99.7
09BE:  BRA    09C4
09C0:  BSF    x9E.7
09C2:  BRA    09EA
09C4:  BCF    x9E.7
09C6:  BRA    09EA
09C8:  MOVFF  94,00
09CC:  MOVFF  95,9E
09D0:  MOVFF  96,9D
09D4:  MOVFF  97,9C
09D8:  BRA    09EA
09DA:  MOVFF  90,00
09DE:  MOVFF  91,9E
09E2:  MOVFF  92,9D
09E6:  MOVFF  93,9C
09EA:  MOVFF  9E,01
09EE:  MOVFF  9D,02
09F2:  MOVFF  9C,03
09F6:  BRA    0A60
09F8:  CLRF   00
09FA:  CLRF   01
09FC:  CLRF   02
09FE:  CLRF   03
0A00:  BRA    0A60
0A02:  CLRF   x9B
0A04:  COMF   x9C,F
0A06:  COMF   x9D,F
0A08:  COMF   x9E,F
0A0A:  COMF   x9B,F
0A0C:  INCF   x9B,F
0A0E:  BNZ   0A1A
0A10:  INCF   x9C,F
0A12:  BNZ   0A1A
0A14:  INCF   x9D,F
0A16:  BNZ   0A1A
0A18:  INCF   x9E,F
0A1A:  BTFSC  x9A.0
0A1C:  BRA    0848
0A1E:  BTFSC  x9A.1
0A20:  BRA    08CE
0A22:  BTFSC  x9A.2
0A24:  BRA    093A
0A26:  BRA    098E
0A28:  MOVF   FEF,W
0A2A:  ADDWF  x9C,F
0A2C:  BNC   0A38
0A2E:  INCF   x9D,F
0A30:  BNZ   0A38
0A32:  INCF   x9E,F
0A34:  BTFSC  FD8.2
0A36:  BSF    x98.0
0A38:  MOVF   FED,F
0A3A:  MOVF   FEF,W
0A3C:  ADDWF  x9D,F
0A3E:  BNC   0A46
0A40:  INCF   x9E,F
0A42:  BTFSC  FD8.2
0A44:  BSF    x98.0
0A46:  MOVF   FED,F
0A48:  MOVF   FEF,W
0A4A:  BTFSC  FEF.7
0A4C:  BRA    0A50
0A4E:  XORLW  80
0A50:  ADDWF  x9E,F
0A52:  BTFSC  FD8.0
0A54:  BSF    x98.0
0A56:  BTFSC  x9A.4
0A58:  BRA    0856
0A5A:  BTFSC  x9A.5
0A5C:  BRA    08DC
0A5E:  BRA    0948
0A60:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
*
00F8:  CLRF   FEA
00FA:  MOVLW  71
00FC:  MOVWF  FE9
00FE:  MOVF   FEF,W
0100:  BZ    011E
0102:  MOVLW  0F
0104:  MOVWF  01
0106:  CLRF   00
0108:  DECFSZ 00,F
010A:  BRA    0108
010C:  DECFSZ 01,F
010E:  BRA    0106
0110:  MOVLW  8F
0112:  MOVWF  00
0114:  DECFSZ 00,F
0116:  BRA    0114
0118:  NOP   
011A:  DECFSZ FEF,F
011C:  BRA    0102
011E:  RETURN 0
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
0120:  MOVLW  08
0122:  MOVWF  01
0124:  MOVLW  11
0126:  MOVWF  00
0128:  DECFSZ 00,F
012A:  BRA    0128
012C:  BCF    F8C.7
012E:  BCF    F95.7
0130:  MOVLW  11
0132:  MOVWF  00
0134:  DECFSZ 00,F
0136:  BRA    0134
0138:  RLCF   x75,F
013A:  BCF    F8C.6
013C:  BTFSC  FD8.0
013E:  BSF    F95.6
0140:  BTFSS  FD8.0
0142:  BCF    F95.6
0144:  BSF    F95.7
0146:  BTFSS  F83.7
0148:  BRA    0146
014A:  DECFSZ 01,F
014C:  BRA    0124
014E:  MOVLW  11
0150:  MOVWF  00
0152:  DECFSZ 00,F
0154:  BRA    0152
0156:  BCF    F8C.7
0158:  BCF    F95.7
015A:  NOP   
015C:  BSF    F95.6
015E:  MOVLW  11
0160:  MOVWF  00
0162:  DECFSZ 00,F
0164:  BRA    0162
0166:  MOVLW  11
0168:  MOVWF  00
016A:  DECFSZ 00,F
016C:  BRA    016A
016E:  BSF    F95.7
0170:  BTFSS  F83.7
0172:  BRA    0170
0174:  CLRF   01
0176:  MOVLW  11
0178:  MOVWF  00
017A:  DECFSZ 00,F
017C:  BRA    017A
017E:  BTFSC  F83.6
0180:  BSF    01.0
0182:  BCF    F8C.7
0184:  BCF    F95.7
0186:  BCF    F8C.6
0188:  BCF    F95.6
018A:  RETURN 0
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
*
18F4:  CLRF   19
18F6:  CLRF   1A
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
*
1916:  CLRF   26
1918:  MOVF   FC1,W
191A:  ANDLW  C0
191C:  IORLW  0F
191E:  MOVWF  FC1
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
....................         delay_us(20); 
....................         i2c_write(LCD_ADDR); //the slave addresse 
....................         delay_us(20); 
....................         i2c_write(data); 
....................         delay_us(20); 
....................         i2c_stop(); 
....................         delay_us(20); 
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
....................         i2c_send_nibble(data); 
....................         data=data-4;       //toggle EN back to 0 
....................         i2c_send_nibble(data); 
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
....................     lcd_send_byte(0x10); 
....................     delay_ms(2); 
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x30); 
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x20); 
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
....................         lcd_send_byte(0x80); 
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0xC0); 
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x60); 
....................            //clears the display 
....................         lcd_clear(); 
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
*
18F8:  CLRF   21
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
....................       case 2:  address= lcd_line_two;     break; 
....................       case 3:  address= lcd_line_three;   break; 
....................       case 4:  address= lcd_line_four;    break; 
....................       default: address= lcd_line_one;     break;  
....................    } 
....................   
....................    address+=x-1; 
....................    data=address&0xF0; 
....................    lcd_send_byte(data); 
....................    data=address&0x0F; 
....................    data=data<<4; 
....................    lcd_send_byte(data); 
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
....................      case '\1': lcd_gotoxy(1,1);  break; 
....................      case '\2': lcd_gotoxy(1,2);  break; 
....................      case '\3': lcd_gotoxy(1,3);  break; 
....................      case '\4': lcd_gotoxy(1,4);  break; 
....................  
....................      default: 
....................         data=in_data&0xF0; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................         data=in_data&0x0F; 
....................         data=data<<4; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................      break; 
....................    } 
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
....................  
.................... const long carga= 0xE8AB; 
.................... extern int contador; 
.................... extern long pulso_timer; 
....................  
.................... void inicializar(); 
....................  
.................... void main() 
*
18E4:  CLRF   FF8
18E6:  BCF    FD0.7
18E8:  BSF    07.7
18EA:  BSF    20.0
18EC:  CLRF   24
18EE:  CLRF   23
18F0:  BSF    20.0
18F2:  BSF    20.0
*
18FA:  CLRF   22
18FC:  CLRF   25
18FE:  BSF    20.0
1900:  MOVLW  14
1902:  MOVWF  38
1904:  CLRF   58
1906:  CLRF   57
1908:  CLRF   56
190A:  CLRF   55
190C:  CLRF   5C
190E:  CLRF   5B
1910:  CLRF   5A
1912:  CLRF   59
1914:  CLRF   x61
*
1920:  MOVLW  07
1922:  MOVWF  FB4
.................... { 
....................  
.................... //declaracion de variables 
.................... //inicializacion de perifericos 
....................  
.................... 	inicializar() ; 
1924:  GOTO   037C
....................      
....................     set_timer1(carga); 
1928:  MOVLW  E8
192A:  MOVWF  FCF
192C:  MOVLW  AB
192E:  MOVWF  FCE
.................... 	while(1) 
.................... 	{ 
....................  
.................... 		maquina_estado(); 
1930:  BRA    11D2
1932:  BRA    1930
....................  
.................... 	} 
.................... } 
....................  
1934:  SLEEP 
.................... void Inicializar(){ 
....................     setup_timer_1( T1_INTERNAL|T1_DIV_BY_2); 
*
037C:  MOVLW  95
037E:  MOVWF  FCD
....................     setup_timer_0(T0_INTERNAL |T0_DIV_32); 
0380:  MOVLW  84
0382:  MOVWF  FD5
....................     set_timer0(0x0000); 
0384:  CLRF   FD7
0386:  CLRF   FD6
....................     set_tris_a(0xE8);// configuracion portA necesaria para la libreria control_ADC 
0388:  MOVLW  E8
038A:  MOVWF  F92
....................     set_tris_b(0xFD); 
038C:  MOVLW  FD
038E:  MOVWF  F93
....................     contador=0; 
0390:  CLRF   22
....................     lcd_init(); 
0392:  BRA    023A
....................     lcd_gotoxy(1,1); 
0394:  MOVLW  01
0396:  MOVWF  x71
0398:  MOVWF  x72
039A:  RCALL  0296
....................     printf(LCD_PUTC,"Primer prueba"); 
039C:  MOVLW  AE
039E:  MOVWF  FF6
03A0:  MOVLW  00
03A2:  MOVWF  FF7
03A4:  BRA    035A
....................     lcd_backlight=ON; 
03A6:  BSF    20.0
....................     enable_interrupts (INT_TIMER1); 
03A8:  BSF    F9D.0
....................     enable_interrupts (GLOBAL); 
03AA:  MOVLW  C0
03AC:  IORWF  FF2,F
....................     output_high (PIN_A0); //pone en alto el chipselect del AD7450 
03AE:  BSF    F89.0
....................     output_high (PIN_A1); // pone en alto el chipselect del MAX186 
03B0:  BSF    F89.1
03B2:  GOTO   1928 (RETURN)
.................... } 
....................  
....................  
.................... /** 
.................... *	\file funciones.c 
.................... *	\brief  
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
00CC:  DATA 25,66
00CE:  DATA 20,57
00D0:  DATA 68,20
00D2:  DATA 25,66
00D4:  DATA 20,6B
00D6:  DATA 57,68
00D8:  DATA 20,20
00DA:  DATA 20,20
00DC:  DATA 20,20
00DE:  DATA 20,20
00E0:  DATA 20,20
00E2:  DATA 20,20
00E4:  DATA 20,20
00E6:  DATA 00,00
00E8:  DATA 54,3D
00EA:  DATA 25,66
00EC:  DATA 20,20
00EE:  DATA 49,3D
00F0:  DATA 25,66
00F2:  DATA 20,20
00F4:  DATA 20,20
00F6:  DATA 20,00
*
052C:  MOVLW  8E
052E:  MOVWF  00
0530:  MOVFF  63,01
0534:  MOVFF  62,02
0538:  CLRF   03
053A:  BTFSS  x63.7
053C:  BRA    0548
053E:  COMF   01,F
0540:  COMF   02,F
0542:  INCF   02,F
0544:  BNZ   0548
0546:  INCF   01,F
0548:  MOVF   01,F
054A:  BNZ   055E
054C:  MOVFF  02,01
0550:  CLRF   02
0552:  MOVLW  08
0554:  SUBWF  00,F
0556:  MOVF   01,F
0558:  BNZ   055E
055A:  CLRF   00
055C:  BRA    0572
055E:  BCF    FD8.0
0560:  BTFSC  01.7
0562:  BRA    056C
0564:  RLCF   02,F
0566:  RLCF   01,F
0568:  DECF   00,F
056A:  BRA    055E
056C:  BTFSC  x63.7
056E:  BRA    0572
0570:  BCF    01.7
0572:  GOTO   1214 (RETURN)
*
0A62:  MOVFF  8D,94
0A66:  MOVF   x91,W
0A68:  XORWF  x94,F
0A6A:  BTFSS  x94.7
0A6C:  BRA    0A78
0A6E:  BCF    FD8.2
0A70:  BCF    FD8.0
0A72:  BTFSC  x8D.7
0A74:  BSF    FD8.0
0A76:  BRA    0AD6
0A78:  MOVFF  8D,94
0A7C:  MOVFF  90,95
0A80:  MOVF   x8C,W
0A82:  SUBWF  x95,F
0A84:  BZ    0A92
0A86:  BTFSS  x94.7
0A88:  BRA    0AD6
0A8A:  MOVF   FD8,W
0A8C:  XORLW  01
0A8E:  MOVWF  FD8
0A90:  BRA    0AD6
0A92:  MOVFF  91,95
0A96:  MOVF   x8D,W
0A98:  SUBWF  x95,F
0A9A:  BZ    0AA8
0A9C:  BTFSS  x94.7
0A9E:  BRA    0AD6
0AA0:  MOVF   FD8,W
0AA2:  XORLW  01
0AA4:  MOVWF  FD8
0AA6:  BRA    0AD6
0AA8:  MOVFF  92,95
0AAC:  MOVF   x8E,W
0AAE:  SUBWF  x95,F
0AB0:  BZ    0ABE
0AB2:  BTFSS  x94.7
0AB4:  BRA    0AD6
0AB6:  MOVF   FD8,W
0AB8:  XORLW  01
0ABA:  MOVWF  FD8
0ABC:  BRA    0AD6
0ABE:  MOVFF  93,95
0AC2:  MOVF   x8F,W
0AC4:  SUBWF  x95,F
0AC6:  BZ    0AD4
0AC8:  BTFSS  x94.7
0ACA:  BRA    0AD6
0ACC:  MOVF   FD8,W
0ACE:  XORLW  01
0AD0:  MOVWF  FD8
0AD2:  BRA    0AD6
0AD4:  BCF    FD8.0
0AD6:  RETURN 0
*
0BE2:  MOVLW  8E
0BE4:  MOVWF  00
0BE6:  MOVF   x8C,W
0BE8:  SUBWF  00,F
0BEA:  MOVFF  8D,02
0BEE:  MOVFF  8E,01
0BF2:  BSF    02.7
0BF4:  MOVF   00,F
0BF6:  BZ    0C0A
0BF8:  BCF    FD8.0
0BFA:  MOVF   02,F
0BFC:  BNZ   0C02
0BFE:  MOVF   01,F
0C00:  BZ    0C0A
0C02:  RRCF   02,F
0C04:  RRCF   01,F
0C06:  DECFSZ 00,F
0C08:  BRA    0BF8
0C0A:  BTFSS  x8D.7
0C0C:  BRA    0C18
0C0E:  COMF   01,F
0C10:  COMF   02,F
0C12:  INCF   01,F
0C14:  BTFSC  FD8.2
0C16:  INCF   02,F
0C18:  GOTO   0CC8 (RETURN)
*
0F62:  MOVF   x6F,W
0F64:  SUBLW  B6
0F66:  MOVWF  x6F
0F68:  CLRF   03
0F6A:  MOVFF  70,73
0F6E:  BSF    x70.7
0F70:  BCF    FD8.0
0F72:  RRCF   x70,F
0F74:  RRCF   x71,F
0F76:  RRCF   x72,F
0F78:  RRCF   03,F
0F7A:  RRCF   02,F
0F7C:  RRCF   01,F
0F7E:  RRCF   00,F
0F80:  DECFSZ x6F,F
0F82:  BRA    0F70
0F84:  BTFSS  x73.7
0F86:  BRA    0F9E
0F88:  COMF   00,F
0F8A:  COMF   01,F
0F8C:  COMF   02,F
0F8E:  COMF   03,F
0F90:  INCF   00,F
0F92:  BTFSC  FD8.2
0F94:  INCF   01,F
0F96:  BTFSC  FD8.2
0F98:  INCF   02,F
0F9A:  BTFSC  FD8.2
0F9C:  INCF   03,F
0F9E:  GOTO   1080 (RETURN)
0FA2:  BTFSC  FD8.1
0FA4:  BRA    0FAC
0FA6:  CLRF   FEA
0FA8:  MOVLW  77
0FAA:  MOVWF  FE9
0FAC:  CLRF   00
0FAE:  CLRF   01
0FB0:  CLRF   02
0FB2:  CLRF   03
0FB4:  CLRF   x77
0FB6:  CLRF   x78
0FB8:  CLRF   x79
0FBA:  CLRF   x7A
0FBC:  MOVF   x76,W
0FBE:  IORWF  x75,W
0FC0:  IORWF  x74,W
0FC2:  IORWF  x73,W
0FC4:  BZ    101E
0FC6:  MOVLW  20
0FC8:  MOVWF  x7B
0FCA:  BCF    FD8.0
0FCC:  RLCF   x6F,F
0FCE:  RLCF   x70,F
0FD0:  RLCF   x71,F
0FD2:  RLCF   x72,F
0FD4:  RLCF   x77,F
0FD6:  RLCF   x78,F
0FD8:  RLCF   x79,F
0FDA:  RLCF   x7A,F
0FDC:  MOVF   x76,W
0FDE:  SUBWF  x7A,W
0FE0:  BNZ   0FF2
0FE2:  MOVF   x75,W
0FE4:  SUBWF  x79,W
0FE6:  BNZ   0FF2
0FE8:  MOVF   x74,W
0FEA:  SUBWF  x78,W
0FEC:  BNZ   0FF2
0FEE:  MOVF   x73,W
0FF0:  SUBWF  x77,W
0FF2:  BNC   1012
0FF4:  MOVF   x73,W
0FF6:  SUBWF  x77,F
0FF8:  MOVF   x74,W
0FFA:  BTFSS  FD8.0
0FFC:  INCFSZ x74,W
0FFE:  SUBWF  x78,F
1000:  MOVF   x75,W
1002:  BTFSS  FD8.0
1004:  INCFSZ x75,W
1006:  SUBWF  x79,F
1008:  MOVF   x76,W
100A:  BTFSS  FD8.0
100C:  INCFSZ x76,W
100E:  SUBWF  x7A,F
1010:  BSF    FD8.0
1012:  RLCF   00,F
1014:  RLCF   01,F
1016:  RLCF   02,F
1018:  RLCF   03,F
101A:  DECFSZ x7B,F
101C:  BRA    0FCA
101E:  MOVFF  77,FEF
1022:  MOVFF  78,FEC
1026:  MOVFF  79,FEC
102A:  MOVFF  7A,FEC
102E:  RETURN 0
1030:  MOVF   FE9,W
1032:  MOVWF  x67
1034:  MOVF   x66,W
1036:  MOVWF  x69
1038:  BZ    106E
103A:  MOVFF  65,93
103E:  MOVFF  64,92
1042:  MOVFF  63,91
1046:  MOVFF  62,90
104A:  CLRF   x97
104C:  CLRF   x96
104E:  MOVLW  20
1050:  MOVWF  x95
1052:  MOVLW  82
1054:  MOVWF  x94
1056:  CALL   05AC
105A:  MOVFF  03,65
105E:  MOVFF  02,64
1062:  MOVFF  01,63
1066:  MOVFF  00,62
106A:  DECFSZ x69,F
106C:  BRA    103A
106E:  MOVFF  65,72
1072:  MOVFF  64,71
1076:  MOVFF  63,70
107A:  MOVFF  62,6F
107E:  BRA    0F62
1080:  MOVFF  03,65
1084:  MOVFF  02,64
1088:  MOVFF  01,63
108C:  MOVFF  00,62
1090:  BTFSS  x65.7
1092:  BRA    10AE
1094:  DECF   x67,F
1096:  BSF    x67.5
1098:  COMF   x62,F
109A:  COMF   x63,F
109C:  COMF   x64,F
109E:  COMF   x65,F
10A0:  INCF   x62,F
10A2:  BTFSC  FD8.2
10A4:  INCF   x63,F
10A6:  BTFSC  FD8.2
10A8:  INCF   x64,F
10AA:  BTFSC  FD8.2
10AC:  INCF   x65,F
10AE:  MOVLW  3B
10B0:  MOVWF  x6E
10B2:  MOVLW  9A
10B4:  MOVWF  x6D
10B6:  MOVLW  CA
10B8:  MOVWF  x6C
10BA:  CLRF   x6B
10BC:  MOVLW  0A
10BE:  MOVWF  x69
10C0:  MOVF   x66,W
10C2:  BTFSC  FD8.2
10C4:  INCF   x67,F
10C6:  BSF    FD8.1
10C8:  CLRF   FEA
10CA:  MOVLW  62
10CC:  MOVWF  FE9
10CE:  MOVFF  65,72
10D2:  MOVFF  64,71
10D6:  MOVFF  63,70
10DA:  MOVFF  62,6F
10DE:  MOVFF  6E,76
10E2:  MOVFF  6D,75
10E6:  MOVFF  6C,74
10EA:  MOVFF  6B,73
10EE:  RCALL  0FA2
10F0:  MOVF   01,W
10F2:  MOVF   00,F
10F4:  BNZ   1114
10F6:  INCF   x66,W
10F8:  SUBWF  x69,W
10FA:  BZ    1114
10FC:  MOVF   x67,W
10FE:  BZ    1118
1100:  ANDLW  0F
1102:  SUBWF  x69,W
1104:  BZ    1108
1106:  BC    117E
1108:  BTFSC  x67.7
110A:  BRA    117E
110C:  BTFSC  x67.6
110E:  BRA    1118
1110:  MOVLW  20
1112:  BRA    1174
1114:  MOVLW  20
1116:  ANDWF  x67,F
1118:  BTFSS  x67.5
111A:  BRA    1136
111C:  BCF    x67.5
111E:  MOVF   x66,W
1120:  BTFSS  FD8.2
1122:  DECF   x67,F
1124:  MOVF   00,W
1126:  MOVWF  x67
1128:  MOVLW  2D
112A:  MOVWF  x70
112C:  CALL   02EC
1130:  MOVF   x67,W
1132:  MOVWF  00
1134:  CLRF   x67
1136:  MOVF   x66,W
1138:  SUBWF  x69,W
113A:  BNZ   1152
113C:  MOVF   00,W
113E:  MOVWF  x67
1140:  MOVLW  2E
1142:  MOVWF  x70
1144:  CALL   02EC
1148:  MOVF   x67,W
114A:  MOVWF  00
114C:  MOVLW  20
114E:  ANDWF  x67,F
1150:  MOVLW  00
1152:  MOVLW  30
1154:  BTFSS  x67.5
1156:  BRA    1174
1158:  BCF    x67.5
115A:  MOVF   x66,W
115C:  BTFSS  FD8.2
115E:  DECF   x67,F
1160:  MOVF   00,W
1162:  MOVWF  x67
1164:  MOVLW  2D
1166:  MOVWF  x70
1168:  CALL   02EC
116C:  MOVF   x67,W
116E:  MOVWF  00
1170:  CLRF   x67
1172:  MOVLW  30
1174:  ADDWF  00,F
1176:  MOVFF  00,70
117A:  CALL   02EC
117E:  BCF    FD8.1
1180:  MOVFF  6E,72
1184:  MOVFF  6D,71
1188:  MOVFF  6C,70
118C:  MOVFF  6B,6F
1190:  CLRF   x76
1192:  CLRF   x75
1194:  CLRF   x74
1196:  MOVLW  0A
1198:  MOVWF  x73
119A:  RCALL  0FA2
119C:  MOVFF  03,6E
11A0:  MOVFF  02,6D
11A4:  MOVFF  01,6C
11A8:  MOVFF  00,6B
11AC:  DECFSZ x69,F
11AE:  BRA    10C6
11B0:  RETURN 0
11B2:  TBLRD*+
11B4:  MOVFF  FF6,63
11B8:  MOVFF  FF7,64
11BC:  MOVFF  FF5,70
11C0:  CALL   02EC
11C4:  MOVFF  63,FF6
11C8:  MOVFF  64,FF7
11CC:  DECFSZ x62,F
11CE:  BRA    11B2
11D0:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
.................... int contador = 0 ;int pulso_timer = 0 ; 
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
0AD8:  MOVFF  69,8F
0ADC:  MOVFF  68,8E
0AE0:  MOVFF  67,8D
0AE4:  MOVFF  66,8C
0AE8:  CLRF   x93
0AEA:  CLRF   x92
0AEC:  CLRF   x91
0AEE:  CLRF   x90
0AF0:  RCALL  0A62
0AF2:  BC    0AF6
0AF4:  BNZ   0B00
....................       return(0.0); 
0AF6:  CLRF   00
0AF8:  CLRF   01
0AFA:  CLRF   02
0AFC:  CLRF   03
0AFE:  BRA    0BE0
....................  
....................    y=x; 
0B00:  MOVFF  69,6D
0B04:  MOVFF  68,6C
0B08:  MOVFF  67,6B
0B0C:  MOVFF  66,6A
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
0B10:  CLRF   x73
0B12:  MOVLW  6A
0B14:  MOVWF  x72
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
0B16:  MOVFF  72,FE9
0B1A:  MOVFF  73,FEA
0B1E:  MOVF   FEF,W
0B20:  CLRF   x77
0B22:  MOVWF  x76
0B24:  MOVLW  7F
0B26:  ADDWF  x76,F
0B28:  MOVLW  00
0B2A:  ADDWFC x77,F
0B2C:  BCF    FD8.0
0B2E:  RRCF   x77,W
0B30:  RRCF   x76,W
0B32:  MOVFF  73,FEA
0B36:  MOVFF  72,FE9
0B3A:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0B3C:  MOVFF  6D,71
0B40:  MOVFF  6C,70
0B44:  MOVFF  6B,6F
0B48:  MOVFF  6A,6E
....................       y+=(x/y); 
0B4C:  MOVFF  69,77
0B50:  MOVFF  68,76
0B54:  MOVFF  67,75
0B58:  MOVFF  66,74
0B5C:  MOVFF  6D,7B
0B60:  MOVFF  6C,7A
0B64:  MOVFF  6B,79
0B68:  MOVFF  6A,78
0B6C:  RCALL  069E
0B6E:  BCF    FD8.1
0B70:  MOVFF  6D,93
0B74:  MOVFF  6C,92
0B78:  MOVFF  6B,91
0B7C:  MOVFF  6A,90
0B80:  MOVFF  03,97
0B84:  MOVFF  02,96
0B88:  MOVFF  01,95
0B8C:  MOVFF  00,94
0B90:  RCALL  07F8
0B92:  MOVFF  03,6D
0B96:  MOVFF  02,6C
0B9A:  MOVFF  01,6B
0B9E:  MOVFF  00,6A
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
0BA2:  MOVFF  72,FE9
0BA6:  MOVFF  73,FEA
0BAA:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
0BAC:  MOVFF  71,8F
0BB0:  MOVFF  70,8E
0BB4:  MOVFF  6F,8D
0BB8:  MOVFF  6E,8C
0BBC:  MOVFF  6D,93
0BC0:  MOVFF  6C,92
0BC4:  MOVFF  6B,91
0BC8:  MOVFF  6A,90
0BCC:  RCALL  0A62
0BCE:  BNZ   0B3C
....................  
....................    return(res); 
0BD0:  MOVFF  6E,00
0BD4:  MOVFF  6F,01
0BD8:  MOVFF  70,02
0BDC:  MOVFF  71,03
0BE0:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
0C1C:  CLRF   x71
0C1E:  CLRF   x70
0C20:  CLRF   x6F
0C22:  MOVLW  7F
0C24:  MOVWF  x6E
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
0C26:  MOVLW  7E
0C28:  MOVWF  x78
0C2A:  MOVLW  80
0C2C:  MOVWF  x79
0C2E:  CLRF   x7A
0C30:  CLRF   x7B
0C32:  MOVLW  7A
0C34:  MOVWF  x7C
0C36:  MOVLW  2A
0C38:  MOVWF  x7D
0C3A:  MOVLW  AA
0C3C:  MOVWF  x7E
0C3E:  MOVLW  A3
0C40:  MOVWF  x7F
0C42:  MOVLW  75
0C44:  MOVWF  x80
0C46:  MOVLW  B6
0C48:  MOVWF  x81
0C4A:  MOVLW  09
0C4C:  MOVWF  x82
0C4E:  MOVLW  B4
0C50:  MOVWF  x83
0C52:  MOVLW  6F
0C54:  MOVWF  x84
0C56:  MOVLW  4F
0C58:  MOVWF  x85
0C5A:  MOVLW  B6
0C5C:  MOVWF  x86
0C5E:  MOVLW  AA
0C60:  MOVWF  x87
0C62:  MOVLW  69
0C64:  MOVWF  x88
0C66:  MOVLW  8B
0C68:  MOVWF  x89
0C6A:  MOVLW  F6
0C6C:  MOVWF  x8A
0C6E:  MOVLW  E8
0C70:  MOVWF  x8B
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0C72:  MOVFF  65,8F
0C76:  MOVFF  64,8E
0C7A:  MOVFF  63,8D
0C7E:  MOVFF  62,8C
0C82:  CLRF   x93
0C84:  CLRF   x92
0C86:  CLRF   x91
0C88:  CLRF   x90
0C8A:  RCALL  0A62
0C8C:  BNC   0C94
0C8E:  MOVF   x63,W
0C90:  XORLW  80
0C92:  MOVWF  x63
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0C94:  MOVFF  65,93
0C98:  MOVFF  64,92
0C9C:  MOVFF  63,91
0CA0:  MOVFF  62,90
0CA4:  MOVLW  83
0CA6:  MOVWF  x97
0CA8:  MOVLW  F9
0CAA:  MOVWF  x96
0CAC:  MOVLW  22
0CAE:  MOVWF  x95
0CB0:  MOVLW  7E
0CB2:  MOVWF  x94
0CB4:  RCALL  05AC
0CB6:  MOVFF  03,8F
0CBA:  MOVFF  02,8E
0CBE:  MOVFF  01,8D
0CC2:  MOVFF  00,8C
0CC6:  BRA    0BE2
0CC8:  MOVFF  01,72
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0CCC:  MOVFF  65,93
0CD0:  MOVFF  64,92
0CD4:  MOVFF  63,91
0CD8:  MOVFF  62,90
0CDC:  MOVLW  83
0CDE:  MOVWF  x97
0CE0:  MOVLW  F9
0CE2:  MOVWF  x96
0CE4:  MOVLW  22
0CE6:  MOVWF  x95
0CE8:  MOVLW  7E
0CEA:  MOVWF  x94
0CEC:  RCALL  05AC
0CEE:  MOVFF  03,8F
0CF2:  MOVFF  02,8E
0CF6:  MOVFF  01,8D
0CFA:  MOVFF  00,8C
0CFE:  CLRF   x91
0D00:  MOVFF  72,90
0D04:  RCALL  0576
0D06:  BSF    FD8.1
0D08:  MOVFF  8F,93
0D0C:  MOVFF  8E,92
0D10:  MOVFF  8D,91
0D14:  MOVFF  8C,90
0D18:  MOVFF  03,97
0D1C:  MOVFF  02,96
0D20:  MOVFF  01,95
0D24:  MOVFF  00,94
0D28:  RCALL  07F8
0D2A:  MOVFF  03,77
0D2E:  MOVFF  02,76
0D32:  MOVFF  01,75
0D36:  MOVFF  00,74
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0D3A:  MOVLW  03
0D3C:  ANDWF  x72,F
....................  
....................    if (quad == 0 || quad == 2) 
0D3E:  MOVF   x72,F
0D40:  BZ    0D48
0D42:  MOVF   x72,W
0D44:  SUBLW  02
0D46:  BNZ   0D7C
....................       t = frac * PI_DIV_BY_TWO; 
0D48:  MOVFF  77,93
0D4C:  MOVFF  76,92
0D50:  MOVFF  75,91
0D54:  MOVFF  74,90
0D58:  MOVLW  DB
0D5A:  MOVWF  x97
0D5C:  MOVLW  0F
0D5E:  MOVWF  x96
0D60:  MOVLW  49
0D62:  MOVWF  x95
0D64:  MOVLW  7F
0D66:  MOVWF  x94
0D68:  RCALL  05AC
0D6A:  MOVFF  03,6D
0D6E:  MOVFF  02,6C
0D72:  MOVFF  01,6B
0D76:  MOVFF  00,6A
0D7A:  BRA    0E46
....................    else if (quad == 1) 
0D7C:  DECFSZ x72,W
0D7E:  BRA    0DE4
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0D80:  BSF    FD8.1
0D82:  CLRF   x93
0D84:  CLRF   x92
0D86:  CLRF   x91
0D88:  MOVLW  7F
0D8A:  MOVWF  x90
0D8C:  MOVFF  77,97
0D90:  MOVFF  76,96
0D94:  MOVFF  75,95
0D98:  MOVFF  74,94
0D9C:  RCALL  07F8
0D9E:  MOVFF  03,8F
0DA2:  MOVFF  02,8E
0DA6:  MOVFF  01,8D
0DAA:  MOVFF  00,8C
0DAE:  MOVFF  03,93
0DB2:  MOVFF  02,92
0DB6:  MOVFF  01,91
0DBA:  MOVFF  00,90
0DBE:  MOVLW  DB
0DC0:  MOVWF  x97
0DC2:  MOVLW  0F
0DC4:  MOVWF  x96
0DC6:  MOVLW  49
0DC8:  MOVWF  x95
0DCA:  MOVLW  7F
0DCC:  MOVWF  x94
0DCE:  CALL   05AC
0DD2:  MOVFF  03,6D
0DD6:  MOVFF  02,6C
0DDA:  MOVFF  01,6B
0DDE:  MOVFF  00,6A
0DE2:  BRA    0E46
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0DE4:  BSF    FD8.1
0DE6:  MOVFF  77,93
0DEA:  MOVFF  76,92
0DEE:  MOVFF  75,91
0DF2:  MOVFF  74,90
0DF6:  CLRF   x97
0DF8:  CLRF   x96
0DFA:  CLRF   x95
0DFC:  MOVLW  7F
0DFE:  MOVWF  x94
0E00:  RCALL  07F8
0E02:  MOVFF  03,8F
0E06:  MOVFF  02,8E
0E0A:  MOVFF  01,8D
0E0E:  MOVFF  00,8C
0E12:  MOVFF  03,93
0E16:  MOVFF  02,92
0E1A:  MOVFF  01,91
0E1E:  MOVFF  00,90
0E22:  MOVLW  DB
0E24:  MOVWF  x97
0E26:  MOVLW  0F
0E28:  MOVWF  x96
0E2A:  MOVLW  49
0E2C:  MOVWF  x95
0E2E:  MOVLW  7F
0E30:  MOVWF  x94
0E32:  CALL   05AC
0E36:  MOVFF  03,6D
0E3A:  MOVFF  02,6C
0E3E:  MOVFF  01,6B
0E42:  MOVFF  00,6A
....................  
....................    y = 1.0; 
0E46:  CLRF   x69
0E48:  CLRF   x68
0E4A:  CLRF   x67
0E4C:  MOVLW  7F
0E4E:  MOVWF  x66
....................    t = t * t; 
0E50:  MOVFF  6D,93
0E54:  MOVFF  6C,92
0E58:  MOVFF  6B,91
0E5C:  MOVFF  6A,90
0E60:  MOVFF  6D,97
0E64:  MOVFF  6C,96
0E68:  MOVFF  6B,95
0E6C:  MOVFF  6A,94
0E70:  CALL   05AC
0E74:  MOVFF  03,6D
0E78:  MOVFF  02,6C
0E7C:  MOVFF  01,6B
0E80:  MOVFF  00,6A
....................    for (i = 0; i <= 4; i++) 
0E84:  CLRF   x73
0E86:  MOVF   x73,W
0E88:  SUBLW  04
0E8A:  BNC   0F3E
....................    { 
....................       t2 = t2 * t; 
0E8C:  MOVFF  71,93
0E90:  MOVFF  70,92
0E94:  MOVFF  6F,91
0E98:  MOVFF  6E,90
0E9C:  MOVFF  6D,97
0EA0:  MOVFF  6C,96
0EA4:  MOVFF  6B,95
0EA8:  MOVFF  6A,94
0EAC:  CALL   05AC
0EB0:  MOVFF  03,71
0EB4:  MOVFF  02,70
0EB8:  MOVFF  01,6F
0EBC:  MOVFF  00,6E
....................       y = y + p[i] * t2; 
0EC0:  MOVF   x73,W
0EC2:  MULLW  04
0EC4:  MOVF   FF3,W
0EC6:  CLRF   03
0EC8:  ADDLW  78
0ECA:  MOVWF  FE9
0ECC:  MOVLW  00
0ECE:  ADDWFC 03,W
0ED0:  MOVWF  FEA
0ED2:  MOVFF  FEF,90
0ED6:  MOVFF  FEC,91
0EDA:  MOVFF  FEC,92
0EDE:  MOVFF  FEC,93
0EE2:  MOVFF  71,97
0EE6:  MOVFF  70,96
0EEA:  MOVFF  6F,95
0EEE:  MOVFF  6E,94
0EF2:  CALL   05AC
0EF6:  MOVFF  FEA,8D
0EFA:  MOVFF  FE9,8C
0EFE:  BCF    FD8.1
0F00:  MOVFF  69,93
0F04:  MOVFF  68,92
0F08:  MOVFF  67,91
0F0C:  MOVFF  66,90
0F10:  MOVFF  03,97
0F14:  MOVFF  02,96
0F18:  MOVFF  01,95
0F1C:  MOVFF  00,94
0F20:  RCALL  07F8
0F22:  MOVFF  8D,FEA
0F26:  MOVFF  8C,FE9
0F2A:  MOVFF  03,69
0F2E:  MOVFF  02,68
0F32:  MOVFF  01,67
0F36:  MOVFF  00,66
0F3A:  INCF   x73,F
0F3C:  BRA    0E86
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
0F3E:  MOVF   x72,W
0F40:  SUBLW  02
0F42:  BZ    0F48
0F44:  DECFSZ x72,W
0F46:  BRA    0F4E
....................       y = -y;  // correct sign 
0F48:  MOVF   x67,W
0F4A:  XORLW  80
0F4C:  MOVWF  x67
....................  
....................    return (y); 
0F4E:  MOVFF  66,00
0F52:  MOVFF  67,01
0F56:  MOVFF  68,02
0F5A:  MOVFF  69,03
0F5E:  GOTO   15DE (RETURN)
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
*
018C:  BSF    F95.6
018E:  MOVLW  11
0190:  MOVWF  00
0192:  DECFSZ 00,F
0194:  BRA    0192
0196:  BSF    F95.7
0198:  MOVLW  11
019A:  MOVWF  00
019C:  DECFSZ 00,F
019E:  BRA    019C
01A0:  BCF    F8C.6
01A2:  BCF    F95.6
01A4:  MOVLW  11
01A6:  MOVWF  00
01A8:  DECFSZ 00,F
01AA:  BRA    01A8
01AC:  BCF    F8C.7
01AE:  BCF    F95.7
....................         delay_us(20); 
01B0:  MOVLW  4F
01B2:  MOVWF  00
01B4:  DECFSZ 00,F
01B6:  BRA    01B4
01B8:  BRA    01BA
....................         i2c_write(LCD_ADDR); //the slave addresse 
01BA:  MOVLW  4E
01BC:  MOVWF  x75
01BE:  RCALL  0120
....................         delay_us(20); 
01C0:  MOVLW  4F
01C2:  MOVWF  00
01C4:  DECFSZ 00,F
01C6:  BRA    01C4
01C8:  BRA    01CA
....................         i2c_write(data); 
01CA:  MOVFF  74,75
01CE:  RCALL  0120
....................         delay_us(20); 
01D0:  MOVLW  4F
01D2:  MOVWF  00
01D4:  DECFSZ 00,F
01D6:  BRA    01D4
01D8:  BRA    01DA
....................         i2c_stop(); 
01DA:  BCF    F95.6
01DC:  NOP   
01DE:  BSF    F95.7
01E0:  BTFSS  F83.7
01E2:  BRA    01E0
01E4:  MOVLW  11
01E6:  MOVWF  00
01E8:  DECFSZ 00,F
01EA:  BRA    01E8
01EC:  BRA    01EE
01EE:  NOP   
01F0:  BSF    F95.6
01F2:  MOVLW  11
01F4:  MOVWF  00
01F6:  DECFSZ 00,F
01F8:  BRA    01F6
....................         delay_us(20); 
01FA:  MOVLW  4F
01FC:  MOVWF  00
01FE:  DECFSZ 00,F
0200:  BRA    01FE
0202:  BRA    0204
0204:  RETURN 0
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
0206:  BTFSS  20.0
0208:  BRA    0214
020A:  MOVF   x73,W
020C:  IORLW  04
020E:  IORLW  08
0210:  MOVWF  x73
0212:  BRA    0216
0214:  BSF    x73.2
....................         i2c_send_nibble(data); 
0216:  MOVFF  73,74
021A:  RCALL  018C
....................         data=data-4;       //toggle EN back to 0 
021C:  MOVLW  04
021E:  SUBWF  x73,F
....................         i2c_send_nibble(data); 
0220:  MOVFF  73,74
0224:  RCALL  018C
0226:  RETURN 0
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
0228:  CLRF   x73
022A:  RCALL  0206
....................     lcd_send_byte(0x10); 
022C:  MOVLW  10
022E:  MOVWF  x73
0230:  RCALL  0206
....................     delay_ms(2); 
0232:  MOVLW  02
0234:  MOVWF  x71
0236:  RCALL  00F8
0238:  RETURN 0
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
023A:  MOVLW  C8
023C:  MOVWF  x71
023E:  RCALL  00F8
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
0240:  CLRF   x73
0242:  RCALL  0206
....................         lcd_send_byte(0x10); 
0244:  MOVLW  10
0246:  MOVWF  x73
0248:  RCALL  0206
....................         lcd_send_byte(0x00); 
024A:  CLRF   x73
024C:  RCALL  0206
....................         lcd_send_byte(0x00); 
024E:  CLRF   x73
0250:  RCALL  0206
....................         lcd_send_byte(0x10); 
0252:  MOVLW  10
0254:  MOVWF  x73
0256:  RCALL  0206
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
0258:  MOVLW  30
025A:  MOVWF  x73
025C:  RCALL  0206
....................         lcd_send_byte(0x30); 
025E:  MOVLW  30
0260:  MOVWF  x73
0262:  RCALL  0206
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
0264:  MOVLW  30
0266:  MOVWF  x73
0268:  RCALL  0206
....................         lcd_send_byte(0x20); 
026A:  MOVLW  20
026C:  MOVWF  x73
026E:  RCALL  0206
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
0270:  MOVLW  20
0272:  MOVWF  x73
0274:  RCALL  0206
....................         lcd_send_byte(0x80); 
0276:  MOVLW  80
0278:  MOVWF  x73
027A:  RCALL  0206
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
027C:  CLRF   x73
027E:  RCALL  0206
....................         lcd_send_byte(0xC0); 
0280:  MOVLW  C0
0282:  MOVWF  x73
0284:  RCALL  0206
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
0286:  CLRF   x73
0288:  RCALL  0206
....................         lcd_send_byte(0x60); 
028A:  MOVLW  60
028C:  MOVWF  x73
028E:  RCALL  0206
....................            //clears the display 
....................         lcd_clear(); 
0290:  RCALL  0228
0292:  GOTO   0394 (RETURN)
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
0296:  MOVF   x72,W
0298:  XORLW  01
029A:  BZ    02AA
029C:  XORLW  03
029E:  BZ    02B0
02A0:  XORLW  01
02A2:  BZ    02B6
02A4:  XORLW  07
02A6:  BZ    02BC
02A8:  BRA    02C2
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
02AA:  MOVLW  80
02AC:  MOVWF  1F
02AE:  BRA    02C6
....................       case 2:  address= lcd_line_two;     break; 
02B0:  MOVLW  C0
02B2:  MOVWF  1F
02B4:  BRA    02C6
....................       case 3:  address= lcd_line_three;   break; 
02B6:  MOVLW  94
02B8:  MOVWF  1F
02BA:  BRA    02C6
....................       case 4:  address= lcd_line_four;    break; 
02BC:  MOVLW  D4
02BE:  MOVWF  1F
02C0:  BRA    02C6
....................       default: address= lcd_line_one;     break;  
02C2:  MOVLW  80
02C4:  MOVWF  1F
....................    } 
....................   
....................    address+=x-1; 
02C6:  MOVLW  01
02C8:  SUBWF  x71,W
02CA:  ADDWF  1F,F
....................    data=address&0xF0; 
02CC:  MOVF   1F,W
02CE:  ANDLW  F0
02D0:  MOVWF  26
....................    lcd_send_byte(data); 
02D2:  MOVFF  26,73
02D6:  RCALL  0206
....................    data=address&0x0F; 
02D8:  MOVF   1F,W
02DA:  ANDLW  0F
02DC:  MOVWF  26
....................    data=data<<4; 
02DE:  SWAPF  26,F
02E0:  MOVLW  F0
02E2:  ANDWF  26,F
....................    lcd_send_byte(data); 
02E4:  MOVFF  26,73
02E8:  RCALL  0206
02EA:  RETURN 0
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
02EC:  MOVF   x70,W
02EE:  XORLW  0C
02F0:  BZ    0304
02F2:  XORLW  0D
02F4:  BZ    0308
02F6:  XORLW  03
02F8:  BZ    0312
02FA:  XORLW  01
02FC:  BZ    031E
02FE:  XORLW  07
0300:  BZ    032A
0302:  BRA    0336
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
0304:  RCALL  0228
0306:  BRA    0358
....................      case '\1': lcd_gotoxy(1,1);  break; 
0308:  MOVLW  01
030A:  MOVWF  x71
030C:  MOVWF  x72
030E:  RCALL  0296
0310:  BRA    0358
....................      case '\2': lcd_gotoxy(1,2);  break; 
0312:  MOVLW  01
0314:  MOVWF  x71
0316:  MOVLW  02
0318:  MOVWF  x72
031A:  RCALL  0296
031C:  BRA    0358
....................      case '\3': lcd_gotoxy(1,3);  break; 
031E:  MOVLW  01
0320:  MOVWF  x71
0322:  MOVLW  03
0324:  MOVWF  x72
0326:  RCALL  0296
0328:  BRA    0358
....................      case '\4': lcd_gotoxy(1,4);  break; 
032A:  MOVLW  01
032C:  MOVWF  x71
032E:  MOVLW  04
0330:  MOVWF  x72
0332:  RCALL  0296
0334:  BRA    0358
....................  
....................      default: 
....................         data=in_data&0xF0; 
0336:  MOVF   x70,W
0338:  ANDLW  F0
033A:  MOVWF  x71
....................         data=data|RS; //set RS pin to 1 
033C:  BSF    x71.0
....................         lcd_send_byte(data); 
033E:  MOVFF  71,73
0342:  RCALL  0206
....................         data=in_data&0x0F; 
0344:  MOVF   x70,W
0346:  ANDLW  0F
0348:  MOVWF  x71
....................         data=data<<4; 
034A:  SWAPF  x71,F
034C:  MOVLW  F0
034E:  ANDWF  x71,F
....................         data=data|RS; //set RS pin to 1 
0350:  BSF    x71.0
....................         lcd_send_byte(data); 
0352:  MOVFF  71,73
0356:  RCALL  0206
....................      break; 
....................    } 
0358:  RETURN 0
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #include <Control_ADCs.h> 
.................... /*  
....................  * File:   MAX191.h 
....................  * Author: MARCOS 
....................  * 
....................  * Created on 23 de septiembre de 2016, 08:14 
....................  */ 
....................  
.................... #ifndef Control_ADCs_H 
.................... #define Control_ADCs_H 
....................  
.................... #define ADC_CSCorriente PIN_A0  // salida 
.................... #define ADC_CSTension PIN_A1 // salida 
.................... #define ADC_SCLK PIN_A2 // salida clock tension 
.................... #define ADC_SCLKcorr PIN_B1 
.................... #define ADC_DOUT PIN_B0  // entrada, por aqui ingresa la info del MAX186 
.................... #define ADC_DIN PIN_A4 //salida, se envia la informacion al MAX186 
.................... #define ADC_SSTRB PIN_A5//entrada 
.................... #define ADC_SDATA PIN_A3//entrada SDATA en AD7450 
....................  
.................... //control AD7450 
.................... signed long leer_Tension(){ 
*
03B6:  CLRF   x63
03B8:  CLRF   x62
....................     signed long dato=0,dato_t; 
....................     int i; 
....................     output_low (ADC_CSTension); 
03BA:  BCF    F92.1
03BC:  BCF    F89.1
....................     delay_us(1); 
03BE:  MOVLW  03
03C0:  MOVWF  00
03C2:  DECFSZ 00,F
03C4:  BRA    03C2
03C6:  BRA    03C8
....................     output_low (ADC_SCLK); 
03C8:  BCF    F92.2
03CA:  BCF    F89.2
....................     delay_us(1); 
03CC:  MOVLW  03
03CE:  MOVWF  00
03D0:  DECFSZ 00,F
03D2:  BRA    03D0
03D4:  BRA    03D6
....................     output_high (ADC_SCLK); 
03D6:  BCF    F92.2
03D8:  BSF    F89.2
....................     delay_us(1); 
03DA:  MOVLW  03
03DC:  MOVWF  00
03DE:  DECFSZ 00,F
03E0:  BRA    03DE
03E2:  BRA    03E4
....................      
....................         for(i=0;i<15;i++){ 
03E4:  CLRF   x66
03E6:  MOVF   x66,W
03E8:  SUBLW  0E
03EA:  BNC   041C
....................           shift_left(&dato,2,input(ADC_SDATA)); 
03EC:  BSF    F92.3
03EE:  BTFSC  F80.3
03F0:  BRA    03F6
03F2:  BCF    FD8.0
03F4:  BRA    03F8
03F6:  BSF    FD8.0
03F8:  RLCF   x62,F
03FA:  RLCF   x63,F
....................           output_low(ADC_SCLK); 
03FC:  BCF    F92.2
03FE:  BCF    F89.2
....................           delay_us(1);  
0400:  MOVLW  03
0402:  MOVWF  00
0404:  DECFSZ 00,F
0406:  BRA    0404
0408:  BRA    040A
....................           output_high(ADC_SCLK);  
040A:  BCF    F92.2
040C:  BSF    F89.2
....................           delay_us(1); 
040E:  MOVLW  03
0410:  MOVWF  00
0412:  DECFSZ 00,F
0414:  BRA    0412
0416:  BRA    0418
0418:  INCF   x66,F
041A:  BRA    03E6
....................         } 
....................  
....................        // output_high (ADC_SCLK); 
....................        // delay_us(1); 
....................         output_high (ADC_CSTension); 
041C:  BCF    F92.1
041E:  BSF    F89.1
....................          
....................        dato_t=(dato&0x0800); 
0420:  CLRF   x64
0422:  MOVF   x63,W
0424:  ANDLW  08
0426:  MOVWF  x65
....................          
....................       if (dato_t==0x0800){ 
0428:  MOVF   x64,F
042A:  BNZ   0446
042C:  MOVF   x65,W
042E:  SUBLW  08
0430:  BNZ   0446
....................             dato=-2048+(dato&0xF7FF); 
0432:  MOVFF  62,00
0436:  MOVF   x63,W
0438:  ANDLW  F7
043A:  MOVWF  03
043C:  MOVFF  62,62
0440:  MOVLW  F8
0442:  ADDWF  03,W
0444:  MOVWF  x63
....................       } 
....................     return(dato); 
0446:  MOVFF  62,01
044A:  MOVFF  63,02
044E:  GOTO   11F4 (RETURN)
.................... } 
....................  
.................... //control MAX186 
.................... long leer_Corriente(){ 
0452:  CLRF   x63
0454:  CLRF   x62
0456:  MOVLW  8E
0458:  MOVWF  x64
....................     long dato=0; 
....................     BYTE config= 0b10001110; 
....................     int i; 
....................     output_low (ADC_CSCorriente); 
045A:  BCF    F92.0
045C:  BCF    F89.0
....................     output_low (ADC_DIN); 
045E:  BCF    F92.4
0460:  BCF    F89.4
....................     delay_us(1); 
0462:  MOVLW  03
0464:  MOVWF  00
0466:  DECFSZ 00,F
0468:  BRA    0466
046A:  BRA    046C
....................      
....................     for(i=0; i<8; i++) { 
046C:  CLRF   x65
046E:  MOVF   x65,W
0470:  SUBLW  07
0472:  BNC   04A2
....................       output_bit(ADC_DIN, shift_left(&config,1,0)); 
0474:  BCF    FD8.0
0476:  RLCF   x64,F
0478:  BC    047E
047A:  BCF    F89.4
047C:  BRA    0480
047E:  BSF    F89.4
0480:  BCF    F92.4
....................       output_high(ADC_SCLKcorr); 
0482:  BCF    F93.1
0484:  BSF    F8A.1
....................       delay_us(1); 
0486:  MOVLW  03
0488:  MOVWF  00
048A:  DECFSZ 00,F
048C:  BRA    048A
048E:  BRA    0490
....................       output_low(ADC_SCLKcorr);	 
0490:  BCF    F93.1
0492:  BCF    F8A.1
....................       delay_us(1); 
0494:  MOVLW  03
0496:  MOVWF  00
0498:  DECFSZ 00,F
049A:  BRA    0498
049C:  BRA    049E
049E:  INCF   x65,F
04A0:  BRA    046E
....................    } 
....................  
....................     output_high(ADC_CSCorriente); 
04A2:  BCF    F92.0
04A4:  BSF    F89.0
....................      
....................     while(input(ADC_SSTRB)=='0');    
....................          
....................         output_low (ADC_CSCorriente); 
04A6:  BCF    F92.0
04A8:  BCF    F89.0
....................         output_high (ADC_SCLKcorr); 
04AA:  BCF    F93.1
04AC:  BSF    F8A.1
....................         delay_us(1); 
04AE:  MOVLW  03
04B0:  MOVWF  00
04B2:  DECFSZ 00,F
04B4:  BRA    04B2
04B6:  BRA    04B8
....................         output_low (ADC_SCLKcorr); 
04B8:  BCF    F93.1
04BA:  BCF    F8A.1
....................         delay_us(1); 
04BC:  MOVLW  03
04BE:  MOVWF  00
04C0:  DECFSZ 00,F
04C2:  BRA    04C0
04C4:  BRA    04C6
....................          
....................         for(i=0;i<15;i++){ 
04C6:  CLRF   x65
04C8:  MOVF   x65,W
04CA:  SUBLW  0E
04CC:  BNC   04FE
....................           output_high(ADC_SCLKcorr); 
04CE:  BCF    F93.1
04D0:  BSF    F8A.1
....................           delay_us(1); 
04D2:  MOVLW  03
04D4:  MOVWF  00
04D6:  DECFSZ 00,F
04D8:  BRA    04D6
04DA:  BRA    04DC
....................           shift_left(&dato,2,input(ADC_DOUT));  
04DC:  BSF    F93.0
04DE:  BTFSC  F81.0
04E0:  BRA    04E6
04E2:  BCF    FD8.0
04E4:  BRA    04E8
04E6:  BSF    FD8.0
04E8:  RLCF   x62,F
04EA:  RLCF   x63,F
....................           output_low(ADC_SCLKcorr); 
04EC:  BCF    F93.1
04EE:  BCF    F8A.1
....................           delay_us(1); 
04F0:  MOVLW  03
04F2:  MOVWF  00
04F4:  DECFSZ 00,F
04F6:  BRA    04F4
04F8:  BRA    04FA
04FA:  INCF   x65,F
04FC:  BRA    04C8
....................         } 
....................   
....................          
....................         output_high (ADC_CSCorriente); 
04FE:  BCF    F92.0
0500:  BSF    F89.0
....................      
....................        
....................     dato= (dato>>3)& 0x0FFF; 
0502:  RRCF   x63,W
0504:  MOVWF  x67
0506:  RRCF   x62,W
0508:  MOVWF  x66
050A:  RRCF   x67,F
050C:  RRCF   x66,F
050E:  RRCF   x67,F
0510:  RRCF   x66,F
0512:  MOVLW  1F
0514:  ANDWF  x67,F
0516:  MOVFF  66,62
051A:  MOVF   x67,W
051C:  ANDLW  0F
051E:  MOVWF  x63
....................     return(dato); 
0520:  MOVFF  62,01
0524:  MOVFF  63,02
0528:  GOTO   1200 (RETURN)
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //Implementacion Switch-Case 
....................  
.................... /** 
.................... *	\fn void maquina_estado() 
.................... *	\brief Implementacion Switch-Case 
.................... *	\details  
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
....................  **/ 
.................... signed long punto1; 
.................... long punto2; 
.................... float tiempo_potencia; 
.................... int16 tiempo_pottimer; 
.................... BYTE pos_V,pos_I,pos_V_A,pos_I_A; 
.................... int control_V; 
.................... int control_I; 
.................... int desfase; 
.................... int puntos=20;//puntos por periodo 
.................... float tension, corriente, tension_RMS,corriente_RMS, t_desfase, potencia_ins,angulo; 
.................... float Energia_Wms=0;//, Energia_Wh=0, Energia_kWh=0; 
.................... float Energia_Wh=0, Energia_kWh; 
.................... const long carga= 0xE8AB; 
....................  
.................... #INT_TIMER1               // interrupcion para demora de 1 ms 
.................... void interrtimer_0(){ 
....................     set_timer1(carga);   // interrupcion cada 1 ms 
*
00BC:  MOVLW  E8
00BE:  MOVWF  FCF
00C0:  MOVLW  AB
00C2:  MOVWF  FCE
....................     pulso_timer++; 
00C4:  INCF   25,F
....................  
00C6:  BCF    F9E.0
00C8:  GOTO   0060
....................    } 
....................  
.................... void maquina_estado() 
.................... { 
.................... 		static int estado = PUNTO_TENS_CORR; 
....................  
.................... 		switch(estado) 
*
11D2:  MOVF   x61,W
11D4:  XORLW  00
11D6:  BZ    11F0
11D8:  XORLW  01
11DA:  BZ    1248
11DC:  XORLW  03
11DE:  BTFSC  FD8.2
11E0:  BRA    13C2
11E2:  XORLW  01
11E4:  BTFSC  FD8.2
11E6:  BRA    1494
11E8:  XORLW  07
11EA:  BTFSC  FD8.2
11EC:  BRA    17EE
11EE:  BRA    18DE
.................... 		{ 
.................... 			case PUNTO_TENS_CORR: 
....................                 punto1= leer_Tension(); 
11F0:  GOTO   03B6
11F4:  MOVFF  02,28
11F8:  MOVFF  01,27
....................                 punto2= leer_Corriente(); // comprobar si funciona con el tiempo de demora de la lectura del externo 
11FC:  GOTO   0452
1200:  MOVFF  02,2A
1204:  MOVFF  01,29
....................                 // convierte los valores de long a float 
....................                 tension=punto1; 
1208:  MOVFF  28,63
120C:  MOVFF  27,62
1210:  GOTO   052C
1214:  MOVFF  03,3C
1218:  MOVFF  02,3B
121C:  MOVFF  01,3A
1220:  MOVFF  00,39
....................                 corriente=punto2; 
1224:  MOVFF  2A,91
1228:  MOVFF  29,90
122C:  CALL   0576
1230:  MOVFF  03,40
1234:  MOVFF  02,3F
1238:  MOVFF  01,3E
123C:  MOVFF  00,3D
....................                 contador++; 
1240:  INCF   22,F
.................... 					estado = CONVERSION_DESFASE; 
1242:  MOVLW  01
1244:  MOVWF  x61
....................  
.................... 				break; 
1246:  BRA    18E0
.................... 			 
.................... 			case CONVERSION_DESFASE: 
....................                 tension= (tension)*2.5/2048; 
1248:  MOVFF  3C,93
124C:  MOVFF  3B,92
1250:  MOVFF  3A,91
1254:  MOVFF  39,90
1258:  CLRF   x97
125A:  CLRF   x96
125C:  MOVLW  20
125E:  MOVWF  x95
1260:  MOVLW  80
1262:  MOVWF  x94
1264:  CALL   05AC
1268:  MOVFF  03,65
126C:  MOVFF  02,64
1270:  MOVFF  01,63
1274:  MOVFF  00,62
1278:  MOVFF  03,77
127C:  MOVFF  02,76
1280:  MOVFF  01,75
1284:  MOVFF  00,74
1288:  CLRF   x7B
128A:  CLRF   x7A
128C:  CLRF   x79
128E:  MOVLW  8A
1290:  MOVWF  x78
1292:  CALL   069E
1296:  MOVFF  03,3C
129A:  MOVFF  02,3B
129E:  MOVFF  01,3A
12A2:  MOVFF  00,39
....................                 corriente= (corriente)/1000-2.510; 
12A6:  MOVFF  40,77
12AA:  MOVFF  3F,76
12AE:  MOVFF  3E,75
12B2:  MOVFF  3D,74
12B6:  CLRF   x7B
12B8:  CLRF   x7A
12BA:  MOVLW  7A
12BC:  MOVWF  x79
12BE:  MOVLW  88
12C0:  MOVWF  x78
12C2:  CALL   069E
12C6:  MOVFF  03,65
12CA:  MOVFF  02,64
12CE:  MOVFF  01,63
12D2:  MOVFF  00,62
12D6:  BSF    FD8.1
12D8:  MOVFF  03,93
12DC:  MOVFF  02,92
12E0:  MOVFF  01,91
12E4:  MOVFF  00,90
12E8:  MOVLW  D7
12EA:  MOVWF  x97
12EC:  MOVLW  A3
12EE:  MOVWF  x96
12F0:  MOVLW  20
12F2:  MOVWF  x95
12F4:  MOVLW  80
12F6:  MOVWF  x94
12F8:  CALL   07F8
12FC:  MOVFF  03,40
1300:  MOVFF  02,3F
1304:  MOVFF  01,3E
1308:  MOVFF  00,3D
....................                 //se convierte a la tension y corriente real 
....................                 tension= tension*155.57; // conversion con 2 V igual a 311.13 V 
130C:  MOVFF  3C,93
1310:  MOVFF  3B,92
1314:  MOVFF  3A,91
1318:  MOVFF  39,90
131C:  MOVLW  EC
131E:  MOVWF  x97
1320:  MOVLW  91
1322:  MOVWF  x96
1324:  MOVLW  1B
1326:  MOVWF  x95
1328:  MOVLW  86
132A:  MOVWF  x94
132C:  CALL   05AC
1330:  MOVFF  03,3C
1334:  MOVFF  02,3B
1338:  MOVFF  01,3A
133C:  MOVFF  00,39
....................                 corriente= corriente*12; // 2.5 V es igual a +30 A (recordar que el sensor mide 30A) 
1340:  MOVFF  40,93
1344:  MOVFF  3F,92
1348:  MOVFF  3E,91
134C:  MOVFF  3D,90
1350:  CLRF   x97
1352:  CLRF   x96
1354:  MOVLW  40
1356:  MOVWF  x95
1358:  MOVLW  82
135A:  MOVWF  x94
135C:  CALL   05AC
1360:  MOVFF  03,40
1364:  MOVFF  02,3F
1368:  MOVFF  01,3E
136C:  MOVFF  00,3D
....................                  
....................                 // Analisis del punto POSITVO O NEGATIVO 
....................                 // valor positivo estado=0-- valor negativo estado=1 
....................                  
....................                 //TENSION 
....................                 #asm 
....................                 clrf &pos_V; 
1370:  CLRF   31
....................                 btfsc (&tension + 0x01), 7; 
1372:  BTFSC  3A.7
....................                 bsf &pos_V,0; 
1374:  BSF    31.0
....................                 #endasm 
.................... 				 
....................                 //CORRIENTE 
....................                 #asm 
....................                 clrf &pos_I; 
1376:  CLRF   32
....................                 btfsc (&corriente + 0x01), 7; // comprueba signo en un bit de los 4 byte del float 
1378:  BTFSC  3E.7
....................                 bsf &pos_I,0; 
137A:  BSF    32.0
....................                 #endasm 
....................  
....................                  
....................                  
.................... 				 
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contador distinto de cero) 
....................                 if (pos_V==1 && contador>=2 && pos_V_A==0 && desfase!=1){  
137C:  DECFSZ 31,W
137E:  BRA    1398
1380:  MOVF   22,W
1382:  SUBLW  01
1384:  BC    1398
1386:  MOVF   33,F
1388:  BNZ   1398
138A:  DECFSZ 37,W
138C:  BRA    1390
138E:  BRA    1398
....................                  control_V= contador; // tiempo en el que cruz la tension  
1390:  MOVFF  22,35
....................                  desfase=1; 
1394:  MOVLW  01
1396:  MOVWF  37
....................                 } 
....................                  
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_I==1 && contador>=2 && pos_I_A==0 && desfase!=2){ 
1398:  DECFSZ 32,W
139A:  BRA    13B4
139C:  MOVF   22,W
139E:  SUBLW  01
13A0:  BC    13B4
13A2:  MOVF   34,F
13A4:  BNZ   13B4
13A6:  MOVF   37,W
13A8:  SUBLW  02
13AA:  BZ    13B4
....................                      
....................                  control_I= contador; // tiempo en el que cruz la corriente 
13AC:  MOVFF  22,36
....................                  desfase=2; 
13B0:  MOVLW  02
13B2:  MOVWF  37
....................                 } 
....................                 // guarda el signo de los puntos anteriores 
....................                 pos_V_A=pos_V; 
13B4:  MOVFF  31,33
....................                 pos_I_A=pos_I; 
13B8:  MOVFF  32,34
....................                  
....................                  
.................... 					estado = TENS_CORR_RMS; 
13BC:  MOVLW  02
13BE:  MOVWF  x61
.................... 		 
.................... 				 
....................  
.................... 				break; 
13C0:  BRA    18E0
.................... //---------------------------------------------------------------------------------------------------- 
....................                  
.................... 			case TENS_CORR_RMS: 
.................... 			 
.................... 				if((contador<30)&& (pulso_timer==1)) 
13C2:  MOVF   22,W
13C4:  SUBLW  1D
13C6:  BNC   1492
13C8:  DECFSZ 25,W
13CA:  BRA    1492
.................... 				{ 
.................... 					tension_RMS=tension_RMS+ tension * tension;       //calcula tension eficaz 
13CC:  MOVFF  3C,93
13D0:  MOVFF  3B,92
13D4:  MOVFF  3A,91
13D8:  MOVFF  39,90
13DC:  MOVFF  3C,97
13E0:  MOVFF  3B,96
13E4:  MOVFF  3A,95
13E8:  MOVFF  39,94
13EC:  CALL   05AC
13F0:  BCF    FD8.1
13F2:  MOVFF  44,93
13F6:  MOVFF  43,92
13FA:  MOVFF  42,91
13FE:  MOVFF  41,90
1402:  MOVFF  03,97
1406:  MOVFF  02,96
140A:  MOVFF  01,95
140E:  MOVFF  00,94
1412:  CALL   07F8
1416:  MOVFF  03,44
141A:  MOVFF  02,43
141E:  MOVFF  01,42
1422:  MOVFF  00,41
....................                     corriente_RMS= corriente_RMS+ corriente * corriente; // calcula corriente eficaz 
1426:  MOVFF  40,93
142A:  MOVFF  3F,92
142E:  MOVFF  3E,91
1432:  MOVFF  3D,90
1436:  MOVFF  40,97
143A:  MOVFF  3F,96
143E:  MOVFF  3E,95
1442:  MOVFF  3D,94
1446:  CALL   05AC
144A:  BCF    FD8.1
144C:  MOVFF  48,93
1450:  MOVFF  47,92
1454:  MOVFF  46,91
1458:  MOVFF  45,90
145C:  MOVFF  03,97
1460:  MOVFF  02,96
1464:  MOVFF  01,95
1468:  MOVFF  00,94
146C:  CALL   07F8
1470:  MOVFF  03,48
1474:  MOVFF  02,47
1478:  MOVFF  01,46
147C:  MOVFF  00,45
....................                     pulso_timer=0; 
1480:  CLRF   25
....................                      
.................... 					estado = PUNTO_TENS_CORR; 
1482:  CLRF   x61
....................                      
....................                     if((contador== 29)){ 
1484:  MOVF   22,W
1486:  SUBLW  1D
1488:  BNZ   1492
.................... 					disable_interrupts(INT_TIMER1);// deshabilita la interrupcion para no entrar al timer 
148A:  BCF    F9D.0
....................                     contador=0; //se reinicia el contador, para comenzar nuevamente  
148C:  CLRF   22
.................... 					estado = CALCULO_POT_ENER; 
148E:  MOVLW  03
1490:  MOVWF  x61
.................... 				} 
.................... 				} 
.................... 				 
....................  
.................... 				break; 
1492:  BRA    18E0
....................                  
.................... //--------------------------------------------------------------------------------------------------------------------                 
.................... 			 
.................... 			case CALCULO_POT_ENER: // falta calculo de energia 
....................                 //calcula las raices para completar el calculo RMS 
.................... 				tension_RMS= sqrt(tension_RMS/30); 
1494:  MOVFF  44,77
1498:  MOVFF  43,76
149C:  MOVFF  42,75
14A0:  MOVFF  41,74
14A4:  CLRF   x7B
14A6:  CLRF   x7A
14A8:  MOVLW  70
14AA:  MOVWF  x79
14AC:  MOVLW  83
14AE:  MOVWF  x78
14B0:  CALL   069E
14B4:  MOVFF  03,65
14B8:  MOVFF  02,64
14BC:  MOVFF  01,63
14C0:  MOVFF  00,62
14C4:  MOVFF  03,69
14C8:  MOVFF  02,68
14CC:  MOVFF  01,67
14D0:  MOVFF  00,66
14D4:  CALL   0AD8
14D8:  MOVFF  03,44
14DC:  MOVFF  02,43
14E0:  MOVFF  01,42
14E4:  MOVFF  00,41
....................                 corriente_RMS= sqrt(corriente_RMS/30); 
14E8:  MOVFF  48,77
14EC:  MOVFF  47,76
14F0:  MOVFF  46,75
14F4:  MOVFF  45,74
14F8:  CLRF   x7B
14FA:  CLRF   x7A
14FC:  MOVLW  70
14FE:  MOVWF  x79
1500:  MOVLW  83
1502:  MOVWF  x78
1504:  CALL   069E
1508:  MOVFF  03,65
150C:  MOVFF  02,64
1510:  MOVFF  01,63
1514:  MOVFF  00,62
1518:  MOVFF  03,69
151C:  MOVFF  02,68
1520:  MOVFF  01,67
1524:  MOVFF  00,66
1528:  CALL   0AD8
152C:  MOVFF  03,48
1530:  MOVFF  02,47
1534:  MOVFF  01,46
1538:  MOVFF  00,45
....................                  
....................                 // se controla si se pudo calcular desfase en el estado anterior  
....................                 // se realiza las diferencia de cruce por cero y se convierte de tiempo a radianes 
....................                 angulo=0; 
153C:  CLRF   54
153E:  CLRF   53
1540:  CLRF   52
1542:  CLRF   51
....................                 if (desfase==2){ 
1544:  MOVF   37,W
1546:  SUBLW  02
1548:  BNZ   15CA
....................                     t_desfase= (control_I-control_V); 
154A:  MOVF   35,W
154C:  SUBWF  36,W
154E:  CLRF   x91
1550:  MOVWF  x90
1552:  CALL   0576
1556:  MOVFF  03,4C
155A:  MOVFF  02,4B
155E:  MOVFF  01,4A
1562:  MOVFF  00,49
....................                     angulo= (t_desfase*pi)/10;      // angulo de desfase en radianes. 20 puntos por periodo 
1566:  MOVFF  4C,93
156A:  MOVFF  4B,92
156E:  MOVFF  4A,91
1572:  MOVFF  49,90
1576:  MOVLW  DB
1578:  MOVWF  x97
157A:  MOVLW  0F
157C:  MOVWF  x96
157E:  MOVLW  49
1580:  MOVWF  x95
1582:  MOVLW  80
1584:  MOVWF  x94
1586:  CALL   05AC
158A:  MOVFF  03,65
158E:  MOVFF  02,64
1592:  MOVFF  01,63
1596:  MOVFF  00,62
159A:  MOVFF  03,77
159E:  MOVFF  02,76
15A2:  MOVFF  01,75
15A6:  MOVFF  00,74
15AA:  CLRF   x7B
15AC:  CLRF   x7A
15AE:  MOVLW  20
15B0:  MOVWF  x79
15B2:  MOVLW  82
15B4:  MOVWF  x78
15B6:  CALL   069E
15BA:  MOVFF  03,54
15BE:  MOVFF  02,53
15C2:  MOVFF  01,52
15C6:  MOVFF  00,51
....................                    /*  lcd_gotoxy(1,1); 
....................                      printf(LCD_PUTC,"desfase= %f       ",t_desfase); 
....................                      lcd_gotoxy(1,2); 
....................                      printf(LCD_PUTC,"angulo=%f        ",angulo); 
....................                      delay_ms(1000);*/ 
....................                 }                 
....................                  
....................                 angulo=cos(angulo); 
15CA:  MOVFF  54,65
15CE:  MOVFF  53,64
15D2:  MOVFF  52,63
15D6:  MOVFF  51,62
15DA:  GOTO   0C1C
15DE:  MOVFF  03,54
15E2:  MOVFF  02,53
15E6:  MOVFF  01,52
15EA:  MOVFF  00,51
....................                // calculo de potencia  
....................                 potencia_ins= tension_RMS*corriente_RMS*angulo; 
15EE:  MOVFF  44,93
15F2:  MOVFF  43,92
15F6:  MOVFF  42,91
15FA:  MOVFF  41,90
15FE:  MOVFF  48,97
1602:  MOVFF  47,96
1606:  MOVFF  46,95
160A:  MOVFF  45,94
160E:  CALL   05AC
1612:  MOVFF  03,65
1616:  MOVFF  02,64
161A:  MOVFF  01,63
161E:  MOVFF  00,62
1622:  MOVFF  03,93
1626:  MOVFF  02,92
162A:  MOVFF  01,91
162E:  MOVFF  00,90
1632:  MOVFF  54,97
1636:  MOVFF  53,96
163A:  MOVFF  52,95
163E:  MOVFF  51,94
1642:  CALL   05AC
1646:  MOVFF  03,50
164A:  MOVFF  02,4F
164E:  MOVFF  01,4E
1652:  MOVFF  00,4D
....................                 //se limpian las variables para la prxima etapa de muestreo 
....................                 control_V=0;       
1656:  CLRF   35
....................                 control_I=0; 
1658:  CLRF   36
....................                 //angulo=0; 
....................                 desfase=0;  
165A:  CLRF   37
....................                  
....................                 //Calculo de Energia 
....................                 tiempo_pottimer=get_timer0(); 
165C:  MOVF   FD6,W
165E:  MOVWF  2F
1660:  MOVFF  FD7,30
....................                 tiempo_potencia=(float)65536 - tiempo_pottimer;    //variable para calcular energia segun tiempo de potencia 
1664:  MOVFF  30,91
1668:  MOVFF  2F,90
166C:  CALL   0576
1670:  BSF    FD8.1
1672:  CLRF   x93
1674:  CLRF   x92
1676:  CLRF   x91
1678:  MOVLW  8F
167A:  MOVWF  x90
167C:  MOVFF  03,97
1680:  MOVFF  02,96
1684:  MOVFF  01,95
1688:  MOVFF  00,94
168C:  CALL   07F8
1690:  MOVFF  03,2E
1694:  MOVFF  02,2D
1698:  MOVFF  01,2C
169C:  MOVFF  00,2B
....................                 tiempo_potencia=tiempo_potencia/375; 
16A0:  MOVFF  2E,77
16A4:  MOVFF  2D,76
16A8:  MOVFF  2C,75
16AC:  MOVFF  2B,74
16B0:  CLRF   x7B
16B2:  MOVLW  80
16B4:  MOVWF  x7A
16B6:  MOVLW  3B
16B8:  MOVWF  x79
16BA:  MOVLW  87
16BC:  MOVWF  x78
16BE:  CALL   069E
16C2:  MOVFF  03,2E
16C6:  MOVFF  02,2D
16CA:  MOVFF  01,2C
16CE:  MOVFF  00,2B
....................                 Energia_Wms=Energia_Wms+potencia_ins*tiempo_potencia;             //Energia en Watt por milisegundo 
16D2:  MOVFF  50,93
16D6:  MOVFF  4F,92
16DA:  MOVFF  4E,91
16DE:  MOVFF  4D,90
16E2:  MOVFF  2E,97
16E6:  MOVFF  2D,96
16EA:  MOVFF  2C,95
16EE:  MOVFF  2B,94
16F2:  CALL   05AC
16F6:  BCF    FD8.1
16F8:  MOVFF  58,93
16FC:  MOVFF  57,92
1700:  MOVFF  56,91
1704:  MOVFF  55,90
1708:  MOVFF  03,97
170C:  MOVFF  02,96
1710:  MOVFF  01,95
1714:  MOVFF  00,94
1718:  CALL   07F8
171C:  MOVFF  03,58
1720:  MOVFF  02,57
1724:  MOVFF  01,56
1728:  MOVFF  00,55
....................                  
....................                 if(Energia_Wms>=3600000){ 
172C:  CLRF   x8F
172E:  MOVLW  BA
1730:  MOVWF  x8E
1732:  MOVLW  5B
1734:  MOVWF  x8D
1736:  MOVLW  94
1738:  MOVWF  x8C
173A:  MOVFF  58,93
173E:  MOVFF  57,92
1742:  MOVFF  56,91
1746:  MOVFF  55,90
174A:  CALL   0A62
174E:  BC    1752
1750:  BNZ   178A
....................                     Energia_Wh=Energia_Wh+1;  // relacion watt ms a watt hora 
1752:  BCF    FD8.1
1754:  MOVFF  5C,93
1758:  MOVFF  5B,92
175C:  MOVFF  5A,91
1760:  MOVFF  59,90
1764:  CLRF   x97
1766:  CLRF   x96
1768:  CLRF   x95
176A:  MOVLW  7F
176C:  MOVWF  x94
176E:  CALL   07F8
1772:  MOVFF  03,5C
1776:  MOVFF  02,5B
177A:  MOVFF  01,5A
177E:  MOVFF  00,59
....................                     Energia_Wms=0;                 
1782:  CLRF   58
1784:  CLRF   57
1786:  CLRF   56
1788:  CLRF   55
....................                 } 
....................                  
....................                 if (Energia_Wh==1000){ 
178A:  MOVFF  5C,8F
178E:  MOVFF  5B,8E
1792:  MOVFF  5A,8D
1796:  MOVFF  59,8C
179A:  CLRF   x93
179C:  CLRF   x92
179E:  MOVLW  7A
17A0:  MOVWF  x91
17A2:  MOVLW  88
17A4:  MOVWF  x90
17A6:  CALL   0A62
17AA:  BNZ   17E4
....................                     Energia_kWh=Energia_kWh+1; 
17AC:  BCF    FD8.1
17AE:  MOVFF  60,93
17B2:  MOVFF  5F,92
17B6:  MOVFF  5E,91
17BA:  MOVFF  5D,90
17BE:  CLRF   x97
17C0:  CLRF   x96
17C2:  CLRF   x95
17C4:  MOVLW  7F
17C6:  MOVWF  x94
17C8:  CALL   07F8
17CC:  MOVFF  03,60
17D0:  MOVFF  02,5F
17D4:  MOVFF  01,5E
17D8:  MOVFF  00,5D
....................                     Energia_Wh=0; 
17DC:  CLRF   5C
17DE:  CLRF   5B
17E0:  CLRF   5A
17E2:  CLRF   59
....................                 } 
....................                  
....................                  
....................                  
....................                 // Se reinicia timer 0 nuevamente, para volver a calcular energia 
....................                   
....................                 set_timer0(0x0000); 
17E4:  CLRF   FD7
17E6:  CLRF   FD6
....................                  
.................... 					estado = MOSTRAR_DATOS; 
17E8:  MOVLW  04
17EA:  MOVWF  x61
.................... 				break; 
17EC:  BRA    18E0
....................                  
.................... //------------------------------------------------------------------------------------- 
....................                  
.................... 			case MOSTRAR_DATOS: 
....................                 //este estado solo muestra los datos en la pantalla LCD 
....................                 lcd_gotoxy(1,1); 
17EE:  MOVLW  01
17F0:  MOVWF  x71
17F2:  MOVWF  x72
17F4:  CALL   0296
....................                 printf(LCD_PUTC,"%f Wh %f kWh              ",Energia_Wh,Energia_kWh); 
17F8:  MOVLW  89
17FA:  MOVWF  FE9
17FC:  MOVFF  5C,65
1800:  MOVFF  5B,64
1804:  MOVFF  5A,63
1808:  MOVFF  59,62
180C:  MOVLW  02
180E:  MOVWF  x66
1810:  RCALL  1030
1812:  MOVLW  CE
1814:  MOVWF  FF6
1816:  MOVLW  00
1818:  MOVWF  FF7
181A:  MOVLW  04
181C:  MOVWF  x62
181E:  RCALL  11B2
1820:  MOVLW  89
1822:  MOVWF  FE9
1824:  MOVFF  60,65
1828:  MOVFF  5F,64
182C:  MOVFF  5E,63
1830:  MOVFF  5D,62
1834:  MOVLW  02
1836:  MOVWF  x66
1838:  CALL   1030
183C:  MOVLW  D4
183E:  MOVWF  FF6
1840:  MOVLW  00
1842:  MOVWF  FF7
1844:  MOVLW  12
1846:  MOVWF  x62
1848:  RCALL  11B2
....................                 lcd_gotoxy(1,2); 
184A:  MOVLW  01
184C:  MOVWF  x71
184E:  MOVLW  02
1850:  MOVWF  x72
1852:  CALL   0296
....................                 printf (LCD_PUTC, "T=\%f  I=\%f     ",tension_RMS,corriente_RMS); 
1856:  MOVLW  54
1858:  MOVWF  x70
185A:  CALL   02EC
185E:  MOVLW  3D
1860:  MOVWF  x70
1862:  CALL   02EC
1866:  MOVLW  89
1868:  MOVWF  FE9
186A:  MOVFF  44,65
186E:  MOVFF  43,64
1872:  MOVFF  42,63
1876:  MOVFF  41,62
187A:  MOVLW  02
187C:  MOVWF  x66
187E:  CALL   1030
1882:  MOVLW  EC
1884:  MOVWF  FF6
1886:  MOVLW  00
1888:  MOVWF  FF7
188A:  MOVLW  04
188C:  MOVWF  x62
188E:  RCALL  11B2
1890:  MOVLW  89
1892:  MOVWF  FE9
1894:  MOVFF  48,65
1898:  MOVFF  47,64
189C:  MOVFF  46,63
18A0:  MOVFF  45,62
18A4:  MOVLW  02
18A6:  MOVWF  x66
18A8:  CALL   1030
18AC:  MOVLW  F2
18AE:  MOVWF  FF6
18B0:  MOVLW  00
18B2:  MOVWF  FF7
18B4:  MOVLW  05
18B6:  MOVWF  x62
18B8:  RCALL  11B2
....................                 //delay_ms(1000); 
....................                 enable_interrupts(INT_TIMER1); 
18BA:  BSF    F9D.0
....................                 enable_interrupts(GLOBAL); 
18BC:  MOVLW  C0
18BE:  IORWF  FF2,F
....................                 pulso_timer=0; 
18C0:  CLRF   25
....................                 set_timer1(carga);    
18C2:  MOVLW  E8
18C4:  MOVWF  FCF
18C6:  MOVLW  AB
18C8:  MOVWF  FCE
.................... 				//reinicia todo 
....................                 corriente_RMS=0; 
18CA:  CLRF   48
18CC:  CLRF   47
18CE:  CLRF   46
18D0:  CLRF   45
....................                 tension_RMS=0; 
18D2:  CLRF   44
18D4:  CLRF   43
18D6:  CLRF   42
18D8:  CLRF   41
....................                  
.................... 				estado = PUNTO_TENS_CORR; 
18DA:  CLRF   x61
.................... 		 
....................  
.................... 				break; 
18DC:  BRA    18E0
.................... 			 
.................... 			default: estado = PUNTO_TENS_CORR; 
18DE:  CLRF   x61
.................... 		} 
18E0:  GOTO   1932 (RETURN)
....................  
....................  
.................... } 
....................  
.................... //Funciones asociadas a los eventos 
....................  
.................... /** 
.................... *	\fn int -(void) 
.................... *	\brief Resumen 
.................... *	\details Detalles 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 4C07   PLL12 CPUDIV1 NOUSBDIV HS FCMEN NOIESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
