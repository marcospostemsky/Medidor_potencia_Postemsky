CCS PCH C Compiler, Version 5.048, 5967               31-oct-16 08:15

               Filename:   C:\Users\MARCOS\Proyecto_final\Med_pot.X\dist\default\production\Med_pot.X.production.lst

               ROM used:   5808 bytes (18%)
                           Largest free fragment is 26956
               RAM used:   79 (4%) at main() level
                           145 (7%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   1676
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   00AE
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #import(file="build/default/production/main.o") 
.................... #import(file="build/default/production/funciones.o") 
.................... /** 
.................... *	\file main.c 
.................... *	\brief Resumen del contenido del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
027A:  MOVLW  8E
027C:  MOVWF  00
027E:  MOVFF  82,01
0282:  MOVFF  81,02
0286:  CLRF   03
0288:  MOVF   01,F
028A:  BNZ   029E
028C:  MOVFF  02,01
0290:  CLRF   02
0292:  MOVLW  08
0294:  SUBWF  00,F
0296:  MOVF   01,F
0298:  BNZ   029E
029A:  CLRF   00
029C:  BRA    02AE
029E:  BCF    FD8.0
02A0:  BTFSC  01.7
02A2:  BRA    02AC
02A4:  RLCF   02,F
02A6:  RLCF   01,F
02A8:  DECF   00,F
02AA:  BRA    029E
02AC:  BCF    01.7
02AE:  RETURN 0
02B0:  MOVF   x81,W
02B2:  BTFSC  FD8.2
02B4:  BRA    0398
02B6:  MOVWF  00
02B8:  MOVF   x85,W
02BA:  BTFSC  FD8.2
02BC:  BRA    0398
02BE:  ADDWF  00,F
02C0:  BNC   02CA
02C2:  MOVLW  81
02C4:  ADDWF  00,F
02C6:  BC    0398
02C8:  BRA    02D2
02CA:  MOVLW  7F
02CC:  SUBWF  00,F
02CE:  BNC   0398
02D0:  BZ    0398
02D2:  MOVFF  82,89
02D6:  MOVF   x86,W
02D8:  XORWF  x89,F
02DA:  BSF    x82.7
02DC:  BSF    x86.7
02DE:  MOVF   x84,W
02E0:  MULWF  x88
02E2:  MOVFF  FF4,8B
02E6:  MOVF   x83,W
02E8:  MULWF  x87
02EA:  MOVFF  FF4,03
02EE:  MOVFF  FF3,8A
02F2:  MULWF  x88
02F4:  MOVF   FF3,W
02F6:  ADDWF  x8B,F
02F8:  MOVF   FF4,W
02FA:  ADDWFC x8A,F
02FC:  MOVLW  00
02FE:  ADDWFC 03,F
0300:  MOVF   x84,W
0302:  MULWF  x87
0304:  MOVF   FF3,W
0306:  ADDWF  x8B,F
0308:  MOVF   FF4,W
030A:  ADDWFC x8A,F
030C:  MOVLW  00
030E:  CLRF   02
0310:  ADDWFC 03,F
0312:  ADDWFC 02,F
0314:  MOVF   x82,W
0316:  MULWF  x88
0318:  MOVF   FF3,W
031A:  ADDWF  x8A,F
031C:  MOVF   FF4,W
031E:  ADDWFC 03,F
0320:  MOVLW  00
0322:  ADDWFC 02,F
0324:  MOVF   x82,W
0326:  MULWF  x87
0328:  MOVF   FF3,W
032A:  ADDWF  03,F
032C:  MOVF   FF4,W
032E:  ADDWFC 02,F
0330:  MOVLW  00
0332:  CLRF   01
0334:  ADDWFC 01,F
0336:  MOVF   x84,W
0338:  MULWF  x86
033A:  MOVF   FF3,W
033C:  ADDWF  x8A,F
033E:  MOVF   FF4,W
0340:  ADDWFC 03,F
0342:  MOVLW  00
0344:  ADDWFC 02,F
0346:  ADDWFC 01,F
0348:  MOVF   x83,W
034A:  MULWF  x86
034C:  MOVF   FF3,W
034E:  ADDWF  03,F
0350:  MOVF   FF4,W
0352:  ADDWFC 02,F
0354:  MOVLW  00
0356:  ADDWFC 01,F
0358:  MOVF   x82,W
035A:  MULWF  x86
035C:  MOVF   FF3,W
035E:  ADDWF  02,F
0360:  MOVF   FF4,W
0362:  ADDWFC 01,F
0364:  INCF   00,F
0366:  BTFSC  01.7
0368:  BRA    0374
036A:  RLCF   x8A,F
036C:  RLCF   03,F
036E:  RLCF   02,F
0370:  RLCF   01,F
0372:  DECF   00,F
0374:  MOVLW  00
0376:  BTFSS  x8A.7
0378:  BRA    038E
037A:  INCF   03,F
037C:  ADDWFC 02,F
037E:  ADDWFC 01,F
0380:  MOVF   01,W
0382:  BNZ   038E
0384:  MOVF   02,W
0386:  BNZ   038E
0388:  MOVF   03,W
038A:  BNZ   038E
038C:  INCF   00,F
038E:  BTFSC  x89.7
0390:  BSF    01.7
0392:  BTFSS  x89.7
0394:  BCF    01.7
0396:  BRA    03A0
0398:  CLRF   00
039A:  CLRF   01
039C:  CLRF   02
039E:  CLRF   03
03A0:  RETURN 0
03A2:  MOVF   x61,W
03A4:  BTFSC  FD8.2
03A6:  BRA    04F2
03A8:  MOVWF  x6D
03AA:  MOVF   x65,W
03AC:  BTFSC  FD8.2
03AE:  BRA    04F2
03B0:  SUBWF  x6D,F
03B2:  BNC   03BE
03B4:  MOVLW  7F
03B6:  ADDWF  x6D,F
03B8:  BTFSC  FD8.0
03BA:  BRA    04F2
03BC:  BRA    03CA
03BE:  MOVLW  81
03C0:  SUBWF  x6D,F
03C2:  BTFSS  FD8.0
03C4:  BRA    04F2
03C6:  BTFSC  FD8.2
03C8:  BRA    04F2
03CA:  MOVFF  6D,00
03CE:  CLRF   01
03D0:  CLRF   02
03D2:  CLRF   03
03D4:  CLRF   x6C
03D6:  MOVFF  62,6B
03DA:  BSF    x6B.7
03DC:  MOVFF  63,6A
03E0:  MOVFF  64,69
03E4:  MOVLW  19
03E6:  MOVWF  x6D
03E8:  MOVF   x68,W
03EA:  SUBWF  x69,F
03EC:  BC    0408
03EE:  MOVLW  01
03F0:  SUBWF  x6A,F
03F2:  BC    0408
03F4:  SUBWF  x6B,F
03F6:  BC    0408
03F8:  SUBWF  x6C,F
03FA:  BC    0408
03FC:  INCF   x6C,F
03FE:  INCF   x6B,F
0400:  INCF   x6A,F
0402:  MOVF   x68,W
0404:  ADDWF  x69,F
0406:  BRA    0458
0408:  MOVF   x67,W
040A:  SUBWF  x6A,F
040C:  BC    0432
040E:  MOVLW  01
0410:  SUBWF  x6B,F
0412:  BC    0432
0414:  SUBWF  x6C,F
0416:  BC    0432
0418:  INCF   x6C,F
041A:  INCF   x6B,F
041C:  MOVF   x67,W
041E:  ADDWF  x6A,F
0420:  MOVF   x68,W
0422:  ADDWF  x69,F
0424:  BNC   0458
0426:  INCF   x6A,F
0428:  BNZ   0458
042A:  INCF   x6B,F
042C:  BNZ   0458
042E:  INCF   x6C,F
0430:  BRA    0458
0432:  MOVF   x66,W
0434:  IORLW  80
0436:  SUBWF  x6B,F
0438:  BC    0456
043A:  MOVLW  01
043C:  SUBWF  x6C,F
043E:  BC    0456
0440:  INCF   x6C,F
0442:  MOVF   x66,W
0444:  IORLW  80
0446:  ADDWF  x6B,F
0448:  MOVF   x67,W
044A:  ADDWF  x6A,F
044C:  BNC   0420
044E:  INCF   x6B,F
0450:  BNZ   0420
0452:  INCF   x6C,F
0454:  BRA    0420
0456:  BSF    03.0
0458:  DECFSZ x6D,F
045A:  BRA    045E
045C:  BRA    0474
045E:  BCF    FD8.0
0460:  RLCF   x69,F
0462:  RLCF   x6A,F
0464:  RLCF   x6B,F
0466:  RLCF   x6C,F
0468:  BCF    FD8.0
046A:  RLCF   03,F
046C:  RLCF   02,F
046E:  RLCF   01,F
0470:  RLCF   x6E,F
0472:  BRA    03E8
0474:  BTFSS  x6E.0
0476:  BRA    0484
0478:  BCF    FD8.0
047A:  RRCF   01,F
047C:  RRCF   02,F
047E:  RRCF   03,F
0480:  RRCF   x6E,F
0482:  BRA    0488
0484:  DECF   00,F
0486:  BZ    04F2
0488:  BTFSC  x6E.7
048A:  BRA    04C8
048C:  BCF    FD8.0
048E:  RLCF   x69,F
0490:  RLCF   x6A,F
0492:  RLCF   x6B,F
0494:  RLCF   x6C,F
0496:  MOVF   x68,W
0498:  SUBWF  x69,F
049A:  BC    04AA
049C:  MOVLW  01
049E:  SUBWF  x6A,F
04A0:  BC    04AA
04A2:  SUBWF  x6B,F
04A4:  BC    04AA
04A6:  SUBWF  x6C,F
04A8:  BNC   04DE
04AA:  MOVF   x67,W
04AC:  SUBWF  x6A,F
04AE:  BC    04BA
04B0:  MOVLW  01
04B2:  SUBWF  x6B,F
04B4:  BC    04BA
04B6:  SUBWF  x6C,F
04B8:  BNC   04DE
04BA:  MOVF   x66,W
04BC:  IORLW  80
04BE:  SUBWF  x6B,F
04C0:  BC    04C8
04C2:  MOVLW  01
04C4:  SUBWF  x6C,F
04C6:  BNC   04DE
04C8:  INCF   03,F
04CA:  BNZ   04DE
04CC:  INCF   02,F
04CE:  BNZ   04DE
04D0:  INCF   01,F
04D2:  BNZ   04DE
04D4:  INCF   00,F
04D6:  BZ    04F2
04D8:  RRCF   01,F
04DA:  RRCF   02,F
04DC:  RRCF   03,F
04DE:  MOVFF  62,6D
04E2:  MOVF   x66,W
04E4:  XORWF  x6D,F
04E6:  BTFSS  x6D.7
04E8:  BRA    04EE
04EA:  BSF    01.7
04EC:  BRA    04FA
04EE:  BCF    01.7
04F0:  BRA    04FA
04F2:  CLRF   00
04F4:  CLRF   01
04F6:  CLRF   02
04F8:  CLRF   03
04FA:  RETURN 0
04FC:  MOVLW  80
04FE:  BTFSC  FD8.1
0500:  XORWF  x86,F
0502:  CLRF   x8B
0504:  CLRF   x8C
0506:  MOVFF  82,8A
050A:  MOVF   x86,W
050C:  XORWF  x8A,F
050E:  MOVF   x81,W
0510:  BTFSC  FD8.2
0512:  BRA    06CC
0514:  MOVWF  x89
0516:  MOVWF  00
0518:  MOVF   x85,W
051A:  BTFSC  FD8.2
051C:  BRA    06DE
051E:  SUBWF  x89,F
0520:  BTFSC  FD8.2
0522:  BRA    0626
0524:  BNC   05A0
0526:  MOVFF  86,8F
052A:  BSF    x8F.7
052C:  MOVFF  87,8E
0530:  MOVFF  88,8D
0534:  CLRF   x8C
0536:  BCF    FD8.0
0538:  RRCF   x8F,F
053A:  RRCF   x8E,F
053C:  RRCF   x8D,F
053E:  RRCF   x8C,F
0540:  DECFSZ x89,F
0542:  BRA    0534
0544:  BTFSS  x8A.7
0546:  BRA    054E
0548:  BSF    x8B.0
054A:  BRA    0706
054C:  BCF    x8B.0
054E:  BCF    x89.0
0550:  BSF    x8B.4
0552:  CLRF   FEA
0554:  MOVLW  84
0556:  MOVWF  FE9
0558:  BRA    072C
055A:  BCF    x8B.4
055C:  BTFSC  x8A.7
055E:  BRA    0574
0560:  BTFSS  x89.0
0562:  BRA    058A
0564:  RRCF   x8F,F
0566:  RRCF   x8E,F
0568:  RRCF   x8D,F
056A:  RRCF   x8C,F
056C:  INCF   00,F
056E:  BTFSC  FD8.2
0570:  BRA    06FC
0572:  BRA    058A
0574:  BTFSC  x8F.7
0576:  BRA    0590
0578:  BCF    FD8.0
057A:  RLCF   x8C,F
057C:  RLCF   x8D,F
057E:  RLCF   x8E,F
0580:  RLCF   x8F,F
0582:  DECF   00,F
0584:  BTFSC  FD8.2
0586:  BRA    06FC
0588:  BRA    0574
058A:  BSF    x8B.6
058C:  BRA    0664
058E:  BCF    x8B.6
0590:  MOVFF  82,8A
0594:  BTFSS  x82.7
0596:  BRA    059C
0598:  BSF    x8F.7
059A:  BRA    06EE
059C:  BCF    x8F.7
059E:  BRA    06EE
05A0:  MOVFF  85,89
05A4:  MOVFF  85,00
05A8:  MOVF   x81,W
05AA:  SUBWF  x89,F
05AC:  MOVFF  82,8F
05B0:  BSF    x8F.7
05B2:  MOVFF  83,8E
05B6:  MOVFF  84,8D
05BA:  CLRF   x8C
05BC:  BCF    FD8.0
05BE:  RRCF   x8F,F
05C0:  RRCF   x8E,F
05C2:  RRCF   x8D,F
05C4:  RRCF   x8C,F
05C6:  DECFSZ x89,F
05C8:  BRA    05BA
05CA:  BTFSS  x8A.7
05CC:  BRA    05D4
05CE:  BSF    x8B.1
05D0:  BRA    0706
05D2:  BCF    x8B.1
05D4:  BCF    x89.0
05D6:  BSF    x8B.5
05D8:  CLRF   FEA
05DA:  MOVLW  88
05DC:  MOVWF  FE9
05DE:  BRA    072C
05E0:  BCF    x8B.5
05E2:  BTFSC  x8A.7
05E4:  BRA    05FA
05E6:  BTFSS  x89.0
05E8:  BRA    0610
05EA:  RRCF   x8F,F
05EC:  RRCF   x8E,F
05EE:  RRCF   x8D,F
05F0:  RRCF   x8C,F
05F2:  INCF   00,F
05F4:  BTFSC  FD8.2
05F6:  BRA    06FC
05F8:  BRA    0610
05FA:  BTFSC  x8F.7
05FC:  BRA    0616
05FE:  BCF    FD8.0
0600:  RLCF   x8C,F
0602:  RLCF   x8D,F
0604:  RLCF   x8E,F
0606:  RLCF   x8F,F
0608:  DECF   00,F
060A:  BTFSC  FD8.2
060C:  BRA    06FC
060E:  BRA    05FA
0610:  BSF    x8B.7
0612:  BRA    0664
0614:  BCF    x8B.7
0616:  MOVFF  86,8A
061A:  BTFSS  x86.7
061C:  BRA    0622
061E:  BSF    x8F.7
0620:  BRA    06EE
0622:  BCF    x8F.7
0624:  BRA    06EE
0626:  MOVFF  86,8F
062A:  BSF    x8F.7
062C:  MOVFF  87,8E
0630:  MOVFF  88,8D
0634:  BTFSS  x8A.7
0636:  BRA    0640
0638:  BCF    x8F.7
063A:  BSF    x8B.2
063C:  BRA    0706
063E:  BCF    x8B.2
0640:  CLRF   x8C
0642:  BCF    x89.0
0644:  CLRF   FEA
0646:  MOVLW  84
0648:  MOVWF  FE9
064A:  BRA    072C
064C:  BTFSC  x8A.7
064E:  BRA    0688
0650:  MOVFF  82,8A
0654:  BTFSS  x89.0
0656:  BRA    0664
0658:  RRCF   x8F,F
065A:  RRCF   x8E,F
065C:  RRCF   x8D,F
065E:  RRCF   x8C,F
0660:  INCF   00,F
0662:  BZ    06FC
0664:  BTFSS  x8C.7
0666:  BRA    067E
0668:  INCF   x8D,F
066A:  BNZ   067E
066C:  INCF   x8E,F
066E:  BNZ   067E
0670:  INCF   x8F,F
0672:  BNZ   067E
0674:  RRCF   x8F,F
0676:  RRCF   x8E,F
0678:  RRCF   x8D,F
067A:  INCF   00,F
067C:  BZ    06FC
067E:  BTFSC  x8B.6
0680:  BRA    058E
0682:  BTFSC  x8B.7
0684:  BRA    0614
0686:  BRA    06C0
0688:  MOVLW  80
068A:  XORWF  x8F,F
068C:  BTFSS  x8F.7
068E:  BRA    0698
0690:  BRA    0706
0692:  MOVFF  86,8A
0696:  BRA    06AC
0698:  MOVFF  82,8A
069C:  MOVF   x8F,F
069E:  BNZ   06AC
06A0:  MOVF   x8E,F
06A2:  BNZ   06AC
06A4:  MOVF   x8D,F
06A6:  BNZ   06AC
06A8:  CLRF   00
06AA:  BRA    06EE
06AC:  BTFSC  x8F.7
06AE:  BRA    06C0
06B0:  BCF    FD8.0
06B2:  RLCF   x8C,F
06B4:  RLCF   x8D,F
06B6:  RLCF   x8E,F
06B8:  RLCF   x8F,F
06BA:  DECFSZ 00,F
06BC:  BRA    06AC
06BE:  BRA    06FC
06C0:  BTFSS  x8A.7
06C2:  BRA    06C8
06C4:  BSF    x8F.7
06C6:  BRA    06EE
06C8:  BCF    x8F.7
06CA:  BRA    06EE
06CC:  MOVFF  85,00
06D0:  MOVFF  86,8F
06D4:  MOVFF  87,8E
06D8:  MOVFF  88,8D
06DC:  BRA    06EE
06DE:  MOVFF  81,00
06E2:  MOVFF  82,8F
06E6:  MOVFF  83,8E
06EA:  MOVFF  84,8D
06EE:  MOVFF  8F,01
06F2:  MOVFF  8E,02
06F6:  MOVFF  8D,03
06FA:  BRA    0764
06FC:  CLRF   00
06FE:  CLRF   01
0700:  CLRF   02
0702:  CLRF   03
0704:  BRA    0764
0706:  CLRF   x8C
0708:  COMF   x8D,F
070A:  COMF   x8E,F
070C:  COMF   x8F,F
070E:  COMF   x8C,F
0710:  INCF   x8C,F
0712:  BNZ   071E
0714:  INCF   x8D,F
0716:  BNZ   071E
0718:  INCF   x8E,F
071A:  BNZ   071E
071C:  INCF   x8F,F
071E:  BTFSC  x8B.0
0720:  BRA    054C
0722:  BTFSC  x8B.1
0724:  BRA    05D2
0726:  BTFSC  x8B.2
0728:  BRA    063E
072A:  BRA    0692
072C:  MOVF   FEF,W
072E:  ADDWF  x8D,F
0730:  BNC   073C
0732:  INCF   x8E,F
0734:  BNZ   073C
0736:  INCF   x8F,F
0738:  BTFSC  FD8.2
073A:  BSF    x89.0
073C:  MOVF   FED,F
073E:  MOVF   FEF,W
0740:  ADDWF  x8E,F
0742:  BNC   074A
0744:  INCF   x8F,F
0746:  BTFSC  FD8.2
0748:  BSF    x89.0
074A:  MOVF   FED,F
074C:  MOVF   FEF,W
074E:  BTFSC  FEF.7
0750:  BRA    0754
0752:  XORLW  80
0754:  ADDWF  x8F,F
0756:  BTFSC  FD8.0
0758:  BSF    x89.0
075A:  BTFSC  x8B.4
075C:  BRA    055A
075E:  BTFSC  x8B.5
0760:  BRA    05E0
0762:  BRA    064C
0764:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
*
0A44:  CLRF   FEA
0A46:  MOVLW  5E
0A48:  MOVWF  FE9
0A4A:  MOVF   FEF,W
0A4C:  BZ    0A6A
0A4E:  MOVLW  0F
0A50:  MOVWF  01
0A52:  CLRF   00
0A54:  DECFSZ 00,F
0A56:  BRA    0A54
0A58:  DECFSZ 01,F
0A5A:  BRA    0A52
0A5C:  MOVLW  8F
0A5E:  MOVWF  00
0A60:  DECFSZ 00,F
0A62:  BRA    0A60
0A64:  NOP   
0A66:  DECFSZ FEF,F
0A68:  BRA    0A4E
0A6A:  RETURN 0
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
*
08E6:  MOVLW  08
08E8:  MOVWF  01
08EA:  MOVLW  11
08EC:  MOVWF  00
08EE:  DECFSZ 00,F
08F0:  BRA    08EE
08F2:  BCF    F8C.7
08F4:  BCF    F95.7
08F6:  MOVLW  11
08F8:  MOVWF  00
08FA:  DECFSZ 00,F
08FC:  BRA    08FA
08FE:  RLCF   x62,F
0900:  BCF    F8C.6
0902:  BTFSC  FD8.0
0904:  BSF    F95.6
0906:  BTFSS  FD8.0
0908:  BCF    F95.6
090A:  BSF    F95.7
090C:  BTFSS  F83.7
090E:  BRA    090C
0910:  DECFSZ 01,F
0912:  BRA    08EA
0914:  MOVLW  11
0916:  MOVWF  00
0918:  DECFSZ 00,F
091A:  BRA    0918
091C:  BCF    F8C.7
091E:  BCF    F95.7
0920:  NOP   
0922:  BSF    F95.6
0924:  MOVLW  11
0926:  MOVWF  00
0928:  DECFSZ 00,F
092A:  BRA    0928
092C:  MOVLW  11
092E:  MOVWF  00
0930:  DECFSZ 00,F
0932:  BRA    0930
0934:  BSF    F95.7
0936:  BTFSS  F83.7
0938:  BRA    0936
093A:  CLRF   01
093C:  MOVLW  11
093E:  MOVWF  00
0940:  DECFSZ 00,F
0942:  BRA    0940
0944:  BTFSC  F83.6
0946:  BSF    01.0
0948:  BCF    F8C.7
094A:  BCF    F95.7
094C:  BCF    F8C.6
094E:  BCF    F95.6
0950:  RETURN 0
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
*
1694:  CLRF   24
1696:  MOVF   FC1,W
1698:  ANDLW  C0
169A:  IORLW  0F
169C:  MOVWF  FC1
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
*
1682:  CLRF   19
1684:  CLRF   1A
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
....................         delay_us(20); 
....................         i2c_write(LCD_ADDR); //the slave addresse 
....................         delay_us(20); 
....................         i2c_write(data); 
....................         delay_us(20); 
....................         i2c_stop(); 
....................         delay_us(20); 
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
....................         i2c_send_nibble(data); 
....................         data=data-4;       //toggle EN back to 0 
....................         i2c_send_nibble(data); 
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
....................     lcd_send_byte(0x10); 
....................     delay_ms(2); 
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x30); 
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x20); 
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
....................         lcd_send_byte(0x80); 
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0xC0); 
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x60); 
....................            //clears the display 
....................         lcd_clear(); 
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
1686:  CLRF   21
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
....................       case 2:  address= lcd_line_two;     break; 
....................       case 3:  address= lcd_line_three;   break; 
....................       case 4:  address= lcd_line_four;    break; 
....................       default: address= lcd_line_one;     break;  
....................    } 
....................   
....................    address+=x-1; 
....................    data=address&0xF0; 
....................    lcd_send_byte(data); 
....................    data=address&0x0F; 
....................    data=data<<4; 
....................    lcd_send_byte(data); 
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
....................      case '\1': lcd_gotoxy(1,1);  break; 
....................      case '\2': lcd_gotoxy(1,2);  break; 
....................      case '\3': lcd_gotoxy(1,3);  break; 
....................      case '\4': lcd_gotoxy(1,4);  break; 
....................  
....................      default: 
....................         data=in_data&0xF0; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................         data=in_data&0x0F; 
....................         data=data<<4; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................      break; 
....................    } 
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
....................  
.................... const long carga= 0xE8AB; 
.................... extern int contador; 
.................... extern long pulso_timer; 
....................  
.................... void inicializar(); 
....................  
.................... void main() 
*
1676:  CLRF   FF8
1678:  BCF    FD0.7
167A:  BSF    07.7
167C:  BSF    20.0
167E:  BSF    20.0
1680:  BSF    20.0
*
1688:  CLRF   22
168A:  CLRF   23
168C:  BSF    20.0
168E:  CLRF   4C
1690:  CLRF   4E
1692:  CLRF   4D
*
169E:  MOVLW  07
16A0:  MOVWF  FB4
.................... { 
....................  
.................... //declaracion de variables 
.................... //inicializacion de perifericos 
....................  
.................... 	inicializar() ; 
16A2:  GOTO   00F0
....................      
....................     set_timer0(carga); 
16A6:  MOVLW  E8
16A8:  MOVWF  FD7
16AA:  MOVLW  AB
16AC:  MOVWF  FD6
.................... 	while(1) 
.................... 	{ 
....................  
.................... 		maquina_estado(); 
16AE:  BRA    1102
16B0:  BRA    16AE
....................  
.................... 	} 
.................... } 
....................  
16B2:  SLEEP 
.................... void Inicializar(){ 
....................     setup_timer_0( RTCC_INTERNAL | T0_DIV_2); 
*
00F0:  MOVLW  80
00F2:  MOVWF  FD5
....................     set_tris_a(0xF9); 
00F4:  MOVLW  F9
00F6:  MOVWF  F92
....................     contador=0; 
00F8:  CLRF   22
....................   /*  lcd_init(); 
....................     lcd_gotoxy(1,1); 
....................     printf(LCD_PUTC,"Primer prueba"); 
....................     lcd_backlight=ON;*/ 
....................     enable_interrupts (INT_RTCC); 
00FA:  BSF    FF2.5
....................     enable_interrupts (GLOBAL); 
00FC:  MOVLW  C0
00FE:  IORWF  FF2,F
....................     output_high (PIN_A0); //pone en alto el chipselect del AD7450 
0100:  BSF    F89.0
....................     output_high (PIN_A1); // pone en alto el chipselect del MAX186 
0102:  BSF    F89.1
0104:  GOTO   16A6 (RETURN)
.................... } 
....................  
....................  
.................... /** 
.................... *	\file funciones.c 
.................... *	\brief  
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
00BE:  DATA 53,65
00C0:  DATA 20,6D
00C2:  DATA 69,64
00C4:  DATA 69,6F
00C6:  DATA 20,64
00C8:  DATA 65,73
00CA:  DATA 66,61
00CC:  DATA 73,65
00CE:  DATA 00,00
00D0:  DATA 50,6F
00D2:  DATA 74,65
00D4:  DATA 6E,63
00D6:  DATA 69,61
00D8:  DATA 3D,20
00DA:  DATA 25,66
00DC:  DATA 20,57
00DE:  DATA 00,00
00E0:  DATA 54,3D
00E2:  DATA 25,66
00E4:  DATA 20,56
00E6:  DATA 20,20
00E8:  DATA 49,3D
00EA:  DATA 25,66
00EC:  DATA 20,41
00EE:  DATA 00,00
*
0766:  MOVFF  7E,85
076A:  MOVF   x82,W
076C:  XORWF  x85,F
076E:  BTFSS  x85.7
0770:  BRA    077C
0772:  BCF    FD8.2
0774:  BCF    FD8.0
0776:  BTFSC  x7E.7
0778:  BSF    FD8.0
077A:  BRA    07DA
077C:  MOVFF  7E,85
0780:  MOVFF  81,86
0784:  MOVF   x7D,W
0786:  SUBWF  x86,F
0788:  BZ    0796
078A:  BTFSS  x85.7
078C:  BRA    07DA
078E:  MOVF   FD8,W
0790:  XORLW  01
0792:  MOVWF  FD8
0794:  BRA    07DA
0796:  MOVFF  82,86
079A:  MOVF   x7E,W
079C:  SUBWF  x86,F
079E:  BZ    07AC
07A0:  BTFSS  x85.7
07A2:  BRA    07DA
07A4:  MOVF   FD8,W
07A6:  XORLW  01
07A8:  MOVWF  FD8
07AA:  BRA    07DA
07AC:  MOVFF  83,86
07B0:  MOVF   x7F,W
07B2:  SUBWF  x86,F
07B4:  BZ    07C2
07B6:  BTFSS  x85.7
07B8:  BRA    07DA
07BA:  MOVF   FD8,W
07BC:  XORLW  01
07BE:  MOVWF  FD8
07C0:  BRA    07DA
07C2:  MOVFF  84,86
07C6:  MOVF   x80,W
07C8:  SUBWF  x86,F
07CA:  BZ    07D8
07CC:  BTFSS  x85.7
07CE:  BRA    07DA
07D0:  MOVF   FD8,W
07D2:  XORLW  01
07D4:  MOVWF  FD8
07D6:  BRA    07DA
07D8:  BCF    FD8.0
07DA:  RETURN 0
*
0AEE:  TBLRD*+
0AF0:  MOVF   FF5,F
0AF2:  BZ    0B0C
0AF4:  MOVFF  FF6,4F
0AF8:  MOVFF  FF7,50
0AFC:  MOVFF  FF5,5D
0B00:  RCALL  0A80
0B02:  MOVFF  4F,FF6
0B06:  MOVFF  50,FF7
0B0A:  BRA    0AEE
0B0C:  GOTO   1502 (RETURN)
0B10:  MOVLW  8E
0B12:  MOVWF  00
0B14:  MOVF   x7D,W
0B16:  SUBWF  00,F
0B18:  MOVFF  7E,02
0B1C:  MOVFF  7F,01
0B20:  BSF    02.7
0B22:  MOVF   00,F
0B24:  BZ    0B38
0B26:  BCF    FD8.0
0B28:  MOVF   02,F
0B2A:  BNZ   0B30
0B2C:  MOVF   01,F
0B2E:  BZ    0B38
0B30:  RRCF   02,F
0B32:  RRCF   01,F
0B34:  DECFSZ 00,F
0B36:  BRA    0B26
0B38:  BTFSS  x7E.7
0B3A:  BRA    0B46
0B3C:  COMF   01,F
0B3E:  COMF   02,F
0B40:  INCF   01,F
0B42:  BTFSC  FD8.2
0B44:  INCF   02,F
0B46:  GOTO   0BF8 (RETURN)
*
0E9C:  TBLRD*+
0E9E:  MOVFF  FF6,50
0EA2:  MOVFF  FF7,51
0EA6:  MOVFF  FF5,5D
0EAA:  RCALL  0A80
0EAC:  MOVFF  50,FF6
0EB0:  MOVFF  51,FF7
0EB4:  DECFSZ 4F,F
0EB6:  BRA    0E9C
0EB8:  RETURN 0
0EBA:  MOVF   5C,W
0EBC:  SUBLW  B6
0EBE:  MOVWF  5C
0EC0:  CLRF   03
0EC2:  MOVFF  5D,60
0EC6:  BSF    5D.7
0EC8:  BCF    FD8.0
0ECA:  RRCF   5D,F
0ECC:  RRCF   5E,F
0ECE:  RRCF   5F,F
0ED0:  RRCF   03,F
0ED2:  RRCF   02,F
0ED4:  RRCF   01,F
0ED6:  RRCF   00,F
0ED8:  DECFSZ 5C,F
0EDA:  BRA    0EC8
0EDC:  BTFSS  x60.7
0EDE:  BRA    0EF6
0EE0:  COMF   00,F
0EE2:  COMF   01,F
0EE4:  COMF   02,F
0EE6:  COMF   03,F
0EE8:  INCF   00,F
0EEA:  BTFSC  FD8.2
0EEC:  INCF   01,F
0EEE:  BTFSC  FD8.2
0EF0:  INCF   02,F
0EF2:  BTFSC  FD8.2
0EF4:  INCF   03,F
0EF6:  GOTO   0FD8 (RETURN)
0EFA:  BTFSC  FD8.1
0EFC:  BRA    0F04
0EFE:  CLRF   FEA
0F00:  MOVLW  64
0F02:  MOVWF  FE9
0F04:  CLRF   00
0F06:  CLRF   01
0F08:  CLRF   02
0F0A:  CLRF   03
0F0C:  CLRF   x64
0F0E:  CLRF   x65
0F10:  CLRF   x66
0F12:  CLRF   x67
0F14:  MOVF   x63,W
0F16:  IORWF  x62,W
0F18:  IORWF  x61,W
0F1A:  IORWF  x60,W
0F1C:  BZ    0F76
0F1E:  MOVLW  20
0F20:  MOVWF  x68
0F22:  BCF    FD8.0
0F24:  RLCF   5C,F
0F26:  RLCF   5D,F
0F28:  RLCF   5E,F
0F2A:  RLCF   5F,F
0F2C:  RLCF   x64,F
0F2E:  RLCF   x65,F
0F30:  RLCF   x66,F
0F32:  RLCF   x67,F
0F34:  MOVF   x63,W
0F36:  SUBWF  x67,W
0F38:  BNZ   0F4A
0F3A:  MOVF   x62,W
0F3C:  SUBWF  x66,W
0F3E:  BNZ   0F4A
0F40:  MOVF   x61,W
0F42:  SUBWF  x65,W
0F44:  BNZ   0F4A
0F46:  MOVF   x60,W
0F48:  SUBWF  x64,W
0F4A:  BNC   0F6A
0F4C:  MOVF   x60,W
0F4E:  SUBWF  x64,F
0F50:  MOVF   x61,W
0F52:  BTFSS  FD8.0
0F54:  INCFSZ x61,W
0F56:  SUBWF  x65,F
0F58:  MOVF   x62,W
0F5A:  BTFSS  FD8.0
0F5C:  INCFSZ x62,W
0F5E:  SUBWF  x66,F
0F60:  MOVF   x63,W
0F62:  BTFSS  FD8.0
0F64:  INCFSZ x63,W
0F66:  SUBWF  x67,F
0F68:  BSF    FD8.0
0F6A:  RLCF   00,F
0F6C:  RLCF   01,F
0F6E:  RLCF   02,F
0F70:  RLCF   03,F
0F72:  DECFSZ x68,F
0F74:  BRA    0F22
0F76:  MOVFF  64,FEF
0F7A:  MOVFF  65,FEC
0F7E:  MOVFF  66,FEC
0F82:  MOVFF  67,FEC
0F86:  RETURN 0
0F88:  MOVF   FE9,W
0F8A:  MOVWF  54
0F8C:  MOVF   53,W
0F8E:  MOVWF  56
0F90:  BZ    0FC6
0F92:  MOVFF  52,84
0F96:  MOVFF  51,83
0F9A:  MOVFF  50,82
0F9E:  MOVFF  4F,81
0FA2:  CLRF   x88
0FA4:  CLRF   x87
0FA6:  MOVLW  20
0FA8:  MOVWF  x86
0FAA:  MOVLW  82
0FAC:  MOVWF  x85
0FAE:  CALL   02B0
0FB2:  MOVFF  03,52
0FB6:  MOVFF  02,51
0FBA:  MOVFF  01,50
0FBE:  MOVFF  00,4F
0FC2:  DECFSZ 56,F
0FC4:  BRA    0F92
0FC6:  MOVFF  52,5F
0FCA:  MOVFF  51,5E
0FCE:  MOVFF  50,5D
0FD2:  MOVFF  4F,5C
0FD6:  BRA    0EBA
0FD8:  MOVFF  03,52
0FDC:  MOVFF  02,51
0FE0:  MOVFF  01,50
0FE4:  MOVFF  00,4F
0FE8:  BTFSS  52.7
0FEA:  BRA    1006
0FEC:  DECF   54,F
0FEE:  BSF    54.5
0FF0:  COMF   4F,F
0FF2:  COMF   50,F
0FF4:  COMF   51,F
0FF6:  COMF   52,F
0FF8:  INCF   4F,F
0FFA:  BTFSC  FD8.2
0FFC:  INCF   50,F
0FFE:  BTFSC  FD8.2
1000:  INCF   51,F
1002:  BTFSC  FD8.2
1004:  INCF   52,F
1006:  MOVLW  3B
1008:  MOVWF  5B
100A:  MOVLW  9A
100C:  MOVWF  5A
100E:  MOVLW  CA
1010:  MOVWF  59
1012:  CLRF   58
1014:  MOVLW  0A
1016:  MOVWF  56
1018:  MOVF   53,W
101A:  BTFSC  FD8.2
101C:  INCF   54,F
101E:  BSF    FD8.1
1020:  CLRF   FEA
1022:  MOVLW  4F
1024:  MOVWF  FE9
1026:  MOVFF  52,5F
102A:  MOVFF  51,5E
102E:  MOVFF  50,5D
1032:  MOVFF  4F,5C
1036:  MOVFF  5B,63
103A:  MOVFF  5A,62
103E:  MOVFF  59,61
1042:  MOVFF  58,60
1046:  RCALL  0EFA
1048:  MOVF   01,W
104A:  MOVF   00,F
104C:  BNZ   106C
104E:  INCF   53,W
1050:  SUBWF  56,W
1052:  BZ    106C
1054:  MOVF   54,W
1056:  BZ    1070
1058:  ANDLW  0F
105A:  SUBWF  56,W
105C:  BZ    1060
105E:  BC    10CE
1060:  BTFSC  54.7
1062:  BRA    10CE
1064:  BTFSC  54.6
1066:  BRA    1070
1068:  MOVLW  20
106A:  BRA    10C6
106C:  MOVLW  20
106E:  ANDWF  54,F
1070:  BTFSS  54.5
1072:  BRA    108C
1074:  BCF    54.5
1076:  MOVF   53,W
1078:  BTFSS  FD8.2
107A:  DECF   54,F
107C:  MOVF   00,W
107E:  MOVWF  54
1080:  MOVLW  2D
1082:  MOVWF  5D
1084:  RCALL  0A80
1086:  MOVF   54,W
1088:  MOVWF  00
108A:  CLRF   54
108C:  MOVF   53,W
108E:  SUBWF  56,W
1090:  BNZ   10A6
1092:  MOVF   00,W
1094:  MOVWF  54
1096:  MOVLW  2E
1098:  MOVWF  5D
109A:  RCALL  0A80
109C:  MOVF   54,W
109E:  MOVWF  00
10A0:  MOVLW  20
10A2:  ANDWF  54,F
10A4:  MOVLW  00
10A6:  MOVLW  30
10A8:  BTFSS  54.5
10AA:  BRA    10C6
10AC:  BCF    54.5
10AE:  MOVF   53,W
10B0:  BTFSS  FD8.2
10B2:  DECF   54,F
10B4:  MOVF   00,W
10B6:  MOVWF  54
10B8:  MOVLW  2D
10BA:  MOVWF  5D
10BC:  RCALL  0A80
10BE:  MOVF   54,W
10C0:  MOVWF  00
10C2:  CLRF   54
10C4:  MOVLW  30
10C6:  ADDWF  00,F
10C8:  MOVFF  00,5D
10CC:  RCALL  0A80
10CE:  BCF    FD8.1
10D0:  MOVFF  5B,5F
10D4:  MOVFF  5A,5E
10D8:  MOVFF  59,5D
10DC:  MOVFF  58,5C
10E0:  CLRF   x63
10E2:  CLRF   x62
10E4:  CLRF   x61
10E6:  MOVLW  0A
10E8:  MOVWF  x60
10EA:  RCALL  0EFA
10EC:  MOVFF  03,5B
10F0:  MOVFF  02,5A
10F4:  MOVFF  01,59
10F8:  MOVFF  00,58
10FC:  DECFSZ 56,F
10FE:  BRA    101E
1100:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
.................... int contador = 0 ;int pulso_timer = 0 ; 
.................... #include "funciones.h"  
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
*
0952:  BSF    F95.6
0954:  MOVLW  11
0956:  MOVWF  00
0958:  DECFSZ 00,F
095A:  BRA    0958
095C:  BSF    F95.7
095E:  MOVLW  11
0960:  MOVWF  00
0962:  DECFSZ 00,F
0964:  BRA    0962
0966:  BCF    F8C.6
0968:  BCF    F95.6
096A:  MOVLW  11
096C:  MOVWF  00
096E:  DECFSZ 00,F
0970:  BRA    096E
0972:  BCF    F8C.7
0974:  BCF    F95.7
....................         delay_us(20); 
0976:  MOVLW  4F
0978:  MOVWF  00
097A:  DECFSZ 00,F
097C:  BRA    097A
097E:  BRA    0980
....................         i2c_write(LCD_ADDR); //the slave addresse 
0980:  MOVLW  4E
0982:  MOVWF  x62
0984:  RCALL  08E6
....................         delay_us(20); 
0986:  MOVLW  4F
0988:  MOVWF  00
098A:  DECFSZ 00,F
098C:  BRA    098A
098E:  BRA    0990
....................         i2c_write(data); 
0990:  MOVFF  61,62
0994:  RCALL  08E6
....................         delay_us(20); 
0996:  MOVLW  4F
0998:  MOVWF  00
099A:  DECFSZ 00,F
099C:  BRA    099A
099E:  BRA    09A0
....................         i2c_stop(); 
09A0:  BCF    F95.6
09A2:  NOP   
09A4:  BSF    F95.7
09A6:  BTFSS  F83.7
09A8:  BRA    09A6
09AA:  MOVLW  11
09AC:  MOVWF  00
09AE:  DECFSZ 00,F
09B0:  BRA    09AE
09B2:  BRA    09B4
09B4:  NOP   
09B6:  BSF    F95.6
09B8:  MOVLW  11
09BA:  MOVWF  00
09BC:  DECFSZ 00,F
09BE:  BRA    09BC
....................         delay_us(20); 
09C0:  MOVLW  4F
09C2:  MOVWF  00
09C4:  DECFSZ 00,F
09C6:  BRA    09C4
09C8:  BRA    09CA
09CA:  RETURN 0
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
09CC:  BTFSS  20.0
09CE:  BRA    09DA
09D0:  MOVF   x60,W
09D2:  IORLW  04
09D4:  IORLW  08
09D6:  MOVWF  x60
09D8:  BRA    09DC
09DA:  BSF    x60.2
....................         i2c_send_nibble(data); 
09DC:  MOVFF  60,61
09E0:  RCALL  0952
....................         data=data-4;       //toggle EN back to 0 
09E2:  MOVLW  04
09E4:  SUBWF  x60,F
....................         i2c_send_nibble(data); 
09E6:  MOVFF  60,61
09EA:  RCALL  0952
09EC:  RETURN 0
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
*
0A6C:  CLRF   x60
0A6E:  RCALL  09CC
....................     lcd_send_byte(0x10); 
0A70:  MOVLW  10
0A72:  MOVWF  x60
0A74:  RCALL  09CC
....................     delay_ms(2); 
0A76:  MOVLW  02
0A78:  MOVWF  5E
0A7A:  RCALL  0A44
0A7C:  GOTO   0AEC (RETURN)
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x30); 
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x20); 
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
....................         lcd_send_byte(0x80); 
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0xC0); 
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x60); 
....................            //clears the display 
....................         lcd_clear(); 
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
*
09EE:  MOVF   5F,W
09F0:  XORLW  01
09F2:  BZ    0A02
09F4:  XORLW  03
09F6:  BZ    0A08
09F8:  XORLW  01
09FA:  BZ    0A0E
09FC:  XORLW  07
09FE:  BZ    0A14
0A00:  BRA    0A1A
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
0A02:  MOVLW  80
0A04:  MOVWF  1F
0A06:  BRA    0A1E
....................       case 2:  address= lcd_line_two;     break; 
0A08:  MOVLW  C0
0A0A:  MOVWF  1F
0A0C:  BRA    0A1E
....................       case 3:  address= lcd_line_three;   break; 
0A0E:  MOVLW  94
0A10:  MOVWF  1F
0A12:  BRA    0A1E
....................       case 4:  address= lcd_line_four;    break; 
0A14:  MOVLW  D4
0A16:  MOVWF  1F
0A18:  BRA    0A1E
....................       default: address= lcd_line_one;     break;  
0A1A:  MOVLW  80
0A1C:  MOVWF  1F
....................    } 
....................   
....................    address+=x-1; 
0A1E:  MOVLW  01
0A20:  SUBWF  5E,W
0A22:  ADDWF  1F,F
....................    data=address&0xF0; 
0A24:  MOVF   1F,W
0A26:  ANDLW  F0
0A28:  MOVWF  24
....................    lcd_send_byte(data); 
0A2A:  MOVFF  24,60
0A2E:  RCALL  09CC
....................    data=address&0x0F; 
0A30:  MOVF   1F,W
0A32:  ANDLW  0F
0A34:  MOVWF  24
....................    data=data<<4; 
0A36:  SWAPF  24,F
0A38:  MOVLW  F0
0A3A:  ANDWF  24,F
....................    lcd_send_byte(data); 
0A3C:  MOVFF  24,60
0A40:  RCALL  09CC
0A42:  RETURN 0
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
*
0A80:  MOVF   5D,W
0A82:  XORLW  0C
0A84:  BZ    0A98
0A86:  XORLW  0D
0A88:  BZ    0A9C
0A8A:  XORLW  03
0A8C:  BZ    0AA6
0A8E:  XORLW  01
0A90:  BZ    0AB2
0A92:  XORLW  07
0A94:  BZ    0ABE
0A96:  BRA    0ACA
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
0A98:  BRA    0A6C
0A9A:  BRA    0AEC
....................      case '\1': lcd_gotoxy(1,1);  break; 
0A9C:  MOVLW  01
0A9E:  MOVWF  5E
0AA0:  MOVWF  5F
0AA2:  RCALL  09EE
0AA4:  BRA    0AEC
....................      case '\2': lcd_gotoxy(1,2);  break; 
0AA6:  MOVLW  01
0AA8:  MOVWF  5E
0AAA:  MOVLW  02
0AAC:  MOVWF  5F
0AAE:  RCALL  09EE
0AB0:  BRA    0AEC
....................      case '\3': lcd_gotoxy(1,3);  break; 
0AB2:  MOVLW  01
0AB4:  MOVWF  5E
0AB6:  MOVLW  03
0AB8:  MOVWF  5F
0ABA:  RCALL  09EE
0ABC:  BRA    0AEC
....................      case '\4': lcd_gotoxy(1,4);  break; 
0ABE:  MOVLW  01
0AC0:  MOVWF  5E
0AC2:  MOVLW  04
0AC4:  MOVWF  5F
0AC6:  RCALL  09EE
0AC8:  BRA    0AEC
....................  
....................      default: 
....................         data=in_data&0xF0; 
0ACA:  MOVF   5D,W
0ACC:  ANDLW  F0
0ACE:  MOVWF  5E
....................         data=data|RS; //set RS pin to 1 
0AD0:  BSF    5E.0
....................         lcd_send_byte(data); 
0AD2:  MOVFF  5E,60
0AD6:  RCALL  09CC
....................         data=in_data&0x0F; 
0AD8:  MOVF   5D,W
0ADA:  ANDLW  0F
0ADC:  MOVWF  5E
....................         data=data<<4; 
0ADE:  SWAPF  5E,F
0AE0:  MOVLW  F0
0AE2:  ANDWF  5E,F
....................         data=data|RS; //set RS pin to 1 
0AE4:  BSF    5E.0
....................         lcd_send_byte(data); 
0AE6:  MOVFF  5E,60
0AEA:  RCALL  09CC
....................      break; 
....................    } 
0AEC:  RETURN 0
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
07DC:  MOVFF  56,80
07E0:  MOVFF  55,7F
07E4:  MOVFF  54,7E
07E8:  MOVFF  53,7D
07EC:  CLRF   x84
07EE:  CLRF   x83
07F0:  CLRF   x82
07F2:  CLRF   x81
07F4:  RCALL  0766
07F6:  BC    07FA
07F8:  BNZ   0804
....................       return(0.0); 
07FA:  CLRF   00
07FC:  CLRF   01
07FE:  CLRF   02
0800:  CLRF   03
0802:  BRA    08E4
....................  
....................    y=x; 
0804:  MOVFF  56,5A
0808:  MOVFF  55,59
080C:  MOVFF  54,58
0810:  MOVFF  53,57
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
0814:  CLRF   x60
0816:  MOVLW  57
0818:  MOVWF  5F
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
081A:  MOVFF  5F,FE9
081E:  MOVFF  60,FEA
0822:  MOVF   FEF,W
0824:  CLRF   x64
0826:  MOVWF  x63
0828:  MOVLW  7F
082A:  ADDWF  x63,F
082C:  MOVLW  00
082E:  ADDWFC x64,F
0830:  BCF    FD8.0
0832:  RRCF   x64,W
0834:  RRCF   x63,W
0836:  MOVFF  60,FEA
083A:  MOVFF  5F,FE9
083E:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0840:  MOVFF  5A,5E
0844:  MOVFF  59,5D
0848:  MOVFF  58,5C
084C:  MOVFF  57,5B
....................       y+=(x/y); 
0850:  MOVFF  56,64
0854:  MOVFF  55,63
0858:  MOVFF  54,62
085C:  MOVFF  53,61
0860:  MOVFF  5A,68
0864:  MOVFF  59,67
0868:  MOVFF  58,66
086C:  MOVFF  57,65
0870:  RCALL  03A2
0872:  BCF    FD8.1
0874:  MOVFF  5A,84
0878:  MOVFF  59,83
087C:  MOVFF  58,82
0880:  MOVFF  57,81
0884:  MOVFF  03,88
0888:  MOVFF  02,87
088C:  MOVFF  01,86
0890:  MOVFF  00,85
0894:  RCALL  04FC
0896:  MOVFF  03,5A
089A:  MOVFF  02,59
089E:  MOVFF  01,58
08A2:  MOVFF  00,57
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
08A6:  MOVFF  5F,FE9
08AA:  MOVFF  60,FEA
08AE:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
08B0:  MOVFF  5E,80
08B4:  MOVFF  5D,7F
08B8:  MOVFF  5C,7E
08BC:  MOVFF  5B,7D
08C0:  MOVFF  5A,84
08C4:  MOVFF  59,83
08C8:  MOVFF  58,82
08CC:  MOVFF  57,81
08D0:  RCALL  0766
08D2:  BNZ   0840
....................  
....................    return(res); 
08D4:  MOVFF  5B,00
08D8:  MOVFF  5C,01
08DC:  MOVFF  5D,02
08E0:  MOVFF  5E,03
08E4:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
0B4A:  CLRF   x62
0B4C:  CLRF   x61
0B4E:  CLRF   x60
0B50:  MOVLW  7F
0B52:  MOVWF  5F
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
0B54:  MOVLW  7E
0B56:  MOVWF  x69
0B58:  MOVLW  80
0B5A:  MOVWF  x6A
0B5C:  CLRF   x6B
0B5E:  CLRF   x6C
0B60:  MOVLW  7A
0B62:  MOVWF  x6D
0B64:  MOVLW  2A
0B66:  MOVWF  x6E
0B68:  MOVLW  AA
0B6A:  MOVWF  x6F
0B6C:  MOVLW  A3
0B6E:  MOVWF  x70
0B70:  MOVLW  75
0B72:  MOVWF  x71
0B74:  MOVLW  B6
0B76:  MOVWF  x72
0B78:  MOVLW  09
0B7A:  MOVWF  x73
0B7C:  MOVLW  B4
0B7E:  MOVWF  x74
0B80:  MOVLW  6F
0B82:  MOVWF  x75
0B84:  MOVLW  4F
0B86:  MOVWF  x76
0B88:  MOVLW  B6
0B8A:  MOVWF  x77
0B8C:  MOVLW  AA
0B8E:  MOVWF  x78
0B90:  MOVLW  69
0B92:  MOVWF  x79
0B94:  MOVLW  8B
0B96:  MOVWF  x7A
0B98:  MOVLW  F6
0B9A:  MOVWF  x7B
0B9C:  MOVLW  E8
0B9E:  MOVWF  x7C
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0BA0:  MOVFF  56,80
0BA4:  MOVFF  55,7F
0BA8:  MOVFF  54,7E
0BAC:  MOVFF  53,7D
0BB0:  CLRF   x84
0BB2:  CLRF   x83
0BB4:  CLRF   x82
0BB6:  CLRF   x81
0BB8:  RCALL  0766
0BBA:  BNC   0BC2
0BBC:  MOVF   54,W
0BBE:  XORLW  80
0BC0:  MOVWF  54
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0BC2:  MOVFF  56,84
0BC6:  MOVFF  55,83
0BCA:  MOVFF  54,82
0BCE:  MOVFF  53,81
0BD2:  MOVLW  83
0BD4:  MOVWF  x88
0BD6:  MOVLW  F9
0BD8:  MOVWF  x87
0BDA:  MOVLW  22
0BDC:  MOVWF  x86
0BDE:  MOVLW  7E
0BE0:  MOVWF  x85
0BE2:  CALL   02B0
0BE6:  MOVFF  03,80
0BEA:  MOVFF  02,7F
0BEE:  MOVFF  01,7E
0BF2:  MOVFF  00,7D
0BF6:  BRA    0B10
0BF8:  MOVFF  01,63
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0BFC:  MOVFF  56,84
0C00:  MOVFF  55,83
0C04:  MOVFF  54,82
0C08:  MOVFF  53,81
0C0C:  MOVLW  83
0C0E:  MOVWF  x88
0C10:  MOVLW  F9
0C12:  MOVWF  x87
0C14:  MOVLW  22
0C16:  MOVWF  x86
0C18:  MOVLW  7E
0C1A:  MOVWF  x85
0C1C:  CALL   02B0
0C20:  MOVFF  03,80
0C24:  MOVFF  02,7F
0C28:  MOVFF  01,7E
0C2C:  MOVFF  00,7D
0C30:  CLRF   x82
0C32:  MOVFF  63,81
0C36:  CALL   027A
0C3A:  BSF    FD8.1
0C3C:  MOVFF  80,84
0C40:  MOVFF  7F,83
0C44:  MOVFF  7E,82
0C48:  MOVFF  7D,81
0C4C:  MOVFF  03,88
0C50:  MOVFF  02,87
0C54:  MOVFF  01,86
0C58:  MOVFF  00,85
0C5C:  RCALL  04FC
0C5E:  MOVFF  03,68
0C62:  MOVFF  02,67
0C66:  MOVFF  01,66
0C6A:  MOVFF  00,65
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0C6E:  MOVLW  03
0C70:  ANDWF  x63,F
....................  
....................    if (quad == 0 || quad == 2) 
0C72:  MOVF   x63,F
0C74:  BZ    0C7C
0C76:  MOVF   x63,W
0C78:  SUBLW  02
0C7A:  BNZ   0CB2
....................       t = frac * PI_DIV_BY_TWO; 
0C7C:  MOVFF  68,84
0C80:  MOVFF  67,83
0C84:  MOVFF  66,82
0C88:  MOVFF  65,81
0C8C:  MOVLW  DB
0C8E:  MOVWF  x88
0C90:  MOVLW  0F
0C92:  MOVWF  x87
0C94:  MOVLW  49
0C96:  MOVWF  x86
0C98:  MOVLW  7F
0C9A:  MOVWF  x85
0C9C:  CALL   02B0
0CA0:  MOVFF  03,5E
0CA4:  MOVFF  02,5D
0CA8:  MOVFF  01,5C
0CAC:  MOVFF  00,5B
0CB0:  BRA    0D7E
....................    else if (quad == 1) 
0CB2:  DECFSZ x63,W
0CB4:  BRA    0D1A
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0CB6:  BSF    FD8.1
0CB8:  CLRF   x84
0CBA:  CLRF   x83
0CBC:  CLRF   x82
0CBE:  MOVLW  7F
0CC0:  MOVWF  x81
0CC2:  MOVFF  68,88
0CC6:  MOVFF  67,87
0CCA:  MOVFF  66,86
0CCE:  MOVFF  65,85
0CD2:  RCALL  04FC
0CD4:  MOVFF  03,80
0CD8:  MOVFF  02,7F
0CDC:  MOVFF  01,7E
0CE0:  MOVFF  00,7D
0CE4:  MOVFF  03,84
0CE8:  MOVFF  02,83
0CEC:  MOVFF  01,82
0CF0:  MOVFF  00,81
0CF4:  MOVLW  DB
0CF6:  MOVWF  x88
0CF8:  MOVLW  0F
0CFA:  MOVWF  x87
0CFC:  MOVLW  49
0CFE:  MOVWF  x86
0D00:  MOVLW  7F
0D02:  MOVWF  x85
0D04:  CALL   02B0
0D08:  MOVFF  03,5E
0D0C:  MOVFF  02,5D
0D10:  MOVFF  01,5C
0D14:  MOVFF  00,5B
0D18:  BRA    0D7E
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0D1A:  BSF    FD8.1
0D1C:  MOVFF  68,84
0D20:  MOVFF  67,83
0D24:  MOVFF  66,82
0D28:  MOVFF  65,81
0D2C:  CLRF   x88
0D2E:  CLRF   x87
0D30:  CLRF   x86
0D32:  MOVLW  7F
0D34:  MOVWF  x85
0D36:  CALL   04FC
0D3A:  MOVFF  03,80
0D3E:  MOVFF  02,7F
0D42:  MOVFF  01,7E
0D46:  MOVFF  00,7D
0D4A:  MOVFF  03,84
0D4E:  MOVFF  02,83
0D52:  MOVFF  01,82
0D56:  MOVFF  00,81
0D5A:  MOVLW  DB
0D5C:  MOVWF  x88
0D5E:  MOVLW  0F
0D60:  MOVWF  x87
0D62:  MOVLW  49
0D64:  MOVWF  x86
0D66:  MOVLW  7F
0D68:  MOVWF  x85
0D6A:  CALL   02B0
0D6E:  MOVFF  03,5E
0D72:  MOVFF  02,5D
0D76:  MOVFF  01,5C
0D7A:  MOVFF  00,5B
....................  
....................    y = 1.0; 
0D7E:  CLRF   5A
0D80:  CLRF   59
0D82:  CLRF   58
0D84:  MOVLW  7F
0D86:  MOVWF  57
....................    t = t * t; 
0D88:  MOVFF  5E,84
0D8C:  MOVFF  5D,83
0D90:  MOVFF  5C,82
0D94:  MOVFF  5B,81
0D98:  MOVFF  5E,88
0D9C:  MOVFF  5D,87
0DA0:  MOVFF  5C,86
0DA4:  MOVFF  5B,85
0DA8:  CALL   02B0
0DAC:  MOVFF  03,5E
0DB0:  MOVFF  02,5D
0DB4:  MOVFF  01,5C
0DB8:  MOVFF  00,5B
....................    for (i = 0; i <= 4; i++) 
0DBC:  CLRF   x64
0DBE:  MOVF   x64,W
0DC0:  SUBLW  04
0DC2:  BNC   0E78
....................    { 
....................       t2 = t2 * t; 
0DC4:  MOVFF  62,84
0DC8:  MOVFF  61,83
0DCC:  MOVFF  60,82
0DD0:  MOVFF  5F,81
0DD4:  MOVFF  5E,88
0DD8:  MOVFF  5D,87
0DDC:  MOVFF  5C,86
0DE0:  MOVFF  5B,85
0DE4:  CALL   02B0
0DE8:  MOVFF  03,62
0DEC:  MOVFF  02,61
0DF0:  MOVFF  01,60
0DF4:  MOVFF  00,5F
....................       y = y + p[i] * t2; 
0DF8:  MOVF   x64,W
0DFA:  MULLW  04
0DFC:  MOVF   FF3,W
0DFE:  CLRF   03
0E00:  ADDLW  69
0E02:  MOVWF  FE9
0E04:  MOVLW  00
0E06:  ADDWFC 03,W
0E08:  MOVWF  FEA
0E0A:  MOVFF  FEF,81
0E0E:  MOVFF  FEC,82
0E12:  MOVFF  FEC,83
0E16:  MOVFF  FEC,84
0E1A:  MOVFF  62,88
0E1E:  MOVFF  61,87
0E22:  MOVFF  60,86
0E26:  MOVFF  5F,85
0E2A:  CALL   02B0
0E2E:  MOVFF  FEA,7E
0E32:  MOVFF  FE9,7D
0E36:  BCF    FD8.1
0E38:  MOVFF  5A,84
0E3C:  MOVFF  59,83
0E40:  MOVFF  58,82
0E44:  MOVFF  57,81
0E48:  MOVFF  03,88
0E4C:  MOVFF  02,87
0E50:  MOVFF  01,86
0E54:  MOVFF  00,85
0E58:  CALL   04FC
0E5C:  MOVFF  7E,FEA
0E60:  MOVFF  7D,FE9
0E64:  MOVFF  03,5A
0E68:  MOVFF  02,59
0E6C:  MOVFF  01,58
0E70:  MOVFF  00,57
0E74:  INCF   x64,F
0E76:  BRA    0DBE
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
0E78:  MOVF   x63,W
0E7A:  SUBLW  02
0E7C:  BZ    0E82
0E7E:  DECFSZ x63,W
0E80:  BRA    0E88
....................       y = -y;  // correct sign 
0E82:  MOVF   58,W
0E84:  XORLW  80
0E86:  MOVWF  58
....................  
....................    return (y); 
0E88:  MOVFF  57,00
0E8C:  MOVFF  58,01
0E90:  MOVFF  59,02
0E94:  MOVFF  5A,03
0E98:  GOTO   155A (RETURN)
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <Control_ADCs.h> 
.................... /*  
....................  * File:   MAX191.h 
....................  * Author: MARCOS 
....................  * 
....................  * Created on 23 de septiembre de 2016, 08:14 
....................  */ 
....................  
.................... #ifndef Control_ADCs_H 
.................... #define Control_ADCs_H 
....................  
.................... #define ADC_CSCorriente PIN_A0 
.................... #define ADC_CSTension PIN_A1 
.................... #define ADC_SCLK PIN_A2 
.................... #define ADC_DOUT PIN_A3  // por aqui ingresa la info de los ADC, SDATA en AD7450 
.................... #define ADC_DIN PIN_A4 // se envia la informacion al MAX186 
.................... #define ADC_SSTRB PIN_A5 
....................  
.................... //control AD7450 
.................... long leer_Tension(){ 
*
0108:  CLRF   50
010A:  CLRF   4F
....................     signed long dato=0x00,dato_t; 
....................     int i; 
....................     output_low (ADC_CSTension); 
010C:  BCF    F92.1
010E:  BCF    F89.1
....................     delay_us(1); 
0110:  MOVLW  03
0112:  MOVWF  00
0114:  DECFSZ 00,F
0116:  BRA    0114
0118:  BRA    011A
....................     output_low (ADC_SCLK); 
011A:  BCF    F92.2
011C:  BCF    F89.2
....................     delay_us(1); 
011E:  MOVLW  03
0120:  MOVWF  00
0122:  DECFSZ 00,F
0124:  BRA    0122
0126:  BRA    0128
....................     output_high (ADC_SCLK); 
0128:  BCF    F92.2
012A:  BSF    F89.2
....................     delay_us(1); 
012C:  MOVLW  03
012E:  MOVWF  00
0130:  DECFSZ 00,F
0132:  BRA    0130
0134:  BRA    0136
....................      
....................         for(i=0;i<15;i++){ 
0136:  CLRF   53
0138:  MOVF   53,W
013A:  SUBLW  0E
013C:  BNC   016E
....................           shift_left(&dato,2,input(ADC_DOUT)); 
013E:  BSF    F92.3
0140:  BTFSC  F80.3
0142:  BRA    0148
0144:  BCF    FD8.0
0146:  BRA    014A
0148:  BSF    FD8.0
014A:  RLCF   4F,F
014C:  RLCF   50,F
....................           output_low(ADC_SCLK); 
014E:  BCF    F92.2
0150:  BCF    F89.2
....................           delay_us(1);  
0152:  MOVLW  03
0154:  MOVWF  00
0156:  DECFSZ 00,F
0158:  BRA    0156
015A:  BRA    015C
....................           output_high(ADC_SCLK);  
015C:  BCF    F92.2
015E:  BSF    F89.2
....................           delay_us(1); 
0160:  MOVLW  03
0162:  MOVWF  00
0164:  DECFSZ 00,F
0166:  BRA    0164
0168:  BRA    016A
016A:  INCF   53,F
016C:  BRA    0138
....................         } 
....................  
....................        // output_high (ADC_SCLK); 
....................        // delay_us(1); 
....................         output_high (ADC_CSTension); 
016E:  BCF    F92.1
0170:  BSF    F89.1
....................          
....................        dato_t=(dato&0x0800); 
0172:  CLRF   51
0174:  MOVF   50,W
0176:  ANDLW  08
0178:  MOVWF  52
....................          
....................       if (dato_t==0x0800){ 
017A:  MOVF   51,F
017C:  BNZ   0198
017E:  MOVF   52,W
0180:  SUBLW  08
0182:  BNZ   0198
....................             dato=-2048+(dato&0xF7FF); 
0184:  MOVFF  4F,00
0188:  MOVF   50,W
018A:  ANDLW  F7
018C:  MOVWF  03
018E:  MOVFF  4F,4F
0192:  MOVLW  F8
0194:  ADDWF  03,W
0196:  MOVWF  50
....................         } 
....................         
....................     return(dato); 
0198:  MOVFF  4F,01
019C:  MOVFF  50,02
01A0:  GOTO   1124 (RETURN)
.................... } 
....................  
.................... //control MAX186 
.................... long leer_Corriente(){ 
01A4:  MOVLW  8E
01A6:  MOVWF  51
....................     long dato; 
....................     BYTE config= 0b10001110; 
....................     int i; 
....................     output_low (ADC_CSCorriente); 
01A8:  BCF    F92.0
01AA:  BCF    F89.0
....................     output_low (ADC_DIN); 
01AC:  BCF    F92.4
01AE:  BCF    F89.4
....................     delay_us(1); 
01B0:  MOVLW  03
01B2:  MOVWF  00
01B4:  DECFSZ 00,F
01B6:  BRA    01B4
01B8:  BRA    01BA
....................      
....................     for(i=0; i<8; i++) { 
01BA:  CLRF   52
01BC:  MOVF   52,W
01BE:  SUBLW  07
01C0:  BNC   01F0
....................       output_bit(ADC_DIN, shift_left(&config,1,0)); 
01C2:  BCF    FD8.0
01C4:  RLCF   51,F
01C6:  BC    01CC
01C8:  BCF    F89.4
01CA:  BRA    01CE
01CC:  BSF    F89.4
01CE:  BCF    F92.4
....................       output_high(ADC_SCLK); 
01D0:  BCF    F92.2
01D2:  BSF    F89.2
....................       delay_us(1); 
01D4:  MOVLW  03
01D6:  MOVWF  00
01D8:  DECFSZ 00,F
01DA:  BRA    01D8
01DC:  BRA    01DE
....................       output_low(ADC_SCLK);	 
01DE:  BCF    F92.2
01E0:  BCF    F89.2
....................       delay_us(1); 
01E2:  MOVLW  03
01E4:  MOVWF  00
01E6:  DECFSZ 00,F
01E8:  BRA    01E6
01EA:  BRA    01EC
01EC:  INCF   52,F
01EE:  BRA    01BC
....................    } 
....................  
....................     output_high(ADC_CSCorriente); 
01F0:  BCF    F92.0
01F2:  BSF    F89.0
....................      
....................     while(input(ADC_SSTRB)=='0');    
....................          
....................         output_low (ADC_CSCorriente); 
01F4:  BCF    F92.0
01F6:  BCF    F89.0
....................         output_high (ADC_SCLK); 
01F8:  BCF    F92.2
01FA:  BSF    F89.2
....................         delay_us(1); 
01FC:  MOVLW  03
01FE:  MOVWF  00
0200:  DECFSZ 00,F
0202:  BRA    0200
0204:  BRA    0206
....................         output_low (ADC_SCLK); 
0206:  BCF    F92.2
0208:  BCF    F89.2
....................         delay_us(1); 
020A:  MOVLW  03
020C:  MOVWF  00
020E:  DECFSZ 00,F
0210:  BRA    020E
0212:  BRA    0214
....................          
....................         for(i=0;i<15;i++){ 
0214:  CLRF   52
0216:  MOVF   52,W
0218:  SUBLW  0E
021A:  BNC   024C
....................           output_high(ADC_SCLK); 
021C:  BCF    F92.2
021E:  BSF    F89.2
....................           delay_us(1); 
0220:  MOVLW  03
0222:  MOVWF  00
0224:  DECFSZ 00,F
0226:  BRA    0224
0228:  BRA    022A
....................           shift_left(&dato,2,input(ADC_DOUT));  
022A:  BSF    F92.3
022C:  BTFSC  F80.3
022E:  BRA    0234
0230:  BCF    FD8.0
0232:  BRA    0236
0234:  BSF    FD8.0
0236:  RLCF   4F,F
0238:  RLCF   50,F
....................           output_low(ADC_SCLK); 
023A:  BCF    F92.2
023C:  BCF    F89.2
....................           delay_us(1); 
023E:  MOVLW  03
0240:  MOVWF  00
0242:  DECFSZ 00,F
0244:  BRA    0242
0246:  BRA    0248
0248:  INCF   52,F
024A:  BRA    0216
....................         } 
....................   
....................          
....................         output_high (ADC_CSCorriente); 
024C:  BCF    F92.0
024E:  BSF    F89.0
....................      
....................  
....................     dato= (dato>>3)& 0x0FFF; 
0250:  RRCF   50,W
0252:  MOVWF  54
0254:  RRCF   4F,W
0256:  MOVWF  53
0258:  RRCF   54,F
025A:  RRCF   53,F
025C:  RRCF   54,F
025E:  RRCF   53,F
0260:  MOVLW  1F
0262:  ANDWF  54,F
0264:  MOVFF  53,4F
0268:  MOVF   54,W
026A:  ANDLW  0F
026C:  MOVWF  50
....................     return(dato); 
026E:  MOVFF  4F,01
0272:  MOVFF  50,02
0276:  GOTO   1130 (RETURN)
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //Implementacion Switch-Case 
....................  
.................... /** 
.................... *	\fn void maquina_estado() 
.................... *	\brief Implementacion Switch-Case 
.................... *	\details  
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
....................  **/ 
.................... unsigned long punto1, punto2; 
.................... int8 pos_V,pos_I,pos_V_A,pos_I_A; 
.................... int control_V, control_I; 
.................... int desfase; 
.................... float tension, corriente, tension_RMS,corriente_RMS, t_desfase, potencia_ins,angulo; 
....................  
.................... const long carga= 0xE8AB; 
....................  
.................... #INT_RTCC                // interrupcion para demora de 1 ms 
.................... void interrtimer_0(){ 
....................     set_timer0(carga);   // interrupcion cada 1 ms 
*
00AE:  MOVLW  E8
00B0:  MOVWF  FD7
00B2:  MOVLW  AB
00B4:  MOVWF  FD6
....................     pulso_timer++; 
00B6:  INCF   23,F
....................  
00B8:  BCF    FF2.2
00BA:  GOTO   0060
....................    } 
....................  
.................... void maquina_estado() 
.................... { 
.................... 		static int estado = PUNTO_TENS_CORR; 
....................  
.................... 		switch(estado) 
*
1102:  MOVF   4C,W
1104:  XORLW  00
1106:  BZ    1120
1108:  XORLW  01
110A:  BZ    1178
110C:  XORLW  03
110E:  BTFSC  FD8.2
1110:  BRA    12E8
1112:  XORLW  01
1114:  BTFSC  FD8.2
1116:  BRA    13BE
1118:  XORLW  07
111A:  BTFSC  FD8.2
111C:  BRA    15A2
111E:  BRA    1670
.................... 		{ 
.................... 			case PUNTO_TENS_CORR: 
....................                 punto1= leer_Tension(); 
1120:  GOTO   0108
1124:  MOVFF  02,26
1128:  MOVFF  01,25
....................                 punto2= leer_Corriente(); // comprobar si funciona con el tiempo de demora de la lectura del externo 
112C:  GOTO   01A4
1130:  MOVFF  02,28
1134:  MOVFF  01,27
....................                 // convierte los valores de long a float 
....................                 tension=punto1; 
1138:  MOVFF  26,82
113C:  MOVFF  25,81
1140:  CALL   027A
1144:  MOVFF  03,33
1148:  MOVFF  02,32
114C:  MOVFF  01,31
1150:  MOVFF  00,30
....................                 corriente=punto2; 
1154:  MOVFF  28,82
1158:  MOVFF  27,81
115C:  CALL   027A
1160:  MOVFF  03,37
1164:  MOVFF  02,36
1168:  MOVFF  01,35
116C:  MOVFF  00,34
....................                 contador++; 
1170:  INCF   22,F
.................... 					estado = CONVERSION_DESFASE; 
1172:  MOVLW  01
1174:  MOVWF  4C
....................  
.................... 				break; 
1176:  BRA    1672
.................... 			 
.................... 			case CONVERSION_DESFASE: 
....................                 tension= (tension)*2.5/2048; 
1178:  MOVFF  33,84
117C:  MOVFF  32,83
1180:  MOVFF  31,82
1184:  MOVFF  30,81
1188:  CLRF   x88
118A:  CLRF   x87
118C:  MOVLW  20
118E:  MOVWF  x86
1190:  MOVLW  80
1192:  MOVWF  x85
1194:  CALL   02B0
1198:  MOVFF  03,52
119C:  MOVFF  02,51
11A0:  MOVFF  01,50
11A4:  MOVFF  00,4F
11A8:  MOVFF  03,64
11AC:  MOVFF  02,63
11B0:  MOVFF  01,62
11B4:  MOVFF  00,61
11B8:  CLRF   x68
11BA:  CLRF   x67
11BC:  CLRF   x66
11BE:  MOVLW  8A
11C0:  MOVWF  x65
11C2:  CALL   03A2
11C6:  MOVFF  03,33
11CA:  MOVFF  02,32
11CE:  MOVFF  01,31
11D2:  MOVFF  00,30
....................                 corriente= (corriente)/1000.0-2.55; 
11D6:  MOVFF  37,64
11DA:  MOVFF  36,63
11DE:  MOVFF  35,62
11E2:  MOVFF  34,61
11E6:  CLRF   x68
11E8:  CLRF   x67
11EA:  MOVLW  7A
11EC:  MOVWF  x66
11EE:  MOVLW  88
11F0:  MOVWF  x65
11F2:  CALL   03A2
11F6:  MOVFF  03,52
11FA:  MOVFF  02,51
11FE:  MOVFF  01,50
1202:  MOVFF  00,4F
1206:  BSF    FD8.1
1208:  MOVFF  03,84
120C:  MOVFF  02,83
1210:  MOVFF  01,82
1214:  MOVFF  00,81
1218:  MOVLW  33
121A:  MOVWF  x88
121C:  MOVWF  x87
121E:  MOVLW  23
1220:  MOVWF  x86
1222:  MOVLW  80
1224:  MOVWF  x85
1226:  CALL   04FC
122A:  MOVFF  03,37
122E:  MOVFF  02,36
1232:  MOVFF  01,35
1236:  MOVFF  00,34
....................                 //se convierte a la tension y corriente real 
....................                 tension= tension*77.78; // conversion con 4 V igual a 311.13 V 
123A:  MOVFF  33,84
123E:  MOVFF  32,83
1242:  MOVFF  31,82
1246:  MOVFF  30,81
124A:  MOVLW  5C
124C:  MOVWF  x88
124E:  MOVLW  8F
1250:  MOVWF  x87
1252:  MOVLW  1B
1254:  MOVWF  x86
1256:  MOVLW  85
1258:  MOVWF  x85
125A:  CALL   02B0
125E:  MOVFF  03,33
1262:  MOVFF  02,32
1266:  MOVFF  01,31
126A:  MOVFF  00,30
....................                 corriente= corriente*12; // 2.5 V es igual a +30 A (recordar que el sensor mide ±30A) 
126E:  MOVFF  37,84
1272:  MOVFF  36,83
1276:  MOVFF  35,82
127A:  MOVFF  34,81
127E:  CLRF   x88
1280:  CLRF   x87
1282:  MOVLW  40
1284:  MOVWF  x86
1286:  MOVLW  82
1288:  MOVWF  x85
128A:  CALL   02B0
128E:  MOVFF  03,37
1292:  MOVFF  02,36
1296:  MOVFF  01,35
129A:  MOVFF  00,34
....................                  
....................                 // Analisis del punto POSITVO O NEGATIVO 
....................                 // valor positivo estado=0-- valor negativo estado=1 
....................                  
....................                 //TENSION 
....................                 #asm 
....................                 clrf &pos_V; 
129E:  CLRF   29
....................                 btfsc (&tension + 0x01), 7; 
12A0:  BTFSC  31.7
....................                 bsf &pos_V,0; 
12A2:  BSF    29.0
....................                 #endasm 
.................... 				 
....................                 //CORRIENTE 
....................                 #asm 
....................                 clrf &pos_I; 
12A4:  CLRF   2A
....................                 btfsc (&corriente + 0x01), 7; // comprueba signo en un bit de los 4 byte del float 
12A6:  BTFSC  35.7
....................                 bsf &pos_I,0; 
12A8:  BSF    2A.0
....................                 #endasm 
....................  
....................                  
....................                  
.................... 				 
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_V==1 && contador!=0 && pos_V_A==0 && control_V != 0){  
12AA:  DECFSZ 29,W
12AC:  BRA    12C2
12AE:  MOVF   22,F
12B0:  BZ    12C2
12B2:  MOVF   2B,F
12B4:  BNZ   12C2
12B6:  MOVF   2D,F
12B8:  BZ    12C2
....................                  control_V= contador; // tiempo en el que cruzó la tension  
12BA:  MOVFF  22,2D
....................                  desfase=1; 
12BE:  MOVLW  01
12C0:  MOVWF  2F
....................                 } 
....................                  
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_I==1 && contador!=0 && pos_I_A==0 && control_I != 0){ 
12C2:  DECFSZ 2A,W
12C4:  BRA    12DA
12C6:  MOVF   22,F
12C8:  BZ    12DA
12CA:  MOVF   2C,F
12CC:  BNZ   12DA
12CE:  MOVF   2E,F
12D0:  BZ    12DA
....................                      
....................                  control_I= contador; // tiempo en el que cruzó la corriente 
12D2:  MOVFF  22,2E
....................                  desfase=2; 
12D6:  MOVLW  02
12D8:  MOVWF  2F
....................                 } 
....................                  
....................                 pos_V_A=pos_V; 
12DA:  MOVFF  29,2B
....................                 pos_I_A=pos_I; 
12DE:  MOVFF  2A,2C
....................                  
....................                  
.................... 					estado = TENS_CORR_RMS; 
12E2:  MOVLW  02
12E4:  MOVWF  4C
.................... 		 
.................... 				 
....................  
.................... 				break; 
12E6:  BRA    1672
.................... 			 
.................... 			case TENS_CORR_RMS: 
.................... 			 
.................... 				if((contador<30)&& (pulso_timer==1)) 
12E8:  MOVF   22,W
12EA:  SUBLW  1D
12EC:  BNC   13BC
12EE:  DECFSZ 23,W
12F0:  BRA    13BC
.................... 				{ 
.................... 					tension_RMS=tension_RMS+ tension * tension;       //calcula tension eficaz 
12F2:  MOVFF  33,84
12F6:  MOVFF  32,83
12FA:  MOVFF  31,82
12FE:  MOVFF  30,81
1302:  MOVFF  33,88
1306:  MOVFF  32,87
130A:  MOVFF  31,86
130E:  MOVFF  30,85
1312:  CALL   02B0
1316:  BCF    FD8.1
1318:  MOVFF  3B,84
131C:  MOVFF  3A,83
1320:  MOVFF  39,82
1324:  MOVFF  38,81
1328:  MOVFF  03,88
132C:  MOVFF  02,87
1330:  MOVFF  01,86
1334:  MOVFF  00,85
1338:  CALL   04FC
133C:  MOVFF  03,3B
1340:  MOVFF  02,3A
1344:  MOVFF  01,39
1348:  MOVFF  00,38
....................                     corriente_RMS= corriente_RMS+ corriente * corriente; // calcula corriente eficaz 
134C:  MOVFF  37,84
1350:  MOVFF  36,83
1354:  MOVFF  35,82
1358:  MOVFF  34,81
135C:  MOVFF  37,88
1360:  MOVFF  36,87
1364:  MOVFF  35,86
1368:  MOVFF  34,85
136C:  CALL   02B0
1370:  BCF    FD8.1
1372:  MOVFF  3F,84
1376:  MOVFF  3E,83
137A:  MOVFF  3D,82
137E:  MOVFF  3C,81
1382:  MOVFF  03,88
1386:  MOVFF  02,87
138A:  MOVFF  01,86
138E:  MOVFF  00,85
1392:  CALL   04FC
1396:  MOVFF  03,3F
139A:  MOVFF  02,3E
139E:  MOVFF  01,3D
13A2:  MOVFF  00,3C
....................                     pulso_timer=0; 
13A6:  CLRF   23
....................                      
.................... 					estado = PUNTO_TENS_CORR; 
13A8:  CLRF   4C
....................                      
....................                     if((contador== 29)){ 
13AA:  MOVF   22,W
13AC:  SUBLW  1D
13AE:  BNZ   13BC
.................... 					disable_interrupts(GLOBAL); 
13B0:  BCF    FF2.6
13B2:  BCF    FF2.7
13B4:  BTFSC  FF2.7
13B6:  BRA    13B2
.................... 					estado = CALCULO_POT_ENER; 
13B8:  MOVLW  03
13BA:  MOVWF  4C
....................                       // lcd_gotoxy(1,1);   
....................                       // printf(LCD_PUTC,"entro timer \%d",contador); 
.................... 				} 
.................... 				} 
.................... 				 
....................  
.................... 				break; 
13BC:  BRA    1672
.................... 			 
.................... 			case CALCULO_POT_ENER: // falta calculo de energia 
....................                 //calcula las raices para completar el calculo RMS 
.................... 				tension_RMS= sqrt(tension_RMS/30); 
13BE:  MOVFF  3B,64
13C2:  MOVFF  3A,63
13C6:  MOVFF  39,62
13CA:  MOVFF  38,61
13CE:  CLRF   x68
13D0:  CLRF   x67
13D2:  MOVLW  70
13D4:  MOVWF  x66
13D6:  MOVLW  83
13D8:  MOVWF  x65
13DA:  CALL   03A2
13DE:  MOVFF  03,52
13E2:  MOVFF  02,51
13E6:  MOVFF  01,50
13EA:  MOVFF  00,4F
13EE:  MOVFF  03,56
13F2:  MOVFF  02,55
13F6:  MOVFF  01,54
13FA:  MOVFF  00,53
13FE:  CALL   07DC
1402:  MOVFF  03,3B
1406:  MOVFF  02,3A
140A:  MOVFF  01,39
140E:  MOVFF  00,38
....................                 corriente_RMS= sqrt(corriente_RMS/30); 
1412:  MOVFF  3F,64
1416:  MOVFF  3E,63
141A:  MOVFF  3D,62
141E:  MOVFF  3C,61
1422:  CLRF   x68
1424:  CLRF   x67
1426:  MOVLW  70
1428:  MOVWF  x66
142A:  MOVLW  83
142C:  MOVWF  x65
142E:  CALL   03A2
1432:  MOVFF  03,52
1436:  MOVFF  02,51
143A:  MOVFF  01,50
143E:  MOVFF  00,4F
1442:  MOVFF  03,56
1446:  MOVFF  02,55
144A:  MOVFF  01,54
144E:  MOVFF  00,53
1452:  CALL   07DC
1456:  MOVFF  03,3F
145A:  MOVFF  02,3E
145E:  MOVFF  01,3D
1462:  MOVFF  00,3C
....................                  
....................                 // se controla si se pudo calcular desfase en el estado anterior  
....................                 // se realiza las diferencia de cruce por cero y se convierte de tiempo a radianes 
....................                 if (desfase==2){ 
1466:  MOVF   2F,W
1468:  SUBLW  02
146A:  BNZ   1512
....................                     t_desfase= (control_I-control_V); 
146C:  MOVF   2D,W
146E:  SUBWF  2E,W
1470:  CLRF   x82
1472:  MOVWF  x81
1474:  CALL   027A
1478:  MOVFF  03,43
147C:  MOVFF  02,42
1480:  MOVFF  01,41
1484:  MOVFF  00,40
....................                     angulo= (t_desfase*pi)/20;      // angulo de desfase en radianes. 
1488:  MOVFF  43,84
148C:  MOVFF  42,83
1490:  MOVFF  41,82
1494:  MOVFF  40,81
1498:  MOVLW  DB
149A:  MOVWF  x88
149C:  MOVLW  0F
149E:  MOVWF  x87
14A0:  MOVLW  49
14A2:  MOVWF  x86
14A4:  MOVLW  80
14A6:  MOVWF  x85
14A8:  CALL   02B0
14AC:  MOVFF  03,52
14B0:  MOVFF  02,51
14B4:  MOVFF  01,50
14B8:  MOVFF  00,4F
14BC:  MOVFF  03,64
14C0:  MOVFF  02,63
14C4:  MOVFF  01,62
14C8:  MOVFF  00,61
14CC:  CLRF   x68
14CE:  CLRF   x67
14D0:  MOVLW  20
14D2:  MOVWF  x66
14D4:  MOVLW  83
14D6:  MOVWF  x65
14D8:  CALL   03A2
14DC:  MOVFF  03,4B
14E0:  MOVFF  02,4A
14E4:  MOVFF  01,49
14E8:  MOVFF  00,48
....................                      lcd_gotoxy(1,1); 
14EC:  MOVLW  01
14EE:  MOVWF  5E
14F0:  MOVWF  5F
14F2:  CALL   09EE
....................                      printf(LCD_PUTC,"Se midio desfase"); 
14F6:  MOVLW  BE
14F8:  MOVWF  FF6
14FA:  MOVLW  00
14FC:  MOVWF  FF7
14FE:  GOTO   0AEE
....................                      delay_ms(1000); 
1502:  MOVLW  04
1504:  MOVWF  4F
1506:  MOVLW  FA
1508:  MOVWF  5E
150A:  CALL   0A44
150E:  DECFSZ 4F,F
1510:  BRA    1506
....................                 }                 
....................                // calculo de potencia  
....................                 potencia_ins= tension_RMS*corriente_RMS* cos(angulo); 
1512:  MOVFF  3B,84
1516:  MOVFF  3A,83
151A:  MOVFF  39,82
151E:  MOVFF  38,81
1522:  MOVFF  3F,88
1526:  MOVFF  3E,87
152A:  MOVFF  3D,86
152E:  MOVFF  3C,85
1532:  CALL   02B0
1536:  MOVFF  03,52
153A:  MOVFF  02,51
153E:  MOVFF  01,50
1542:  MOVFF  00,4F
1546:  MOVFF  4B,56
154A:  MOVFF  4A,55
154E:  MOVFF  49,54
1552:  MOVFF  48,53
1556:  GOTO   0B4A
155A:  MOVFF  52,84
155E:  MOVFF  51,83
1562:  MOVFF  50,82
1566:  MOVFF  4F,81
156A:  MOVFF  03,88
156E:  MOVFF  02,87
1572:  MOVFF  01,86
1576:  MOVFF  00,85
157A:  CALL   02B0
157E:  MOVFF  03,47
1582:  MOVFF  02,46
1586:  MOVFF  01,45
158A:  MOVFF  00,44
....................                 //se limpian las variables para la próxima tanta de muestreo 
....................                 control_V=0;       
158E:  CLRF   2D
....................                 control_I=0; 
1590:  CLRF   2E
....................                 angulo=0; 
1592:  CLRF   4B
1594:  CLRF   4A
1596:  CLRF   49
1598:  CLRF   48
....................                 desfase=0;  
159A:  CLRF   2F
....................                  
.................... 					estado = MOSTRAR_DATOS; 
159C:  MOVLW  04
159E:  MOVWF  4C
.................... 				break; 
15A0:  BRA    1672
.................... 			 
.................... 			case MOSTRAR_DATOS: 
....................                 //este estado solo muestra los datos en la pantalla LCD 
....................                 lcd_gotoxy(1,1); 
15A2:  MOVLW  01
15A4:  MOVWF  5E
15A6:  MOVWF  5F
15A8:  CALL   09EE
....................                 printf(LCD_PUTC,"Potencia= \%f W",potencia_ins); 
15AC:  MOVLW  D0
15AE:  MOVWF  FF6
15B0:  MOVLW  00
15B2:  MOVWF  FF7
15B4:  MOVLW  0A
15B6:  MOVWF  4F
15B8:  RCALL  0E9C
15BA:  MOVLW  89
15BC:  MOVWF  FE9
15BE:  MOVFF  47,52
15C2:  MOVFF  46,51
15C6:  MOVFF  45,50
15CA:  MOVFF  44,4F
15CE:  MOVLW  02
15D0:  MOVWF  53
15D2:  RCALL  0F88
15D4:  MOVLW  20
15D6:  MOVWF  5D
15D8:  CALL   0A80
15DC:  MOVLW  57
15DE:  MOVWF  5D
15E0:  CALL   0A80
....................                 lcd_gotoxy(1,2); 
15E4:  MOVLW  01
15E6:  MOVWF  5E
15E8:  MOVLW  02
15EA:  MOVWF  5F
15EC:  CALL   09EE
....................                 printf (LCD_PUTC, "T=\%f V  I=\%f A",tension_RMS,corriente_RMS); 
15F0:  MOVLW  54
15F2:  MOVWF  5D
15F4:  CALL   0A80
15F8:  MOVLW  3D
15FA:  MOVWF  5D
15FC:  CALL   0A80
1600:  MOVLW  89
1602:  MOVWF  FE9
1604:  MOVFF  3B,52
1608:  MOVFF  3A,51
160C:  MOVFF  39,50
1610:  MOVFF  38,4F
1614:  MOVLW  02
1616:  MOVWF  53
1618:  RCALL  0F88
161A:  MOVLW  E4
161C:  MOVWF  FF6
161E:  MOVLW  00
1620:  MOVWF  FF7
1622:  MOVLW  06
1624:  MOVWF  4F
1626:  RCALL  0E9C
1628:  MOVLW  89
162A:  MOVWF  FE9
162C:  MOVFF  3F,52
1630:  MOVFF  3E,51
1634:  MOVFF  3D,50
1638:  MOVFF  3C,4F
163C:  MOVLW  02
163E:  MOVWF  53
1640:  RCALL  0F88
1642:  MOVLW  20
1644:  MOVWF  5D
1646:  CALL   0A80
164A:  MOVLW  41
164C:  MOVWF  5D
164E:  CALL   0A80
....................                 delay_ms(1000); 
1652:  MOVLW  04
1654:  MOVWF  4F
1656:  MOVLW  FA
1658:  MOVWF  5E
165A:  CALL   0A44
165E:  DECFSZ 4F,F
1660:  BRA    1656
....................                 enable_interrupts(GLOBAL); 
1662:  MOVLW  C0
1664:  IORWF  FF2,F
....................                 set_timer0(0x1D);   // se carga 29 para un desborde en 500 us teniendo en cuenta los tiempos en C 
1666:  CLRF   FD7
1668:  MOVLW  1D
166A:  MOVWF  FD6
.................... 					 
.................... 					estado = PUNTO_TENS_CORR; 
166C:  CLRF   4C
.................... 		 
....................  
.................... 				break; 
166E:  BRA    1672
.................... 			 
.................... 			default: estado = PUNTO_TENS_CORR; 
1670:  CLRF   4C
.................... 		} 
1672:  GOTO   16B0 (RETURN)
....................  
....................  
.................... } 
....................  
.................... //Funciones asociadas a los eventos 
....................  
.................... /** 
.................... *	\fn int -(void) 
.................... *	\brief Resumen 
.................... *	\details Detalles 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 4C07   PLL12 CPUDIV1 NOUSBDIV HS FCMEN NOIESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
