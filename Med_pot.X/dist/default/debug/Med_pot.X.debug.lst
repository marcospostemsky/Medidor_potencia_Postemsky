CCS PCH C Compiler, Version 5.048, 5967               03-nov-16 10:51

               Filename:   C:\Users\MARCOS\Proyecto_final\Med_pot.X\dist\default\debug\Med_pot.X.debug.lst

               ROM used:   6470 bytes (20%)
                           Largest free fragment is 25462
               RAM used:   94 (5%) at main() level
                           156 (8%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 30

*
0000:  GOTO   18AA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   00BC
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #import(file="build/default/debug/main.o") 
.................... #import(file="build/default/debug/funciones.o") 
.................... /** 
.................... *	\file main.c 
.................... *	\brief Resumen del contenido del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  DATA 50,72
00B0:  DATA 69,6D
00B2:  DATA 65,72
00B4:  DATA 20,70
00B6:  DATA 72,75
00B8:  DATA 65,62
00BA:  DATA 61,00
*
0346:  TBLRD*+
0348:  MOVF   FF5,F
034A:  BZ    0364
034C:  MOVFF  FF6,5E
0350:  MOVFF  FF7,5F
0354:  MOVFF  FF5,6C
0358:  RCALL  02D8
035A:  MOVFF  5E,FF6
035E:  MOVFF  5F,FF7
0362:  BRA    0346
0364:  GOTO   0392 (RETURN)
*
0562:  MOVLW  8E
0564:  MOVWF  00
0566:  MOVFF  8D,01
056A:  MOVFF  8C,02
056E:  CLRF   03
0570:  MOVF   01,F
0572:  BNZ   0586
0574:  MOVFF  02,01
0578:  CLRF   02
057A:  MOVLW  08
057C:  SUBWF  00,F
057E:  MOVF   01,F
0580:  BNZ   0586
0582:  CLRF   00
0584:  BRA    0596
0586:  BCF    FD8.0
0588:  BTFSC  01.7
058A:  BRA    0594
058C:  RLCF   02,F
058E:  RLCF   01,F
0590:  DECF   00,F
0592:  BRA    0586
0594:  BCF    01.7
0596:  RETURN 0
0598:  MOVF   x8C,W
059A:  BTFSC  FD8.2
059C:  BRA    0680
059E:  MOVWF  00
05A0:  MOVF   x90,W
05A2:  BTFSC  FD8.2
05A4:  BRA    0680
05A6:  ADDWF  00,F
05A8:  BNC   05B2
05AA:  MOVLW  81
05AC:  ADDWF  00,F
05AE:  BC    0680
05B0:  BRA    05BA
05B2:  MOVLW  7F
05B4:  SUBWF  00,F
05B6:  BNC   0680
05B8:  BZ    0680
05BA:  MOVFF  8D,94
05BE:  MOVF   x91,W
05C0:  XORWF  x94,F
05C2:  BSF    x8D.7
05C4:  BSF    x91.7
05C6:  MOVF   x8F,W
05C8:  MULWF  x93
05CA:  MOVFF  FF4,96
05CE:  MOVF   x8E,W
05D0:  MULWF  x92
05D2:  MOVFF  FF4,03
05D6:  MOVFF  FF3,95
05DA:  MULWF  x93
05DC:  MOVF   FF3,W
05DE:  ADDWF  x96,F
05E0:  MOVF   FF4,W
05E2:  ADDWFC x95,F
05E4:  MOVLW  00
05E6:  ADDWFC 03,F
05E8:  MOVF   x8F,W
05EA:  MULWF  x92
05EC:  MOVF   FF3,W
05EE:  ADDWF  x96,F
05F0:  MOVF   FF4,W
05F2:  ADDWFC x95,F
05F4:  MOVLW  00
05F6:  CLRF   02
05F8:  ADDWFC 03,F
05FA:  ADDWFC 02,F
05FC:  MOVF   x8D,W
05FE:  MULWF  x93
0600:  MOVF   FF3,W
0602:  ADDWF  x95,F
0604:  MOVF   FF4,W
0606:  ADDWFC 03,F
0608:  MOVLW  00
060A:  ADDWFC 02,F
060C:  MOVF   x8D,W
060E:  MULWF  x92
0610:  MOVF   FF3,W
0612:  ADDWF  03,F
0614:  MOVF   FF4,W
0616:  ADDWFC 02,F
0618:  MOVLW  00
061A:  CLRF   01
061C:  ADDWFC 01,F
061E:  MOVF   x8F,W
0620:  MULWF  x91
0622:  MOVF   FF3,W
0624:  ADDWF  x95,F
0626:  MOVF   FF4,W
0628:  ADDWFC 03,F
062A:  MOVLW  00
062C:  ADDWFC 02,F
062E:  ADDWFC 01,F
0630:  MOVF   x8E,W
0632:  MULWF  x91
0634:  MOVF   FF3,W
0636:  ADDWF  03,F
0638:  MOVF   FF4,W
063A:  ADDWFC 02,F
063C:  MOVLW  00
063E:  ADDWFC 01,F
0640:  MOVF   x8D,W
0642:  MULWF  x91
0644:  MOVF   FF3,W
0646:  ADDWF  02,F
0648:  MOVF   FF4,W
064A:  ADDWFC 01,F
064C:  INCF   00,F
064E:  BTFSC  01.7
0650:  BRA    065C
0652:  RLCF   x95,F
0654:  RLCF   03,F
0656:  RLCF   02,F
0658:  RLCF   01,F
065A:  DECF   00,F
065C:  MOVLW  00
065E:  BTFSS  x95.7
0660:  BRA    0676
0662:  INCF   03,F
0664:  ADDWFC 02,F
0666:  ADDWFC 01,F
0668:  MOVF   01,W
066A:  BNZ   0676
066C:  MOVF   02,W
066E:  BNZ   0676
0670:  MOVF   03,W
0672:  BNZ   0676
0674:  INCF   00,F
0676:  BTFSC  x94.7
0678:  BSF    01.7
067A:  BTFSS  x94.7
067C:  BCF    01.7
067E:  BRA    0688
0680:  CLRF   00
0682:  CLRF   01
0684:  CLRF   02
0686:  CLRF   03
0688:  RETURN 0
068A:  MOVF   x70,W
068C:  BTFSC  FD8.2
068E:  BRA    07DA
0690:  MOVWF  x7C
0692:  MOVF   x74,W
0694:  BTFSC  FD8.2
0696:  BRA    07DA
0698:  SUBWF  x7C,F
069A:  BNC   06A6
069C:  MOVLW  7F
069E:  ADDWF  x7C,F
06A0:  BTFSC  FD8.0
06A2:  BRA    07DA
06A4:  BRA    06B2
06A6:  MOVLW  81
06A8:  SUBWF  x7C,F
06AA:  BTFSS  FD8.0
06AC:  BRA    07DA
06AE:  BTFSC  FD8.2
06B0:  BRA    07DA
06B2:  MOVFF  7C,00
06B6:  CLRF   01
06B8:  CLRF   02
06BA:  CLRF   03
06BC:  CLRF   x7B
06BE:  MOVFF  71,7A
06C2:  BSF    x7A.7
06C4:  MOVFF  72,79
06C8:  MOVFF  73,78
06CC:  MOVLW  19
06CE:  MOVWF  x7C
06D0:  MOVF   x77,W
06D2:  SUBWF  x78,F
06D4:  BC    06F0
06D6:  MOVLW  01
06D8:  SUBWF  x79,F
06DA:  BC    06F0
06DC:  SUBWF  x7A,F
06DE:  BC    06F0
06E0:  SUBWF  x7B,F
06E2:  BC    06F0
06E4:  INCF   x7B,F
06E6:  INCF   x7A,F
06E8:  INCF   x79,F
06EA:  MOVF   x77,W
06EC:  ADDWF  x78,F
06EE:  BRA    0740
06F0:  MOVF   x76,W
06F2:  SUBWF  x79,F
06F4:  BC    071A
06F6:  MOVLW  01
06F8:  SUBWF  x7A,F
06FA:  BC    071A
06FC:  SUBWF  x7B,F
06FE:  BC    071A
0700:  INCF   x7B,F
0702:  INCF   x7A,F
0704:  MOVF   x76,W
0706:  ADDWF  x79,F
0708:  MOVF   x77,W
070A:  ADDWF  x78,F
070C:  BNC   0740
070E:  INCF   x79,F
0710:  BNZ   0740
0712:  INCF   x7A,F
0714:  BNZ   0740
0716:  INCF   x7B,F
0718:  BRA    0740
071A:  MOVF   x75,W
071C:  IORLW  80
071E:  SUBWF  x7A,F
0720:  BC    073E
0722:  MOVLW  01
0724:  SUBWF  x7B,F
0726:  BC    073E
0728:  INCF   x7B,F
072A:  MOVF   x75,W
072C:  IORLW  80
072E:  ADDWF  x7A,F
0730:  MOVF   x76,W
0732:  ADDWF  x79,F
0734:  BNC   0708
0736:  INCF   x7A,F
0738:  BNZ   0708
073A:  INCF   x7B,F
073C:  BRA    0708
073E:  BSF    03.0
0740:  DECFSZ x7C,F
0742:  BRA    0746
0744:  BRA    075C
0746:  BCF    FD8.0
0748:  RLCF   x78,F
074A:  RLCF   x79,F
074C:  RLCF   x7A,F
074E:  RLCF   x7B,F
0750:  BCF    FD8.0
0752:  RLCF   03,F
0754:  RLCF   02,F
0756:  RLCF   01,F
0758:  RLCF   x7D,F
075A:  BRA    06D0
075C:  BTFSS  x7D.0
075E:  BRA    076C
0760:  BCF    FD8.0
0762:  RRCF   01,F
0764:  RRCF   02,F
0766:  RRCF   03,F
0768:  RRCF   x7D,F
076A:  BRA    0770
076C:  DECF   00,F
076E:  BZ    07DA
0770:  BTFSC  x7D.7
0772:  BRA    07B0
0774:  BCF    FD8.0
0776:  RLCF   x78,F
0778:  RLCF   x79,F
077A:  RLCF   x7A,F
077C:  RLCF   x7B,F
077E:  MOVF   x77,W
0780:  SUBWF  x78,F
0782:  BC    0792
0784:  MOVLW  01
0786:  SUBWF  x79,F
0788:  BC    0792
078A:  SUBWF  x7A,F
078C:  BC    0792
078E:  SUBWF  x7B,F
0790:  BNC   07C6
0792:  MOVF   x76,W
0794:  SUBWF  x79,F
0796:  BC    07A2
0798:  MOVLW  01
079A:  SUBWF  x7A,F
079C:  BC    07A2
079E:  SUBWF  x7B,F
07A0:  BNC   07C6
07A2:  MOVF   x75,W
07A4:  IORLW  80
07A6:  SUBWF  x7A,F
07A8:  BC    07B0
07AA:  MOVLW  01
07AC:  SUBWF  x7B,F
07AE:  BNC   07C6
07B0:  INCF   03,F
07B2:  BNZ   07C6
07B4:  INCF   02,F
07B6:  BNZ   07C6
07B8:  INCF   01,F
07BA:  BNZ   07C6
07BC:  INCF   00,F
07BE:  BZ    07DA
07C0:  RRCF   01,F
07C2:  RRCF   02,F
07C4:  RRCF   03,F
07C6:  MOVFF  71,7C
07CA:  MOVF   x75,W
07CC:  XORWF  x7C,F
07CE:  BTFSS  x7C.7
07D0:  BRA    07D6
07D2:  BSF    01.7
07D4:  BRA    07E2
07D6:  BCF    01.7
07D8:  BRA    07E2
07DA:  CLRF   00
07DC:  CLRF   01
07DE:  CLRF   02
07E0:  CLRF   03
07E2:  RETURN 0
07E4:  MOVLW  80
07E6:  BTFSC  FD8.1
07E8:  XORWF  x91,F
07EA:  CLRF   x96
07EC:  CLRF   x97
07EE:  MOVFF  8D,95
07F2:  MOVF   x91,W
07F4:  XORWF  x95,F
07F6:  MOVF   x8C,W
07F8:  BTFSC  FD8.2
07FA:  BRA    09B4
07FC:  MOVWF  x94
07FE:  MOVWF  00
0800:  MOVF   x90,W
0802:  BTFSC  FD8.2
0804:  BRA    09C6
0806:  SUBWF  x94,F
0808:  BTFSC  FD8.2
080A:  BRA    090E
080C:  BNC   0888
080E:  MOVFF  91,9A
0812:  BSF    x9A.7
0814:  MOVFF  92,99
0818:  MOVFF  93,98
081C:  CLRF   x97
081E:  BCF    FD8.0
0820:  RRCF   x9A,F
0822:  RRCF   x99,F
0824:  RRCF   x98,F
0826:  RRCF   x97,F
0828:  DECFSZ x94,F
082A:  BRA    081C
082C:  BTFSS  x95.7
082E:  BRA    0836
0830:  BSF    x96.0
0832:  BRA    09EE
0834:  BCF    x96.0
0836:  BCF    x94.0
0838:  BSF    x96.4
083A:  CLRF   FEA
083C:  MOVLW  8F
083E:  MOVWF  FE9
0840:  BRA    0A14
0842:  BCF    x96.4
0844:  BTFSC  x95.7
0846:  BRA    085C
0848:  BTFSS  x94.0
084A:  BRA    0872
084C:  RRCF   x9A,F
084E:  RRCF   x99,F
0850:  RRCF   x98,F
0852:  RRCF   x97,F
0854:  INCF   00,F
0856:  BTFSC  FD8.2
0858:  BRA    09E4
085A:  BRA    0872
085C:  BTFSC  x9A.7
085E:  BRA    0878
0860:  BCF    FD8.0
0862:  RLCF   x97,F
0864:  RLCF   x98,F
0866:  RLCF   x99,F
0868:  RLCF   x9A,F
086A:  DECF   00,F
086C:  BTFSC  FD8.2
086E:  BRA    09E4
0870:  BRA    085C
0872:  BSF    x96.6
0874:  BRA    094C
0876:  BCF    x96.6
0878:  MOVFF  8D,95
087C:  BTFSS  x8D.7
087E:  BRA    0884
0880:  BSF    x9A.7
0882:  BRA    09D6
0884:  BCF    x9A.7
0886:  BRA    09D6
0888:  MOVFF  90,94
088C:  MOVFF  90,00
0890:  MOVF   x8C,W
0892:  SUBWF  x94,F
0894:  MOVFF  8D,9A
0898:  BSF    x9A.7
089A:  MOVFF  8E,99
089E:  MOVFF  8F,98
08A2:  CLRF   x97
08A4:  BCF    FD8.0
08A6:  RRCF   x9A,F
08A8:  RRCF   x99,F
08AA:  RRCF   x98,F
08AC:  RRCF   x97,F
08AE:  DECFSZ x94,F
08B0:  BRA    08A2
08B2:  BTFSS  x95.7
08B4:  BRA    08BC
08B6:  BSF    x96.1
08B8:  BRA    09EE
08BA:  BCF    x96.1
08BC:  BCF    x94.0
08BE:  BSF    x96.5
08C0:  CLRF   FEA
08C2:  MOVLW  93
08C4:  MOVWF  FE9
08C6:  BRA    0A14
08C8:  BCF    x96.5
08CA:  BTFSC  x95.7
08CC:  BRA    08E2
08CE:  BTFSS  x94.0
08D0:  BRA    08F8
08D2:  RRCF   x9A,F
08D4:  RRCF   x99,F
08D6:  RRCF   x98,F
08D8:  RRCF   x97,F
08DA:  INCF   00,F
08DC:  BTFSC  FD8.2
08DE:  BRA    09E4
08E0:  BRA    08F8
08E2:  BTFSC  x9A.7
08E4:  BRA    08FE
08E6:  BCF    FD8.0
08E8:  RLCF   x97,F
08EA:  RLCF   x98,F
08EC:  RLCF   x99,F
08EE:  RLCF   x9A,F
08F0:  DECF   00,F
08F2:  BTFSC  FD8.2
08F4:  BRA    09E4
08F6:  BRA    08E2
08F8:  BSF    x96.7
08FA:  BRA    094C
08FC:  BCF    x96.7
08FE:  MOVFF  91,95
0902:  BTFSS  x91.7
0904:  BRA    090A
0906:  BSF    x9A.7
0908:  BRA    09D6
090A:  BCF    x9A.7
090C:  BRA    09D6
090E:  MOVFF  91,9A
0912:  BSF    x9A.7
0914:  MOVFF  92,99
0918:  MOVFF  93,98
091C:  BTFSS  x95.7
091E:  BRA    0928
0920:  BCF    x9A.7
0922:  BSF    x96.2
0924:  BRA    09EE
0926:  BCF    x96.2
0928:  CLRF   x97
092A:  BCF    x94.0
092C:  CLRF   FEA
092E:  MOVLW  8F
0930:  MOVWF  FE9
0932:  BRA    0A14
0934:  BTFSC  x95.7
0936:  BRA    0970
0938:  MOVFF  8D,95
093C:  BTFSS  x94.0
093E:  BRA    094C
0940:  RRCF   x9A,F
0942:  RRCF   x99,F
0944:  RRCF   x98,F
0946:  RRCF   x97,F
0948:  INCF   00,F
094A:  BZ    09E4
094C:  BTFSS  x97.7
094E:  BRA    0966
0950:  INCF   x98,F
0952:  BNZ   0966
0954:  INCF   x99,F
0956:  BNZ   0966
0958:  INCF   x9A,F
095A:  BNZ   0966
095C:  RRCF   x9A,F
095E:  RRCF   x99,F
0960:  RRCF   x98,F
0962:  INCF   00,F
0964:  BZ    09E4
0966:  BTFSC  x96.6
0968:  BRA    0876
096A:  BTFSC  x96.7
096C:  BRA    08FC
096E:  BRA    09A8
0970:  MOVLW  80
0972:  XORWF  x9A,F
0974:  BTFSS  x9A.7
0976:  BRA    0980
0978:  BRA    09EE
097A:  MOVFF  91,95
097E:  BRA    0994
0980:  MOVFF  8D,95
0984:  MOVF   x9A,F
0986:  BNZ   0994
0988:  MOVF   x99,F
098A:  BNZ   0994
098C:  MOVF   x98,F
098E:  BNZ   0994
0990:  CLRF   00
0992:  BRA    09D6
0994:  BTFSC  x9A.7
0996:  BRA    09A8
0998:  BCF    FD8.0
099A:  RLCF   x97,F
099C:  RLCF   x98,F
099E:  RLCF   x99,F
09A0:  RLCF   x9A,F
09A2:  DECFSZ 00,F
09A4:  BRA    0994
09A6:  BRA    09E4
09A8:  BTFSS  x95.7
09AA:  BRA    09B0
09AC:  BSF    x9A.7
09AE:  BRA    09D6
09B0:  BCF    x9A.7
09B2:  BRA    09D6
09B4:  MOVFF  90,00
09B8:  MOVFF  91,9A
09BC:  MOVFF  92,99
09C0:  MOVFF  93,98
09C4:  BRA    09D6
09C6:  MOVFF  8C,00
09CA:  MOVFF  8D,9A
09CE:  MOVFF  8E,99
09D2:  MOVFF  8F,98
09D6:  MOVFF  9A,01
09DA:  MOVFF  99,02
09DE:  MOVFF  98,03
09E2:  BRA    0A4C
09E4:  CLRF   00
09E6:  CLRF   01
09E8:  CLRF   02
09EA:  CLRF   03
09EC:  BRA    0A4C
09EE:  CLRF   x97
09F0:  COMF   x98,F
09F2:  COMF   x99,F
09F4:  COMF   x9A,F
09F6:  COMF   x97,F
09F8:  INCF   x97,F
09FA:  BNZ   0A06
09FC:  INCF   x98,F
09FE:  BNZ   0A06
0A00:  INCF   x99,F
0A02:  BNZ   0A06
0A04:  INCF   x9A,F
0A06:  BTFSC  x96.0
0A08:  BRA    0834
0A0A:  BTFSC  x96.1
0A0C:  BRA    08BA
0A0E:  BTFSC  x96.2
0A10:  BRA    0926
0A12:  BRA    097A
0A14:  MOVF   FEF,W
0A16:  ADDWF  x98,F
0A18:  BNC   0A24
0A1A:  INCF   x99,F
0A1C:  BNZ   0A24
0A1E:  INCF   x9A,F
0A20:  BTFSC  FD8.2
0A22:  BSF    x94.0
0A24:  MOVF   FED,F
0A26:  MOVF   FEF,W
0A28:  ADDWF  x99,F
0A2A:  BNC   0A32
0A2C:  INCF   x9A,F
0A2E:  BTFSC  FD8.2
0A30:  BSF    x94.0
0A32:  MOVF   FED,F
0A34:  MOVF   FEF,W
0A36:  BTFSC  FEF.7
0A38:  BRA    0A3C
0A3A:  XORLW  80
0A3C:  ADDWF  x9A,F
0A3E:  BTFSC  FD8.0
0A40:  BSF    x94.0
0A42:  BTFSC  x96.4
0A44:  BRA    0842
0A46:  BTFSC  x96.5
0A48:  BRA    08C8
0A4A:  BRA    0934
0A4C:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
*
00E4:  CLRF   FEA
00E6:  MOVLW  6D
00E8:  MOVWF  FE9
00EA:  MOVF   FEF,W
00EC:  BZ    010A
00EE:  MOVLW  0F
00F0:  MOVWF  01
00F2:  CLRF   00
00F4:  DECFSZ 00,F
00F6:  BRA    00F4
00F8:  DECFSZ 01,F
00FA:  BRA    00F2
00FC:  MOVLW  8F
00FE:  MOVWF  00
0100:  DECFSZ 00,F
0102:  BRA    0100
0104:  NOP   
0106:  DECFSZ FEF,F
0108:  BRA    00EE
010A:  RETURN 0
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
010C:  MOVLW  08
010E:  MOVWF  01
0110:  MOVLW  11
0112:  MOVWF  00
0114:  DECFSZ 00,F
0116:  BRA    0114
0118:  BCF    F8C.7
011A:  BCF    F95.7
011C:  MOVLW  11
011E:  MOVWF  00
0120:  DECFSZ 00,F
0122:  BRA    0120
0124:  RLCF   x71,F
0126:  BCF    F8C.6
0128:  BTFSC  FD8.0
012A:  BSF    F95.6
012C:  BTFSS  FD8.0
012E:  BCF    F95.6
0130:  BSF    F95.7
0132:  BTFSS  F83.7
0134:  BRA    0132
0136:  DECFSZ 01,F
0138:  BRA    0110
013A:  MOVLW  11
013C:  MOVWF  00
013E:  DECFSZ 00,F
0140:  BRA    013E
0142:  BCF    F8C.7
0144:  BCF    F95.7
0146:  NOP   
0148:  BSF    F95.6
014A:  MOVLW  11
014C:  MOVWF  00
014E:  DECFSZ 00,F
0150:  BRA    014E
0152:  MOVLW  11
0154:  MOVWF  00
0156:  DECFSZ 00,F
0158:  BRA    0156
015A:  BSF    F95.7
015C:  BTFSS  F83.7
015E:  BRA    015C
0160:  CLRF   01
0162:  MOVLW  11
0164:  MOVWF  00
0166:  DECFSZ 00,F
0168:  BRA    0166
016A:  BTFSC  F83.6
016C:  BSF    01.0
016E:  BCF    F8C.7
0170:  BCF    F95.7
0172:  BCF    F8C.6
0174:  BCF    F95.6
0176:  RETURN 0
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
....................         delay_us(20); 
....................         i2c_write(LCD_ADDR); //the slave addresse 
....................         delay_us(20); 
....................         i2c_write(data); 
....................         delay_us(20); 
....................         i2c_stop(); 
....................         delay_us(20); 
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
....................         i2c_send_nibble(data); 
....................         data=data-4;       //toggle EN back to 0 
....................         i2c_send_nibble(data); 
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
....................     lcd_send_byte(0x10); 
....................     delay_ms(2); 
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x30); 
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x20); 
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
....................         lcd_send_byte(0x80); 
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0xC0); 
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x60); 
....................            //clears the display 
....................         lcd_clear(); 
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
....................       case 2:  address= lcd_line_two;     break; 
....................       case 3:  address= lcd_line_three;   break; 
....................       case 4:  address= lcd_line_four;    break; 
....................       default: address= lcd_line_one;     break;  
....................    } 
....................   
....................    address+=x-1; 
....................    data=address&0xF0; 
....................    lcd_send_byte(data); 
....................    data=address&0x0F; 
....................    data=data<<4; 
....................    lcd_send_byte(data); 
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
....................      case '\1': lcd_gotoxy(1,1);  break; 
....................      case '\2': lcd_gotoxy(1,2);  break; 
....................      case '\3': lcd_gotoxy(1,3);  break; 
....................      case '\4': lcd_gotoxy(1,4);  break; 
....................  
....................      default: 
....................         data=in_data&0xF0; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................         data=in_data&0x0F; 
....................         data=data<<4; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................      break; 
....................    } 
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
....................  
.................... const long carga= 0xE8AB; 
.................... extern int contador; 
.................... extern long pulso_timer; 
....................  
.................... void inicializar(); 
....................  
.................... void main() 
*
18AA:  CLRF   FF8
18AC:  BCF    FD0.7
18AE:  BSF    07.7
18B0:  BSF    20.0
18B2:  CLRF   24
18B4:  CLRF   23
18B6:  BSF    20.0
18B8:  BSF    20.0
18BA:  BRA    18FA
18BC:  DATA 02,00
18BE:  DATA 19,00
18C0:  DATA 00,02
18C2:  DATA 00,21
18C4:  DATA 00,00
18C6:  DATA 01,00
18C8:  DATA 22,00
18CA:  DATA 01,00
18CC:  DATA 25,00
18CE:  DATA 01,00
18D0:  DATA 25,00
18D2:  DATA 01,0F
18D4:  DATA B4,07
18D6:  DATA 01,00
18D8:  DATA 34,14
18DA:  DATA 01,00
18DC:  DATA 34,14
18DE:  DATA 04,00
18E0:  DATA 51,00
18E2:  DATA 00,00
18E4:  DATA 00,08
18E6:  DATA 40,51
18E8:  DATA 00,08
18EA:  DATA 40,55
18EC:  DATA 00,05
18EE:  DATA 40,59
18F0:  DATA 00,01
18F2:  DATA 00,5D
18F4:  DATA 00,01
18F6:  DATA 00,26
18F8:  DATA 00,00
18FA:  MOVLW  00
18FC:  MOVWF  FF8
18FE:  MOVLW  18
1900:  MOVWF  FF7
1902:  MOVLW  BC
1904:  MOVWF  FF6
1906:  TBLRD*+
1908:  MOVF   FF5,W
190A:  MOVWF  00
190C:  XORLW  00
190E:  BZ    1936
1910:  TBLRD*+
1912:  MOVF   FF5,W
1914:  MOVWF  01
1916:  BTFSC  FE8.7
1918:  BRA    1924
191A:  ANDLW  0F
191C:  MOVWF  FEA
191E:  TBLRD*+
1920:  MOVFF  FF5,FE9
1924:  BTFSC  01.6
1926:  TBLRD*+
1928:  BTFSS  01.6
192A:  TBLRD*+
192C:  MOVFF  FF5,FEE
1930:  DCFSNZ 00,F
1932:  BRA    1906
1934:  BRA    1928
1936:  CLRF   FF8
.................... { 
....................  
.................... //declaracion de variables 
.................... //inicializacion de perifericos 
....................  
.................... 	inicializar() ; 
1938:  GOTO   0368
....................      
....................     set_timer1(carga); 
193C:  MOVLW  E8
193E:  MOVWF  FCF
1940:  MOVLW  AB
1942:  MOVWF  FCE
.................... 	while(1) 
.................... 	{ 
....................  
.................... 		maquina_estado(); 
1944:  BRA    11BE
1946:  BRA    1944
....................  
.................... 	} 
.................... } 
....................  
1948:  BRA    1948
.................... void Inicializar(){ 
....................     setup_timer_1( T1_INTERNAL|T1_DIV_BY_2); 
*
0368:  MOVLW  95
036A:  MOVWF  FCD
....................     setup_timer_0(T0_INTERNAL |T0_DIV_32); 
036C:  MOVLW  84
036E:  MOVWF  FD5
....................     set_timer0(0x0000); 
0370:  CLRF   FD7
0372:  CLRF   FD6
....................     set_tris_a(0xE8);// configuracion portA necesaria para la libreria control_ADC 
0374:  MOVLW  E8
0376:  MOVWF  F92
....................     set_tris_b(0xFF); 
0378:  MOVLW  FF
037A:  MOVWF  F93
....................     contador=0; 
037C:  CLRF   22
....................     lcd_init(); 
037E:  BRA    0226
....................     lcd_gotoxy(1,1); 
0380:  MOVLW  01
0382:  MOVWF  x6D
0384:  MOVWF  x6E
0386:  RCALL  0282
....................     printf(LCD_PUTC,"Primer prueba"); 
0388:  MOVLW  AE
038A:  MOVWF  FF6
038C:  MOVLW  00
038E:  MOVWF  FF7
0390:  BRA    0346
....................     lcd_backlight=ON; 
0392:  BSF    20.0
....................     enable_interrupts (INT_TIMER1); 
0394:  BSF    F9D.0
....................     enable_interrupts (GLOBAL); 
0396:  MOVLW  C0
0398:  IORWF  FF2,F
....................     output_high (PIN_A0); //pone en alto el chipselect del AD7450 
039A:  BSF    F89.0
....................     output_high (PIN_A1); // pone en alto el chipselect del MAX186 
039C:  BSF    F89.1
039E:  GOTO   193C (RETURN)
.................... } 
....................  
....................  
.................... /** 
.................... *	\file funciones.c 
.................... *	\brief  
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
00CC:  DATA 70,6F
00CE:  DATA 74,3D
00D0:  DATA 20,25
00D2:  DATA 66,20
00D4:  DATA 57,00
00D6:  DATA 54,3D
00D8:  DATA 25,66
00DA:  DATA 20,20
00DC:  DATA 49,3D
00DE:  DATA 25,66
00E0:  DATA 20,20
00E2:  DATA 00,00
*
0518:  MOVLW  8E
051A:  MOVWF  00
051C:  MOVFF  5F,01
0520:  MOVFF  5E,02
0524:  CLRF   03
0526:  BTFSS  5F.7
0528:  BRA    0534
052A:  COMF   01,F
052C:  COMF   02,F
052E:  INCF   02,F
0530:  BNZ   0534
0532:  INCF   01,F
0534:  MOVF   01,F
0536:  BNZ   054A
0538:  MOVFF  02,01
053C:  CLRF   02
053E:  MOVLW  08
0540:  SUBWF  00,F
0542:  MOVF   01,F
0544:  BNZ   054A
0546:  CLRF   00
0548:  BRA    055E
054A:  BCF    FD8.0
054C:  BTFSC  01.7
054E:  BRA    0558
0550:  RLCF   02,F
0552:  RLCF   01,F
0554:  DECF   00,F
0556:  BRA    054A
0558:  BTFSC  5F.7
055A:  BRA    055E
055C:  BCF    01.7
055E:  GOTO   1200 (RETURN)
*
0A4E:  MOVFF  89,90
0A52:  MOVF   x8D,W
0A54:  XORWF  x90,F
0A56:  BTFSS  x90.7
0A58:  BRA    0A64
0A5A:  BCF    FD8.2
0A5C:  BCF    FD8.0
0A5E:  BTFSC  x89.7
0A60:  BSF    FD8.0
0A62:  BRA    0AC2
0A64:  MOVFF  89,90
0A68:  MOVFF  8C,91
0A6C:  MOVF   x88,W
0A6E:  SUBWF  x91,F
0A70:  BZ    0A7E
0A72:  BTFSS  x90.7
0A74:  BRA    0AC2
0A76:  MOVF   FD8,W
0A78:  XORLW  01
0A7A:  MOVWF  FD8
0A7C:  BRA    0AC2
0A7E:  MOVFF  8D,91
0A82:  MOVF   x89,W
0A84:  SUBWF  x91,F
0A86:  BZ    0A94
0A88:  BTFSS  x90.7
0A8A:  BRA    0AC2
0A8C:  MOVF   FD8,W
0A8E:  XORLW  01
0A90:  MOVWF  FD8
0A92:  BRA    0AC2
0A94:  MOVFF  8E,91
0A98:  MOVF   x8A,W
0A9A:  SUBWF  x91,F
0A9C:  BZ    0AAA
0A9E:  BTFSS  x90.7
0AA0:  BRA    0AC2
0AA2:  MOVF   FD8,W
0AA4:  XORLW  01
0AA6:  MOVWF  FD8
0AA8:  BRA    0AC2
0AAA:  MOVFF  8F,91
0AAE:  MOVF   x8B,W
0AB0:  SUBWF  x91,F
0AB2:  BZ    0AC0
0AB4:  BTFSS  x90.7
0AB6:  BRA    0AC2
0AB8:  MOVF   FD8,W
0ABA:  XORLW  01
0ABC:  MOVWF  FD8
0ABE:  BRA    0AC2
0AC0:  BCF    FD8.0
0AC2:  RETURN 0
*
0BCE:  MOVLW  8E
0BD0:  MOVWF  00
0BD2:  MOVF   x88,W
0BD4:  SUBWF  00,F
0BD6:  MOVFF  89,02
0BDA:  MOVFF  8A,01
0BDE:  BSF    02.7
0BE0:  MOVF   00,F
0BE2:  BZ    0BF6
0BE4:  BCF    FD8.0
0BE6:  MOVF   02,F
0BE8:  BNZ   0BEE
0BEA:  MOVF   01,F
0BEC:  BZ    0BF6
0BEE:  RRCF   02,F
0BF0:  RRCF   01,F
0BF2:  DECFSZ 00,F
0BF4:  BRA    0BE4
0BF6:  BTFSS  x89.7
0BF8:  BRA    0C04
0BFA:  COMF   01,F
0BFC:  COMF   02,F
0BFE:  INCF   01,F
0C00:  BTFSC  FD8.2
0C02:  INCF   02,F
0C04:  GOTO   0CB4 (RETURN)
*
0F4E:  TBLRD*+
0F50:  MOVFF  FF6,5F
0F54:  MOVFF  FF7,60
0F58:  MOVFF  FF5,6C
0F5C:  CALL   02D8
0F60:  MOVFF  5F,FF6
0F64:  MOVFF  60,FF7
0F68:  DECFSZ 5E,F
0F6A:  BRA    0F4E
0F6C:  RETURN 0
0F6E:  MOVF   x6B,W
0F70:  SUBLW  B6
0F72:  MOVWF  x6B
0F74:  CLRF   03
0F76:  MOVFF  6C,6F
0F7A:  BSF    x6C.7
0F7C:  BCF    FD8.0
0F7E:  RRCF   x6C,F
0F80:  RRCF   x6D,F
0F82:  RRCF   x6E,F
0F84:  RRCF   03,F
0F86:  RRCF   02,F
0F88:  RRCF   01,F
0F8A:  RRCF   00,F
0F8C:  DECFSZ x6B,F
0F8E:  BRA    0F7C
0F90:  BTFSS  x6F.7
0F92:  BRA    0FAA
0F94:  COMF   00,F
0F96:  COMF   01,F
0F98:  COMF   02,F
0F9A:  COMF   03,F
0F9C:  INCF   00,F
0F9E:  BTFSC  FD8.2
0FA0:  INCF   01,F
0FA2:  BTFSC  FD8.2
0FA4:  INCF   02,F
0FA6:  BTFSC  FD8.2
0FA8:  INCF   03,F
0FAA:  GOTO   108C (RETURN)
0FAE:  BTFSC  FD8.1
0FB0:  BRA    0FB8
0FB2:  CLRF   FEA
0FB4:  MOVLW  73
0FB6:  MOVWF  FE9
0FB8:  CLRF   00
0FBA:  CLRF   01
0FBC:  CLRF   02
0FBE:  CLRF   03
0FC0:  CLRF   x73
0FC2:  CLRF   x74
0FC4:  CLRF   x75
0FC6:  CLRF   x76
0FC8:  MOVF   x72,W
0FCA:  IORWF  x71,W
0FCC:  IORWF  x70,W
0FCE:  IORWF  x6F,W
0FD0:  BZ    102A
0FD2:  MOVLW  20
0FD4:  MOVWF  x77
0FD6:  BCF    FD8.0
0FD8:  RLCF   x6B,F
0FDA:  RLCF   x6C,F
0FDC:  RLCF   x6D,F
0FDE:  RLCF   x6E,F
0FE0:  RLCF   x73,F
0FE2:  RLCF   x74,F
0FE4:  RLCF   x75,F
0FE6:  RLCF   x76,F
0FE8:  MOVF   x72,W
0FEA:  SUBWF  x76,W
0FEC:  BNZ   0FFE
0FEE:  MOVF   x71,W
0FF0:  SUBWF  x75,W
0FF2:  BNZ   0FFE
0FF4:  MOVF   x70,W
0FF6:  SUBWF  x74,W
0FF8:  BNZ   0FFE
0FFA:  MOVF   x6F,W
0FFC:  SUBWF  x73,W
0FFE:  BNC   101E
1000:  MOVF   x6F,W
1002:  SUBWF  x73,F
1004:  MOVF   x70,W
1006:  BTFSS  FD8.0
1008:  INCFSZ x70,W
100A:  SUBWF  x74,F
100C:  MOVF   x71,W
100E:  BTFSS  FD8.0
1010:  INCFSZ x71,W
1012:  SUBWF  x75,F
1014:  MOVF   x72,W
1016:  BTFSS  FD8.0
1018:  INCFSZ x72,W
101A:  SUBWF  x76,F
101C:  BSF    FD8.0
101E:  RLCF   00,F
1020:  RLCF   01,F
1022:  RLCF   02,F
1024:  RLCF   03,F
1026:  DECFSZ x77,F
1028:  BRA    0FD6
102A:  MOVFF  73,FEF
102E:  MOVFF  74,FEC
1032:  MOVFF  75,FEC
1036:  MOVFF  76,FEC
103A:  RETURN 0
103C:  MOVF   FE9,W
103E:  MOVWF  x63
1040:  MOVF   x62,W
1042:  MOVWF  x65
1044:  BZ    107A
1046:  MOVFF  61,8F
104A:  MOVFF  60,8E
104E:  MOVFF  5F,8D
1052:  MOVFF  5E,8C
1056:  CLRF   x93
1058:  CLRF   x92
105A:  MOVLW  20
105C:  MOVWF  x91
105E:  MOVLW  82
1060:  MOVWF  x90
1062:  CALL   0598
1066:  MOVFF  03,61
106A:  MOVFF  02,60
106E:  MOVFF  01,5F
1072:  MOVFF  00,5E
1076:  DECFSZ x65,F
1078:  BRA    1046
107A:  MOVFF  61,6E
107E:  MOVFF  60,6D
1082:  MOVFF  5F,6C
1086:  MOVFF  5E,6B
108A:  BRA    0F6E
108C:  MOVFF  03,61
1090:  MOVFF  02,60
1094:  MOVFF  01,5F
1098:  MOVFF  00,5E
109C:  BTFSS  x61.7
109E:  BRA    10BA
10A0:  DECF   x63,F
10A2:  BSF    x63.5
10A4:  COMF   5E,F
10A6:  COMF   5F,F
10A8:  COMF   x60,F
10AA:  COMF   x61,F
10AC:  INCF   5E,F
10AE:  BTFSC  FD8.2
10B0:  INCF   5F,F
10B2:  BTFSC  FD8.2
10B4:  INCF   x60,F
10B6:  BTFSC  FD8.2
10B8:  INCF   x61,F
10BA:  MOVLW  3B
10BC:  MOVWF  x6A
10BE:  MOVLW  9A
10C0:  MOVWF  x69
10C2:  MOVLW  CA
10C4:  MOVWF  x68
10C6:  CLRF   x67
10C8:  MOVLW  0A
10CA:  MOVWF  x65
10CC:  MOVF   x62,W
10CE:  BTFSC  FD8.2
10D0:  INCF   x63,F
10D2:  BSF    FD8.1
10D4:  CLRF   FEA
10D6:  MOVLW  5E
10D8:  MOVWF  FE9
10DA:  MOVFF  61,6E
10DE:  MOVFF  60,6D
10E2:  MOVFF  5F,6C
10E6:  MOVFF  5E,6B
10EA:  MOVFF  6A,72
10EE:  MOVFF  69,71
10F2:  MOVFF  68,70
10F6:  MOVFF  67,6F
10FA:  RCALL  0FAE
10FC:  MOVF   01,W
10FE:  MOVF   00,F
1100:  BNZ   1120
1102:  INCF   x62,W
1104:  SUBWF  x65,W
1106:  BZ    1120
1108:  MOVF   x63,W
110A:  BZ    1124
110C:  ANDLW  0F
110E:  SUBWF  x65,W
1110:  BZ    1114
1112:  BC    118A
1114:  BTFSC  x63.7
1116:  BRA    118A
1118:  BTFSC  x63.6
111A:  BRA    1124
111C:  MOVLW  20
111E:  BRA    1180
1120:  MOVLW  20
1122:  ANDWF  x63,F
1124:  BTFSS  x63.5
1126:  BRA    1142
1128:  BCF    x63.5
112A:  MOVF   x62,W
112C:  BTFSS  FD8.2
112E:  DECF   x63,F
1130:  MOVF   00,W
1132:  MOVWF  x63
1134:  MOVLW  2D
1136:  MOVWF  x6C
1138:  CALL   02D8
113C:  MOVF   x63,W
113E:  MOVWF  00
1140:  CLRF   x63
1142:  MOVF   x62,W
1144:  SUBWF  x65,W
1146:  BNZ   115E
1148:  MOVF   00,W
114A:  MOVWF  x63
114C:  MOVLW  2E
114E:  MOVWF  x6C
1150:  CALL   02D8
1154:  MOVF   x63,W
1156:  MOVWF  00
1158:  MOVLW  20
115A:  ANDWF  x63,F
115C:  MOVLW  00
115E:  MOVLW  30
1160:  BTFSS  x63.5
1162:  BRA    1180
1164:  BCF    x63.5
1166:  MOVF   x62,W
1168:  BTFSS  FD8.2
116A:  DECF   x63,F
116C:  MOVF   00,W
116E:  MOVWF  x63
1170:  MOVLW  2D
1172:  MOVWF  x6C
1174:  CALL   02D8
1178:  MOVF   x63,W
117A:  MOVWF  00
117C:  CLRF   x63
117E:  MOVLW  30
1180:  ADDWF  00,F
1182:  MOVFF  00,6C
1186:  CALL   02D8
118A:  BCF    FD8.1
118C:  MOVFF  6A,6E
1190:  MOVFF  69,6D
1194:  MOVFF  68,6C
1198:  MOVFF  67,6B
119C:  CLRF   x72
119E:  CLRF   x71
11A0:  CLRF   x70
11A2:  MOVLW  0A
11A4:  MOVWF  x6F
11A6:  RCALL  0FAE
11A8:  MOVFF  03,6A
11AC:  MOVFF  02,69
11B0:  MOVFF  01,68
11B4:  MOVFF  00,67
11B8:  DECFSZ x65,F
11BA:  BRA    10D2
11BC:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
.................... int contador = 0 ;int pulso_timer = 0 ; 
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
0AC4:  MOVFF  65,8B
0AC8:  MOVFF  64,8A
0ACC:  MOVFF  63,89
0AD0:  MOVFF  62,88
0AD4:  CLRF   x8F
0AD6:  CLRF   x8E
0AD8:  CLRF   x8D
0ADA:  CLRF   x8C
0ADC:  RCALL  0A4E
0ADE:  BC    0AE2
0AE0:  BNZ   0AEC
....................       return(0.0); 
0AE2:  CLRF   00
0AE4:  CLRF   01
0AE6:  CLRF   02
0AE8:  CLRF   03
0AEA:  BRA    0BCC
....................  
....................    y=x; 
0AEC:  MOVFF  65,69
0AF0:  MOVFF  64,68
0AF4:  MOVFF  63,67
0AF8:  MOVFF  62,66
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
0AFC:  CLRF   x6F
0AFE:  MOVLW  66
0B00:  MOVWF  x6E
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
0B02:  MOVFF  6E,FE9
0B06:  MOVFF  6F,FEA
0B0A:  MOVF   FEF,W
0B0C:  CLRF   x73
0B0E:  MOVWF  x72
0B10:  MOVLW  7F
0B12:  ADDWF  x72,F
0B14:  MOVLW  00
0B16:  ADDWFC x73,F
0B18:  BCF    FD8.0
0B1A:  RRCF   x73,W
0B1C:  RRCF   x72,W
0B1E:  MOVFF  6F,FEA
0B22:  MOVFF  6E,FE9
0B26:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0B28:  MOVFF  69,6D
0B2C:  MOVFF  68,6C
0B30:  MOVFF  67,6B
0B34:  MOVFF  66,6A
....................       y+=(x/y); 
0B38:  MOVFF  65,73
0B3C:  MOVFF  64,72
0B40:  MOVFF  63,71
0B44:  MOVFF  62,70
0B48:  MOVFF  69,77
0B4C:  MOVFF  68,76
0B50:  MOVFF  67,75
0B54:  MOVFF  66,74
0B58:  RCALL  068A
0B5A:  BCF    FD8.1
0B5C:  MOVFF  69,8F
0B60:  MOVFF  68,8E
0B64:  MOVFF  67,8D
0B68:  MOVFF  66,8C
0B6C:  MOVFF  03,93
0B70:  MOVFF  02,92
0B74:  MOVFF  01,91
0B78:  MOVFF  00,90
0B7C:  RCALL  07E4
0B7E:  MOVFF  03,69
0B82:  MOVFF  02,68
0B86:  MOVFF  01,67
0B8A:  MOVFF  00,66
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
0B8E:  MOVFF  6E,FE9
0B92:  MOVFF  6F,FEA
0B96:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
0B98:  MOVFF  6D,8B
0B9C:  MOVFF  6C,8A
0BA0:  MOVFF  6B,89
0BA4:  MOVFF  6A,88
0BA8:  MOVFF  69,8F
0BAC:  MOVFF  68,8E
0BB0:  MOVFF  67,8D
0BB4:  MOVFF  66,8C
0BB8:  RCALL  0A4E
0BBA:  BNZ   0B28
....................  
....................    return(res); 
0BBC:  MOVFF  6A,00
0BC0:  MOVFF  6B,01
0BC4:  MOVFF  6C,02
0BC8:  MOVFF  6D,03
0BCC:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
0C08:  CLRF   x6D
0C0A:  CLRF   x6C
0C0C:  CLRF   x6B
0C0E:  MOVLW  7F
0C10:  MOVWF  x6A
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
0C12:  MOVLW  7E
0C14:  MOVWF  x74
0C16:  MOVLW  80
0C18:  MOVWF  x75
0C1A:  CLRF   x76
0C1C:  CLRF   x77
0C1E:  MOVLW  7A
0C20:  MOVWF  x78
0C22:  MOVLW  2A
0C24:  MOVWF  x79
0C26:  MOVLW  AA
0C28:  MOVWF  x7A
0C2A:  MOVLW  A3
0C2C:  MOVWF  x7B
0C2E:  MOVLW  75
0C30:  MOVWF  x7C
0C32:  MOVLW  B6
0C34:  MOVWF  x7D
0C36:  MOVLW  09
0C38:  MOVWF  x7E
0C3A:  MOVLW  B4
0C3C:  MOVWF  x7F
0C3E:  MOVLW  6F
0C40:  MOVWF  x80
0C42:  MOVLW  4F
0C44:  MOVWF  x81
0C46:  MOVLW  B6
0C48:  MOVWF  x82
0C4A:  MOVLW  AA
0C4C:  MOVWF  x83
0C4E:  MOVLW  69
0C50:  MOVWF  x84
0C52:  MOVLW  8B
0C54:  MOVWF  x85
0C56:  MOVLW  F6
0C58:  MOVWF  x86
0C5A:  MOVLW  E8
0C5C:  MOVWF  x87
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0C5E:  MOVFF  61,8B
0C62:  MOVFF  60,8A
0C66:  MOVFF  5F,89
0C6A:  MOVFF  5E,88
0C6E:  CLRF   x8F
0C70:  CLRF   x8E
0C72:  CLRF   x8D
0C74:  CLRF   x8C
0C76:  RCALL  0A4E
0C78:  BNC   0C80
0C7A:  MOVF   5F,W
0C7C:  XORLW  80
0C7E:  MOVWF  5F
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0C80:  MOVFF  61,8F
0C84:  MOVFF  60,8E
0C88:  MOVFF  5F,8D
0C8C:  MOVFF  5E,8C
0C90:  MOVLW  83
0C92:  MOVWF  x93
0C94:  MOVLW  F9
0C96:  MOVWF  x92
0C98:  MOVLW  22
0C9A:  MOVWF  x91
0C9C:  MOVLW  7E
0C9E:  MOVWF  x90
0CA0:  RCALL  0598
0CA2:  MOVFF  03,8B
0CA6:  MOVFF  02,8A
0CAA:  MOVFF  01,89
0CAE:  MOVFF  00,88
0CB2:  BRA    0BCE
0CB4:  MOVFF  01,6E
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0CB8:  MOVFF  61,8F
0CBC:  MOVFF  60,8E
0CC0:  MOVFF  5F,8D
0CC4:  MOVFF  5E,8C
0CC8:  MOVLW  83
0CCA:  MOVWF  x93
0CCC:  MOVLW  F9
0CCE:  MOVWF  x92
0CD0:  MOVLW  22
0CD2:  MOVWF  x91
0CD4:  MOVLW  7E
0CD6:  MOVWF  x90
0CD8:  RCALL  0598
0CDA:  MOVFF  03,8B
0CDE:  MOVFF  02,8A
0CE2:  MOVFF  01,89
0CE6:  MOVFF  00,88
0CEA:  CLRF   x8D
0CEC:  MOVFF  6E,8C
0CF0:  RCALL  0562
0CF2:  BSF    FD8.1
0CF4:  MOVFF  8B,8F
0CF8:  MOVFF  8A,8E
0CFC:  MOVFF  89,8D
0D00:  MOVFF  88,8C
0D04:  MOVFF  03,93
0D08:  MOVFF  02,92
0D0C:  MOVFF  01,91
0D10:  MOVFF  00,90
0D14:  RCALL  07E4
0D16:  MOVFF  03,73
0D1A:  MOVFF  02,72
0D1E:  MOVFF  01,71
0D22:  MOVFF  00,70
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0D26:  MOVLW  03
0D28:  ANDWF  x6E,F
....................  
....................    if (quad == 0 || quad == 2) 
0D2A:  MOVF   x6E,F
0D2C:  BZ    0D34
0D2E:  MOVF   x6E,W
0D30:  SUBLW  02
0D32:  BNZ   0D68
....................       t = frac * PI_DIV_BY_TWO; 
0D34:  MOVFF  73,8F
0D38:  MOVFF  72,8E
0D3C:  MOVFF  71,8D
0D40:  MOVFF  70,8C
0D44:  MOVLW  DB
0D46:  MOVWF  x93
0D48:  MOVLW  0F
0D4A:  MOVWF  x92
0D4C:  MOVLW  49
0D4E:  MOVWF  x91
0D50:  MOVLW  7F
0D52:  MOVWF  x90
0D54:  RCALL  0598
0D56:  MOVFF  03,69
0D5A:  MOVFF  02,68
0D5E:  MOVFF  01,67
0D62:  MOVFF  00,66
0D66:  BRA    0E32
....................    else if (quad == 1) 
0D68:  DECFSZ x6E,W
0D6A:  BRA    0DD0
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0D6C:  BSF    FD8.1
0D6E:  CLRF   x8F
0D70:  CLRF   x8E
0D72:  CLRF   x8D
0D74:  MOVLW  7F
0D76:  MOVWF  x8C
0D78:  MOVFF  73,93
0D7C:  MOVFF  72,92
0D80:  MOVFF  71,91
0D84:  MOVFF  70,90
0D88:  RCALL  07E4
0D8A:  MOVFF  03,8B
0D8E:  MOVFF  02,8A
0D92:  MOVFF  01,89
0D96:  MOVFF  00,88
0D9A:  MOVFF  03,8F
0D9E:  MOVFF  02,8E
0DA2:  MOVFF  01,8D
0DA6:  MOVFF  00,8C
0DAA:  MOVLW  DB
0DAC:  MOVWF  x93
0DAE:  MOVLW  0F
0DB0:  MOVWF  x92
0DB2:  MOVLW  49
0DB4:  MOVWF  x91
0DB6:  MOVLW  7F
0DB8:  MOVWF  x90
0DBA:  CALL   0598
0DBE:  MOVFF  03,69
0DC2:  MOVFF  02,68
0DC6:  MOVFF  01,67
0DCA:  MOVFF  00,66
0DCE:  BRA    0E32
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0DD0:  BSF    FD8.1
0DD2:  MOVFF  73,8F
0DD6:  MOVFF  72,8E
0DDA:  MOVFF  71,8D
0DDE:  MOVFF  70,8C
0DE2:  CLRF   x93
0DE4:  CLRF   x92
0DE6:  CLRF   x91
0DE8:  MOVLW  7F
0DEA:  MOVWF  x90
0DEC:  RCALL  07E4
0DEE:  MOVFF  03,8B
0DF2:  MOVFF  02,8A
0DF6:  MOVFF  01,89
0DFA:  MOVFF  00,88
0DFE:  MOVFF  03,8F
0E02:  MOVFF  02,8E
0E06:  MOVFF  01,8D
0E0A:  MOVFF  00,8C
0E0E:  MOVLW  DB
0E10:  MOVWF  x93
0E12:  MOVLW  0F
0E14:  MOVWF  x92
0E16:  MOVLW  49
0E18:  MOVWF  x91
0E1A:  MOVLW  7F
0E1C:  MOVWF  x90
0E1E:  CALL   0598
0E22:  MOVFF  03,69
0E26:  MOVFF  02,68
0E2A:  MOVFF  01,67
0E2E:  MOVFF  00,66
....................  
....................    y = 1.0; 
0E32:  CLRF   x65
0E34:  CLRF   x64
0E36:  CLRF   x63
0E38:  MOVLW  7F
0E3A:  MOVWF  x62
....................    t = t * t; 
0E3C:  MOVFF  69,8F
0E40:  MOVFF  68,8E
0E44:  MOVFF  67,8D
0E48:  MOVFF  66,8C
0E4C:  MOVFF  69,93
0E50:  MOVFF  68,92
0E54:  MOVFF  67,91
0E58:  MOVFF  66,90
0E5C:  CALL   0598
0E60:  MOVFF  03,69
0E64:  MOVFF  02,68
0E68:  MOVFF  01,67
0E6C:  MOVFF  00,66
....................    for (i = 0; i <= 4; i++) 
0E70:  CLRF   x6F
0E72:  MOVF   x6F,W
0E74:  SUBLW  04
0E76:  BNC   0F2A
....................    { 
....................       t2 = t2 * t; 
0E78:  MOVFF  6D,8F
0E7C:  MOVFF  6C,8E
0E80:  MOVFF  6B,8D
0E84:  MOVFF  6A,8C
0E88:  MOVFF  69,93
0E8C:  MOVFF  68,92
0E90:  MOVFF  67,91
0E94:  MOVFF  66,90
0E98:  CALL   0598
0E9C:  MOVFF  03,6D
0EA0:  MOVFF  02,6C
0EA4:  MOVFF  01,6B
0EA8:  MOVFF  00,6A
....................       y = y + p[i] * t2; 
0EAC:  MOVF   x6F,W
0EAE:  MULLW  04
0EB0:  MOVF   FF3,W
0EB2:  CLRF   03
0EB4:  ADDLW  74
0EB6:  MOVWF  FE9
0EB8:  MOVLW  00
0EBA:  ADDWFC 03,W
0EBC:  MOVWF  FEA
0EBE:  MOVFF  FEF,8C
0EC2:  MOVFF  FEC,8D
0EC6:  MOVFF  FEC,8E
0ECA:  MOVFF  FEC,8F
0ECE:  MOVFF  6D,93
0ED2:  MOVFF  6C,92
0ED6:  MOVFF  6B,91
0EDA:  MOVFF  6A,90
0EDE:  CALL   0598
0EE2:  MOVFF  FEA,89
0EE6:  MOVFF  FE9,88
0EEA:  BCF    FD8.1
0EEC:  MOVFF  65,8F
0EF0:  MOVFF  64,8E
0EF4:  MOVFF  63,8D
0EF8:  MOVFF  62,8C
0EFC:  MOVFF  03,93
0F00:  MOVFF  02,92
0F04:  MOVFF  01,91
0F08:  MOVFF  00,90
0F0C:  RCALL  07E4
0F0E:  MOVFF  89,FEA
0F12:  MOVFF  88,FE9
0F16:  MOVFF  03,65
0F1A:  MOVFF  02,64
0F1E:  MOVFF  01,63
0F22:  MOVFF  00,62
0F26:  INCF   x6F,F
0F28:  BRA    0E72
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
0F2A:  MOVF   x6E,W
0F2C:  SUBLW  02
0F2E:  BZ    0F34
0F30:  DECFSZ x6E,W
0F32:  BRA    0F3A
....................       y = -y;  // correct sign 
0F34:  MOVF   x63,W
0F36:  XORLW  80
0F38:  MOVWF  x63
....................  
....................    return (y); 
0F3A:  MOVFF  62,00
0F3E:  MOVFF  63,01
0F42:  MOVFF  64,02
0F46:  MOVFF  65,03
0F4A:  GOTO   15CA (RETURN)
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
*
0178:  BSF    F95.6
017A:  MOVLW  11
017C:  MOVWF  00
017E:  DECFSZ 00,F
0180:  BRA    017E
0182:  BSF    F95.7
0184:  MOVLW  11
0186:  MOVWF  00
0188:  DECFSZ 00,F
018A:  BRA    0188
018C:  BCF    F8C.6
018E:  BCF    F95.6
0190:  MOVLW  11
0192:  MOVWF  00
0194:  DECFSZ 00,F
0196:  BRA    0194
0198:  BCF    F8C.7
019A:  BCF    F95.7
....................         delay_us(20); 
019C:  MOVLW  4F
019E:  MOVWF  00
01A0:  DECFSZ 00,F
01A2:  BRA    01A0
01A4:  BRA    01A6
....................         i2c_write(LCD_ADDR); //the slave addresse 
01A6:  MOVLW  4E
01A8:  MOVWF  x71
01AA:  RCALL  010C
....................         delay_us(20); 
01AC:  MOVLW  4F
01AE:  MOVWF  00
01B0:  DECFSZ 00,F
01B2:  BRA    01B0
01B4:  BRA    01B6
....................         i2c_write(data); 
01B6:  MOVFF  70,71
01BA:  RCALL  010C
....................         delay_us(20); 
01BC:  MOVLW  4F
01BE:  MOVWF  00
01C0:  DECFSZ 00,F
01C2:  BRA    01C0
01C4:  BRA    01C6
....................         i2c_stop(); 
01C6:  BCF    F95.6
01C8:  NOP   
01CA:  BSF    F95.7
01CC:  BTFSS  F83.7
01CE:  BRA    01CC
01D0:  MOVLW  11
01D2:  MOVWF  00
01D4:  DECFSZ 00,F
01D6:  BRA    01D4
01D8:  BRA    01DA
01DA:  NOP   
01DC:  BSF    F95.6
01DE:  MOVLW  11
01E0:  MOVWF  00
01E2:  DECFSZ 00,F
01E4:  BRA    01E2
....................         delay_us(20); 
01E6:  MOVLW  4F
01E8:  MOVWF  00
01EA:  DECFSZ 00,F
01EC:  BRA    01EA
01EE:  BRA    01F0
01F0:  RETURN 0
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
01F2:  BTFSS  20.0
01F4:  BRA    0200
01F6:  MOVF   x6F,W
01F8:  IORLW  04
01FA:  IORLW  08
01FC:  MOVWF  x6F
01FE:  BRA    0202
0200:  BSF    x6F.2
....................         i2c_send_nibble(data); 
0202:  MOVFF  6F,70
0206:  RCALL  0178
....................         data=data-4;       //toggle EN back to 0 
0208:  MOVLW  04
020A:  SUBWF  x6F,F
....................         i2c_send_nibble(data); 
020C:  MOVFF  6F,70
0210:  RCALL  0178
0212:  RETURN 0
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
0214:  CLRF   x6F
0216:  RCALL  01F2
....................     lcd_send_byte(0x10); 
0218:  MOVLW  10
021A:  MOVWF  x6F
021C:  RCALL  01F2
....................     delay_ms(2); 
021E:  MOVLW  02
0220:  MOVWF  x6D
0222:  RCALL  00E4
0224:  RETURN 0
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
0226:  MOVLW  C8
0228:  MOVWF  x6D
022A:  RCALL  00E4
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
022C:  CLRF   x6F
022E:  RCALL  01F2
....................         lcd_send_byte(0x10); 
0230:  MOVLW  10
0232:  MOVWF  x6F
0234:  RCALL  01F2
....................         lcd_send_byte(0x00); 
0236:  CLRF   x6F
0238:  RCALL  01F2
....................         lcd_send_byte(0x00); 
023A:  CLRF   x6F
023C:  RCALL  01F2
....................         lcd_send_byte(0x10); 
023E:  MOVLW  10
0240:  MOVWF  x6F
0242:  RCALL  01F2
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
0244:  MOVLW  30
0246:  MOVWF  x6F
0248:  RCALL  01F2
....................         lcd_send_byte(0x30); 
024A:  MOVLW  30
024C:  MOVWF  x6F
024E:  RCALL  01F2
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
0250:  MOVLW  30
0252:  MOVWF  x6F
0254:  RCALL  01F2
....................         lcd_send_byte(0x20); 
0256:  MOVLW  20
0258:  MOVWF  x6F
025A:  RCALL  01F2
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
025C:  MOVLW  20
025E:  MOVWF  x6F
0260:  RCALL  01F2
....................         lcd_send_byte(0x80); 
0262:  MOVLW  80
0264:  MOVWF  x6F
0266:  RCALL  01F2
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
0268:  CLRF   x6F
026A:  RCALL  01F2
....................         lcd_send_byte(0xC0); 
026C:  MOVLW  C0
026E:  MOVWF  x6F
0270:  RCALL  01F2
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
0272:  CLRF   x6F
0274:  RCALL  01F2
....................         lcd_send_byte(0x60); 
0276:  MOVLW  60
0278:  MOVWF  x6F
027A:  RCALL  01F2
....................            //clears the display 
....................         lcd_clear(); 
027C:  RCALL  0214
027E:  GOTO   0380 (RETURN)
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
0282:  MOVF   x6E,W
0284:  XORLW  01
0286:  BZ    0296
0288:  XORLW  03
028A:  BZ    029C
028C:  XORLW  01
028E:  BZ    02A2
0290:  XORLW  07
0292:  BZ    02A8
0294:  BRA    02AE
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
0296:  MOVLW  80
0298:  MOVWF  1F
029A:  BRA    02B2
....................       case 2:  address= lcd_line_two;     break; 
029C:  MOVLW  C0
029E:  MOVWF  1F
02A0:  BRA    02B2
....................       case 3:  address= lcd_line_three;   break; 
02A2:  MOVLW  94
02A4:  MOVWF  1F
02A6:  BRA    02B2
....................       case 4:  address= lcd_line_four;    break; 
02A8:  MOVLW  D4
02AA:  MOVWF  1F
02AC:  BRA    02B2
....................       default: address= lcd_line_one;     break;  
02AE:  MOVLW  80
02B0:  MOVWF  1F
....................    } 
....................   
....................    address+=x-1; 
02B2:  MOVLW  01
02B4:  SUBWF  x6D,W
02B6:  ADDWF  1F,F
....................    data=address&0xF0; 
02B8:  MOVF   1F,W
02BA:  ANDLW  F0
02BC:  MOVWF  26
....................    lcd_send_byte(data); 
02BE:  MOVFF  26,6F
02C2:  RCALL  01F2
....................    data=address&0x0F; 
02C4:  MOVF   1F,W
02C6:  ANDLW  0F
02C8:  MOVWF  26
....................    data=data<<4; 
02CA:  SWAPF  26,F
02CC:  MOVLW  F0
02CE:  ANDWF  26,F
....................    lcd_send_byte(data); 
02D0:  MOVFF  26,6F
02D4:  RCALL  01F2
02D6:  RETURN 0
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
02D8:  MOVF   x6C,W
02DA:  XORLW  0C
02DC:  BZ    02F0
02DE:  XORLW  0D
02E0:  BZ    02F4
02E2:  XORLW  03
02E4:  BZ    02FE
02E6:  XORLW  01
02E8:  BZ    030A
02EA:  XORLW  07
02EC:  BZ    0316
02EE:  BRA    0322
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
02F0:  RCALL  0214
02F2:  BRA    0344
....................      case '\1': lcd_gotoxy(1,1);  break; 
02F4:  MOVLW  01
02F6:  MOVWF  x6D
02F8:  MOVWF  x6E
02FA:  RCALL  0282
02FC:  BRA    0344
....................      case '\2': lcd_gotoxy(1,2);  break; 
02FE:  MOVLW  01
0300:  MOVWF  x6D
0302:  MOVLW  02
0304:  MOVWF  x6E
0306:  RCALL  0282
0308:  BRA    0344
....................      case '\3': lcd_gotoxy(1,3);  break; 
030A:  MOVLW  01
030C:  MOVWF  x6D
030E:  MOVLW  03
0310:  MOVWF  x6E
0312:  RCALL  0282
0314:  BRA    0344
....................      case '\4': lcd_gotoxy(1,4);  break; 
0316:  MOVLW  01
0318:  MOVWF  x6D
031A:  MOVLW  04
031C:  MOVWF  x6E
031E:  RCALL  0282
0320:  BRA    0344
....................  
....................      default: 
....................         data=in_data&0xF0; 
0322:  MOVF   x6C,W
0324:  ANDLW  F0
0326:  MOVWF  x6D
....................         data=data|RS; //set RS pin to 1 
0328:  BSF    x6D.0
....................         lcd_send_byte(data); 
032A:  MOVFF  6D,6F
032E:  RCALL  01F2
....................         data=in_data&0x0F; 
0330:  MOVF   x6C,W
0332:  ANDLW  0F
0334:  MOVWF  x6D
....................         data=data<<4; 
0336:  SWAPF  x6D,F
0338:  MOVLW  F0
033A:  ANDWF  x6D,F
....................         data=data|RS; //set RS pin to 1 
033C:  BSF    x6D.0
....................         lcd_send_byte(data); 
033E:  MOVFF  6D,6F
0342:  RCALL  01F2
....................      break; 
....................    } 
0344:  RETURN 0
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #include <Control_ADCs.h> 
.................... /*  
....................  * File:   MAX191.h 
....................  * Author: MARCOS 
....................  * 
....................  * Created on 23 de septiembre de 2016, 08:14 
....................  */ 
....................  
.................... #ifndef Control_ADCs_H 
.................... #define Control_ADCs_H 
....................  
.................... #define ADC_CSCorriente PIN_A0  // salida 
.................... #define ADC_CSTension PIN_A1 // salida 
.................... #define ADC_SCLK PIN_A2 // salida clock tension 
.................... #define ADC_SCLKcorr PIN_B1 
.................... #define ADC_DOUT PIN_B0  // entrada, por aqui ingresa la info del MAX186 
.................... #define ADC_DIN PIN_A4 //salida, se envia la informacion al MAX186 
.................... #define ADC_SSTRB PIN_A5//entrada 
.................... #define ADC_SDATA PIN_A3//entrada SDATA en AD7450 
....................  
.................... //control AD7450 
.................... signed long leer_Tension(){ 
*
03A2:  CLRF   5F
03A4:  CLRF   5E
....................     signed long dato=0,dato_t; 
....................     int i; 
....................     output_low (ADC_CSTension); 
03A6:  BCF    F92.1
03A8:  BCF    F89.1
....................     delay_us(1); 
03AA:  MOVLW  03
03AC:  MOVWF  00
03AE:  DECFSZ 00,F
03B0:  BRA    03AE
03B2:  BRA    03B4
....................     output_low (ADC_SCLK); 
03B4:  BCF    F92.2
03B6:  BCF    F89.2
....................     delay_us(1); 
03B8:  MOVLW  03
03BA:  MOVWF  00
03BC:  DECFSZ 00,F
03BE:  BRA    03BC
03C0:  BRA    03C2
....................     output_high (ADC_SCLK); 
03C2:  BCF    F92.2
03C4:  BSF    F89.2
....................     delay_us(1); 
03C6:  MOVLW  03
03C8:  MOVWF  00
03CA:  DECFSZ 00,F
03CC:  BRA    03CA
03CE:  BRA    03D0
....................      
....................         for(i=0;i<15;i++){ 
03D0:  CLRF   x62
03D2:  MOVF   x62,W
03D4:  SUBLW  0E
03D6:  BNC   0408
....................           shift_left(&dato,2,input(ADC_SDATA)); 
03D8:  BSF    F92.3
03DA:  BTFSC  F80.3
03DC:  BRA    03E2
03DE:  BCF    FD8.0
03E0:  BRA    03E4
03E2:  BSF    FD8.0
03E4:  RLCF   5E,F
03E6:  RLCF   5F,F
....................           output_low(ADC_SCLK); 
03E8:  BCF    F92.2
03EA:  BCF    F89.2
....................           delay_us(1);  
03EC:  MOVLW  03
03EE:  MOVWF  00
03F0:  DECFSZ 00,F
03F2:  BRA    03F0
03F4:  BRA    03F6
....................           output_high(ADC_SCLK);  
03F6:  BCF    F92.2
03F8:  BSF    F89.2
....................           delay_us(1); 
03FA:  MOVLW  03
03FC:  MOVWF  00
03FE:  DECFSZ 00,F
0400:  BRA    03FE
0402:  BRA    0404
0404:  INCF   x62,F
0406:  BRA    03D2
....................         } 
....................  
....................        // output_high (ADC_SCLK); 
....................        // delay_us(1); 
....................         output_high (ADC_CSTension); 
0408:  BCF    F92.1
040A:  BSF    F89.1
....................          
....................        dato_t=(dato&0x0800); 
040C:  CLRF   x60
040E:  MOVF   5F,W
0410:  ANDLW  08
0412:  MOVWF  x61
....................          
....................       if (dato_t==0x0800){ 
0414:  MOVF   x60,F
0416:  BNZ   0432
0418:  MOVF   x61,W
041A:  SUBLW  08
041C:  BNZ   0432
....................             dato=-2048+(dato&0xF7FF); 
041E:  MOVFF  5E,00
0422:  MOVF   5F,W
0424:  ANDLW  F7
0426:  MOVWF  03
0428:  MOVFF  5E,5E
042C:  MOVLW  F8
042E:  ADDWF  03,W
0430:  MOVWF  5F
....................       } 
....................     return(dato); 
0432:  MOVFF  5E,01
0436:  MOVFF  5F,02
043A:  GOTO   11E0 (RETURN)
.................... } 
....................  
.................... //control MAX186 
.................... long leer_Corriente(){ 
043E:  CLRF   5F
0440:  CLRF   5E
0442:  MOVLW  8E
0444:  MOVWF  x60
....................     long dato=0; 
....................     BYTE config= 0b10001110; 
....................     int i; 
....................     output_low (ADC_CSCorriente); 
0446:  BCF    F92.0
0448:  BCF    F89.0
....................     output_low (ADC_DIN); 
044A:  BCF    F92.4
044C:  BCF    F89.4
....................     delay_us(1); 
044E:  MOVLW  03
0450:  MOVWF  00
0452:  DECFSZ 00,F
0454:  BRA    0452
0456:  BRA    0458
....................      
....................     for(i=0; i<8; i++) { 
0458:  CLRF   x61
045A:  MOVF   x61,W
045C:  SUBLW  07
045E:  BNC   048E
....................       output_bit(ADC_DIN, shift_left(&config,1,0)); 
0460:  BCF    FD8.0
0462:  RLCF   x60,F
0464:  BC    046A
0466:  BCF    F89.4
0468:  BRA    046C
046A:  BSF    F89.4
046C:  BCF    F92.4
....................       output_high(ADC_SCLKcorr); 
046E:  BCF    F93.1
0470:  BSF    F8A.1
....................       delay_us(1); 
0472:  MOVLW  03
0474:  MOVWF  00
0476:  DECFSZ 00,F
0478:  BRA    0476
047A:  BRA    047C
....................       output_low(ADC_SCLKcorr);	 
047C:  BCF    F93.1
047E:  BCF    F8A.1
....................       delay_us(1); 
0480:  MOVLW  03
0482:  MOVWF  00
0484:  DECFSZ 00,F
0486:  BRA    0484
0488:  BRA    048A
048A:  INCF   x61,F
048C:  BRA    045A
....................    } 
....................  
....................     output_high(ADC_CSCorriente); 
048E:  BCF    F92.0
0490:  BSF    F89.0
....................      
....................     while(input(ADC_SSTRB)=='0');    
....................          
....................         output_low (ADC_CSCorriente); 
0492:  BCF    F92.0
0494:  BCF    F89.0
....................         output_high (ADC_SCLKcorr); 
0496:  BCF    F93.1
0498:  BSF    F8A.1
....................         delay_us(1); 
049A:  MOVLW  03
049C:  MOVWF  00
049E:  DECFSZ 00,F
04A0:  BRA    049E
04A2:  BRA    04A4
....................         output_low (ADC_SCLKcorr); 
04A4:  BCF    F93.1
04A6:  BCF    F8A.1
....................         delay_us(1); 
04A8:  MOVLW  03
04AA:  MOVWF  00
04AC:  DECFSZ 00,F
04AE:  BRA    04AC
04B0:  BRA    04B2
....................          
....................         for(i=0;i<15;i++){ 
04B2:  CLRF   x61
04B4:  MOVF   x61,W
04B6:  SUBLW  0E
04B8:  BNC   04EA
....................           output_high(ADC_SCLKcorr); 
04BA:  BCF    F93.1
04BC:  BSF    F8A.1
....................           delay_us(1); 
04BE:  MOVLW  03
04C0:  MOVWF  00
04C2:  DECFSZ 00,F
04C4:  BRA    04C2
04C6:  BRA    04C8
....................           shift_left(&dato,2,input(ADC_DOUT));  
04C8:  BSF    F93.0
04CA:  BTFSC  F81.0
04CC:  BRA    04D2
04CE:  BCF    FD8.0
04D0:  BRA    04D4
04D2:  BSF    FD8.0
04D4:  RLCF   5E,F
04D6:  RLCF   5F,F
....................           output_low(ADC_SCLKcorr); 
04D8:  BCF    F93.1
04DA:  BCF    F8A.1
....................           delay_us(1); 
04DC:  MOVLW  03
04DE:  MOVWF  00
04E0:  DECFSZ 00,F
04E2:  BRA    04E0
04E4:  BRA    04E6
04E6:  INCF   x61,F
04E8:  BRA    04B4
....................         } 
....................   
....................          
....................         output_high (ADC_CSCorriente); 
04EA:  BCF    F92.0
04EC:  BSF    F89.0
....................      
....................        
....................     dato= (dato>>3)& 0x0FFF; 
04EE:  RRCF   5F,W
04F0:  MOVWF  x63
04F2:  RRCF   5E,W
04F4:  MOVWF  x62
04F6:  RRCF   x63,F
04F8:  RRCF   x62,F
04FA:  RRCF   x63,F
04FC:  RRCF   x62,F
04FE:  MOVLW  1F
0500:  ANDWF  x63,F
0502:  MOVFF  62,5E
0506:  MOVF   x63,W
0508:  ANDLW  0F
050A:  MOVWF  5F
....................     return(dato); 
050C:  MOVFF  5E,01
0510:  MOVFF  5F,02
0514:  GOTO   11EC (RETURN)
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //Implementacion Switch-Case 
....................  
.................... /** 
.................... *	\fn void maquina_estado() 
.................... *	\brief Implementacion Switch-Case 
.................... *	\details  
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
....................  **/ 
.................... signed long punto1; 
.................... long punto2; 
.................... int16 tiempo_potencia; 
.................... BYTE pos_V,pos_I,pos_V_A,pos_I_A; 
.................... int control_V; 
.................... int control_I; 
.................... int desfase; 
.................... int puntos=20;//puntos por periodo 
.................... float tension, corriente, tension_RMS,corriente_RMS, t_desfase, potencia_ins,angulo; 
.................... float Energia_Wms=0, Energia_Wh=0, Energia_kWh=0; 
....................  
.................... const long carga= 0xE8AB; 
....................  
.................... #INT_TIMER1               // interrupcion para demora de 1 ms 
.................... void interrtimer_1(){ 
....................     set_timer1(carga);   // interrupcion cada 1 ms 
*
00BC:  MOVLW  E8
00BE:  MOVWF  FCF
00C0:  MOVLW  AB
00C2:  MOVWF  FCE
....................     pulso_timer++; 
00C4:  INCF   25,F
....................  
00C6:  BCF    F9E.0
00C8:  GOTO   0060
....................    } 
....................  
.................... void maquina_estado() 
.................... { 
.................... 		static int estado = PUNTO_TENS_CORR; 
....................  
.................... 		switch(estado) 
*
11BE:  MOVF   5D,W
11C0:  XORLW  00
11C2:  BZ    11DC
11C4:  XORLW  01
11C6:  BZ    1234
11C8:  XORLW  03
11CA:  BTFSC  FD8.2
11CC:  BRA    13AE
11CE:  XORLW  01
11D0:  BTFSC  FD8.2
11D2:  BRA    1480
11D4:  XORLW  07
11D6:  BTFSC  FD8.2
11D8:  BRA    17BA
11DA:  BRA    18A4
.................... 		{ 
.................... 			case PUNTO_TENS_CORR: 
....................                 punto1= leer_Tension(); 
11DC:  GOTO   03A2
11E0:  MOVFF  02,28
11E4:  MOVFF  01,27
....................                 punto2= leer_Corriente(); // comprobar si funciona con el tiempo de demora de la lectura del externo 
11E8:  GOTO   043E
11EC:  MOVFF  02,2A
11F0:  MOVFF  01,29
....................                 // convierte los valores de long a float 
....................                 tension=punto1; 
11F4:  MOVFF  28,5F
11F8:  MOVFF  27,5E
11FC:  GOTO   0518
1200:  MOVFF  03,38
1204:  MOVFF  02,37
1208:  MOVFF  01,36
120C:  MOVFF  00,35
....................                 corriente=punto2; 
1210:  MOVFF  2A,8D
1214:  MOVFF  29,8C
1218:  CALL   0562
121C:  MOVFF  03,3C
1220:  MOVFF  02,3B
1224:  MOVFF  01,3A
1228:  MOVFF  00,39
....................                 contador++; 
122C:  INCF   22,F
.................... 					estado = CONVERSION_DESFASE; 
122E:  MOVLW  01
1230:  MOVWF  5D
....................  
.................... 				break; 
1232:  BRA    18A6
.................... 			 
.................... 			case CONVERSION_DESFASE: 
....................                 tension= (tension)*2.5/2048; 
1234:  MOVFF  38,8F
1238:  MOVFF  37,8E
123C:  MOVFF  36,8D
1240:  MOVFF  35,8C
1244:  CLRF   x93
1246:  CLRF   x92
1248:  MOVLW  20
124A:  MOVWF  x91
124C:  MOVLW  80
124E:  MOVWF  x90
1250:  CALL   0598
1254:  MOVFF  03,61
1258:  MOVFF  02,60
125C:  MOVFF  01,5F
1260:  MOVFF  00,5E
1264:  MOVFF  03,73
1268:  MOVFF  02,72
126C:  MOVFF  01,71
1270:  MOVFF  00,70
1274:  CLRF   x77
1276:  CLRF   x76
1278:  CLRF   x75
127A:  MOVLW  8A
127C:  MOVWF  x74
127E:  CALL   068A
1282:  MOVFF  03,38
1286:  MOVFF  02,37
128A:  MOVFF  01,36
128E:  MOVFF  00,35
....................                 corriente= (corriente)/1000-2.510; 
1292:  MOVFF  3C,73
1296:  MOVFF  3B,72
129A:  MOVFF  3A,71
129E:  MOVFF  39,70
12A2:  CLRF   x77
12A4:  CLRF   x76
12A6:  MOVLW  7A
12A8:  MOVWF  x75
12AA:  MOVLW  88
12AC:  MOVWF  x74
12AE:  CALL   068A
12B2:  MOVFF  03,61
12B6:  MOVFF  02,60
12BA:  MOVFF  01,5F
12BE:  MOVFF  00,5E
12C2:  BSF    FD8.1
12C4:  MOVFF  03,8F
12C8:  MOVFF  02,8E
12CC:  MOVFF  01,8D
12D0:  MOVFF  00,8C
12D4:  MOVLW  D7
12D6:  MOVWF  x93
12D8:  MOVLW  A3
12DA:  MOVWF  x92
12DC:  MOVLW  20
12DE:  MOVWF  x91
12E0:  MOVLW  80
12E2:  MOVWF  x90
12E4:  CALL   07E4
12E8:  MOVFF  03,3C
12EC:  MOVFF  02,3B
12F0:  MOVFF  01,3A
12F4:  MOVFF  00,39
....................                 //se convierte a la tension y corriente real 
....................                 tension= tension*155.57; // conversion con 2 V igual a 311.13 V 
12F8:  MOVFF  38,8F
12FC:  MOVFF  37,8E
1300:  MOVFF  36,8D
1304:  MOVFF  35,8C
1308:  MOVLW  EC
130A:  MOVWF  x93
130C:  MOVLW  91
130E:  MOVWF  x92
1310:  MOVLW  1B
1312:  MOVWF  x91
1314:  MOVLW  86
1316:  MOVWF  x90
1318:  CALL   0598
131C:  MOVFF  03,38
1320:  MOVFF  02,37
1324:  MOVFF  01,36
1328:  MOVFF  00,35
....................                 corriente= corriente*12; // 2.5 V es igual a +30 A (recordar que el sensor mide 30A) 
132C:  MOVFF  3C,8F
1330:  MOVFF  3B,8E
1334:  MOVFF  3A,8D
1338:  MOVFF  39,8C
133C:  CLRF   x93
133E:  CLRF   x92
1340:  MOVLW  40
1342:  MOVWF  x91
1344:  MOVLW  82
1346:  MOVWF  x90
1348:  CALL   0598
134C:  MOVFF  03,3C
1350:  MOVFF  02,3B
1354:  MOVFF  01,3A
1358:  MOVFF  00,39
....................                  
....................                 // Analisis del punto POSITVO O NEGATIVO 
....................                 // valor positivo estado=0-- valor negativo estado=1 
....................                  
....................                 //TENSION 
....................                 #asm 
....................                 clrf &pos_V; 
135C:  CLRF   2D
....................                 btfsc (&tension + 0x01), 7; 
135E:  BTFSC  36.7
....................                 bsf &pos_V,0; 
1360:  BSF    2D.0
....................                 #endasm 
.................... 				 
....................                 //CORRIENTE 
....................                 #asm 
....................                 clrf &pos_I; 
1362:  CLRF   2E
....................                 btfsc (&corriente + 0x01), 7; // comprueba signo en un bit de los 4 byte del float 
1364:  BTFSC  3A.7
....................                 bsf &pos_I,0; 
1366:  BSF    2E.0
....................                 #endasm 
....................  
....................                  
....................                  
.................... 				 
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contador distinto de cero) 
....................                 if (pos_V==1 && contador>=2 && pos_V_A==0 && desfase!=1){  
1368:  DECFSZ 2D,W
136A:  BRA    1384
136C:  MOVF   22,W
136E:  SUBLW  01
1370:  BC    1384
1372:  MOVF   2F,F
1374:  BNZ   1384
1376:  DECFSZ 33,W
1378:  BRA    137C
137A:  BRA    1384
....................                  control_V= contador; // tiempo en el que cruz la tension  
137C:  MOVFF  22,31
....................                  desfase=1; 
1380:  MOVLW  01
1382:  MOVWF  33
....................                 } 
....................                  
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_I==1 && contador>=2 && pos_I_A==0 && desfase!=2){ 
1384:  DECFSZ 2E,W
1386:  BRA    13A0
1388:  MOVF   22,W
138A:  SUBLW  01
138C:  BC    13A0
138E:  MOVF   30,F
1390:  BNZ   13A0
1392:  MOVF   33,W
1394:  SUBLW  02
1396:  BZ    13A0
....................                      
....................                  control_I= contador; // tiempo en el que cruz la corriente 
1398:  MOVFF  22,32
....................                  desfase=2; 
139C:  MOVLW  02
139E:  MOVWF  33
....................                 } 
....................                 // guarda el signo de los puntos anteriores 
....................                 pos_V_A=pos_V; 
13A0:  MOVFF  2D,2F
....................                 pos_I_A=pos_I; 
13A4:  MOVFF  2E,30
....................                  
....................                  
.................... 					estado = TENS_CORR_RMS; 
13A8:  MOVLW  02
13AA:  MOVWF  5D
.................... 		 
.................... 				 
....................  
.................... 				break; 
13AC:  BRA    18A6
.................... //---------------------------------------------------------------------------------------------------- 
....................                  
.................... 			case TENS_CORR_RMS: 
.................... 			 
.................... 				if((contador<30)&& (pulso_timer==1)) 
13AE:  MOVF   22,W
13B0:  SUBLW  1D
13B2:  BNC   147E
13B4:  DECFSZ 25,W
13B6:  BRA    147E
.................... 				{ 
.................... 					tension_RMS=tension_RMS+ tension * tension;       //calcula tension eficaz 
13B8:  MOVFF  38,8F
13BC:  MOVFF  37,8E
13C0:  MOVFF  36,8D
13C4:  MOVFF  35,8C
13C8:  MOVFF  38,93
13CC:  MOVFF  37,92
13D0:  MOVFF  36,91
13D4:  MOVFF  35,90
13D8:  CALL   0598
13DC:  BCF    FD8.1
13DE:  MOVFF  40,8F
13E2:  MOVFF  3F,8E
13E6:  MOVFF  3E,8D
13EA:  MOVFF  3D,8C
13EE:  MOVFF  03,93
13F2:  MOVFF  02,92
13F6:  MOVFF  01,91
13FA:  MOVFF  00,90
13FE:  CALL   07E4
1402:  MOVFF  03,40
1406:  MOVFF  02,3F
140A:  MOVFF  01,3E
140E:  MOVFF  00,3D
....................                     corriente_RMS= corriente_RMS+ corriente * corriente; // calcula corriente eficaz 
1412:  MOVFF  3C,8F
1416:  MOVFF  3B,8E
141A:  MOVFF  3A,8D
141E:  MOVFF  39,8C
1422:  MOVFF  3C,93
1426:  MOVFF  3B,92
142A:  MOVFF  3A,91
142E:  MOVFF  39,90
1432:  CALL   0598
1436:  BCF    FD8.1
1438:  MOVFF  44,8F
143C:  MOVFF  43,8E
1440:  MOVFF  42,8D
1444:  MOVFF  41,8C
1448:  MOVFF  03,93
144C:  MOVFF  02,92
1450:  MOVFF  01,91
1454:  MOVFF  00,90
1458:  CALL   07E4
145C:  MOVFF  03,44
1460:  MOVFF  02,43
1464:  MOVFF  01,42
1468:  MOVFF  00,41
....................                     pulso_timer=0; 
146C:  CLRF   25
....................                      
.................... 					estado = PUNTO_TENS_CORR; 
146E:  CLRF   5D
....................                      
....................                     if((contador== 29)){ 
1470:  MOVF   22,W
1472:  SUBLW  1D
1474:  BNZ   147E
.................... 					disable_interrupts(INT_TIMER1);// deshabilita la interrupcion para no entrar al timer 
1476:  BCF    F9D.0
....................                     contador=0; //se reinicia el contador, para comenzar nuevamente  
1478:  CLRF   22
.................... 					estado = CALCULO_POT_ENER; 
147A:  MOVLW  03
147C:  MOVWF  5D
.................... 				} 
.................... 				} 
.................... 				 
....................  
.................... 				break; 
147E:  BRA    18A6
....................                  
.................... //--------------------------------------------------------------------------------------------------------------------                 
.................... 			 
.................... 			case CALCULO_POT_ENER: // falta calculo de energia 
....................                 //calcula las raices para completar el calculo RMS 
.................... 				tension_RMS= sqrt(tension_RMS/30); 
1480:  MOVFF  40,73
1484:  MOVFF  3F,72
1488:  MOVFF  3E,71
148C:  MOVFF  3D,70
1490:  CLRF   x77
1492:  CLRF   x76
1494:  MOVLW  70
1496:  MOVWF  x75
1498:  MOVLW  83
149A:  MOVWF  x74
149C:  CALL   068A
14A0:  MOVFF  03,61
14A4:  MOVFF  02,60
14A8:  MOVFF  01,5F
14AC:  MOVFF  00,5E
14B0:  MOVFF  03,65
14B4:  MOVFF  02,64
14B8:  MOVFF  01,63
14BC:  MOVFF  00,62
14C0:  CALL   0AC4
14C4:  MOVFF  03,40
14C8:  MOVFF  02,3F
14CC:  MOVFF  01,3E
14D0:  MOVFF  00,3D
....................                 corriente_RMS= sqrt(corriente_RMS/30); 
14D4:  MOVFF  44,73
14D8:  MOVFF  43,72
14DC:  MOVFF  42,71
14E0:  MOVFF  41,70
14E4:  CLRF   x77
14E6:  CLRF   x76
14E8:  MOVLW  70
14EA:  MOVWF  x75
14EC:  MOVLW  83
14EE:  MOVWF  x74
14F0:  CALL   068A
14F4:  MOVFF  03,61
14F8:  MOVFF  02,60
14FC:  MOVFF  01,5F
1500:  MOVFF  00,5E
1504:  MOVFF  03,65
1508:  MOVFF  02,64
150C:  MOVFF  01,63
1510:  MOVFF  00,62
1514:  CALL   0AC4
1518:  MOVFF  03,44
151C:  MOVFF  02,43
1520:  MOVFF  01,42
1524:  MOVFF  00,41
....................                  
....................                 // se controla si se pudo calcular desfase en el estado anterior  
....................                 // se realiza las diferencia de cruce por cero y se convierte de tiempo a radianes 
....................                 angulo=0; 
1528:  CLRF   50
152A:  CLRF   4F
152C:  CLRF   4E
152E:  CLRF   4D
....................                 if (desfase==2){ 
1530:  MOVF   33,W
1532:  SUBLW  02
1534:  BNZ   15B6
....................                     t_desfase= (control_I-control_V); 
1536:  MOVF   31,W
1538:  SUBWF  32,W
153A:  CLRF   x8D
153C:  MOVWF  x8C
153E:  CALL   0562
1542:  MOVFF  03,48
1546:  MOVFF  02,47
154A:  MOVFF  01,46
154E:  MOVFF  00,45
....................                     angulo= (t_desfase*pi)/10;      // angulo de desfase en radianes. 20 puntos por periodo 
1552:  MOVFF  48,8F
1556:  MOVFF  47,8E
155A:  MOVFF  46,8D
155E:  MOVFF  45,8C
1562:  MOVLW  DB
1564:  MOVWF  x93
1566:  MOVLW  0F
1568:  MOVWF  x92
156A:  MOVLW  49
156C:  MOVWF  x91
156E:  MOVLW  80
1570:  MOVWF  x90
1572:  CALL   0598
1576:  MOVFF  03,61
157A:  MOVFF  02,60
157E:  MOVFF  01,5F
1582:  MOVFF  00,5E
1586:  MOVFF  03,73
158A:  MOVFF  02,72
158E:  MOVFF  01,71
1592:  MOVFF  00,70
1596:  CLRF   x77
1598:  CLRF   x76
159A:  MOVLW  20
159C:  MOVWF  x75
159E:  MOVLW  82
15A0:  MOVWF  x74
15A2:  CALL   068A
15A6:  MOVFF  03,50
15AA:  MOVFF  02,4F
15AE:  MOVFF  01,4E
15B2:  MOVFF  00,4D
....................                    /*  lcd_gotoxy(1,1); 
....................                      printf(LCD_PUTC,"desfase= %f       ",t_desfase); 
....................                      lcd_gotoxy(1,2); 
....................                      printf(LCD_PUTC,"angulo=%f        ",angulo); 
....................                      delay_ms(1000);*/ 
....................                 }                 
....................                  
....................                 angulo=cos(angulo); 
15B6:  MOVFF  50,61
15BA:  MOVFF  4F,60
15BE:  MOVFF  4E,5F
15C2:  MOVFF  4D,5E
15C6:  GOTO   0C08
15CA:  MOVFF  03,50
15CE:  MOVFF  02,4F
15D2:  MOVFF  01,4E
15D6:  MOVFF  00,4D
....................                // calculo de potencia  
....................                 potencia_ins= tension_RMS*corriente_RMS*angulo; 
15DA:  MOVFF  40,8F
15DE:  MOVFF  3F,8E
15E2:  MOVFF  3E,8D
15E6:  MOVFF  3D,8C
15EA:  MOVFF  44,93
15EE:  MOVFF  43,92
15F2:  MOVFF  42,91
15F6:  MOVFF  41,90
15FA:  CALL   0598
15FE:  MOVFF  03,61
1602:  MOVFF  02,60
1606:  MOVFF  01,5F
160A:  MOVFF  00,5E
160E:  MOVFF  03,8F
1612:  MOVFF  02,8E
1616:  MOVFF  01,8D
161A:  MOVFF  00,8C
161E:  MOVFF  50,93
1622:  MOVFF  4F,92
1626:  MOVFF  4E,91
162A:  MOVFF  4D,90
162E:  CALL   0598
1632:  MOVFF  03,4C
1636:  MOVFF  02,4B
163A:  MOVFF  01,4A
163E:  MOVFF  00,49
....................                 //se limpian las variables para la prxima etapa de muestreo 
....................                 control_V=0;       
1642:  CLRF   31
....................                 control_I=0; 
1644:  CLRF   32
....................                 angulo=0; 
1646:  CLRF   50
1648:  CLRF   4F
164A:  CLRF   4E
164C:  CLRF   4D
....................                 desfase=0;  
164E:  CLRF   33
....................                  
....................                 //Calculo de Energia 
....................                 tiempo_potencia=65536 - get_timer0();    //variable para calcular energia segun tiempo de potencia 
1650:  MOVF   FD6,W
1652:  XORLW  FF
1654:  ADDLW  01
1656:  MOVWF  2B
1658:  MOVLW  00
165A:  SUBFWB FD7,W
165C:  MOVWF  2C
....................                 Energia_Wms=Energia_Wms+potencia_ins*tiempo_potencia/37500000;             //Energia en Watt por milisegundo 
165E:  MOVFF  2C,8D
1662:  MOVFF  2B,8C
1666:  CALL   0562
166A:  MOVFF  4C,8F
166E:  MOVFF  4B,8E
1672:  MOVFF  4A,8D
1676:  MOVFF  49,8C
167A:  MOVFF  03,93
167E:  MOVFF  02,92
1682:  MOVFF  01,91
1686:  MOVFF  00,90
168A:  CALL   0598
168E:  MOVFF  03,61
1692:  MOVFF  02,60
1696:  MOVFF  01,5F
169A:  MOVFF  00,5E
169E:  MOVFF  03,73
16A2:  MOVFF  02,72
16A6:  MOVFF  01,71
16AA:  MOVFF  00,70
16AE:  MOVLW  18
16B0:  MOVWF  x77
16B2:  MOVLW  0D
16B4:  MOVWF  x76
16B6:  MOVLW  0F
16B8:  MOVWF  x75
16BA:  MOVLW  98
16BC:  MOVWF  x74
16BE:  CALL   068A
16C2:  BCF    FD8.1
16C4:  MOVFF  54,8F
16C8:  MOVFF  53,8E
16CC:  MOVFF  52,8D
16D0:  MOVFF  51,8C
16D4:  MOVFF  03,93
16D8:  MOVFF  02,92
16DC:  MOVFF  01,91
16E0:  MOVFF  00,90
16E4:  CALL   07E4
16E8:  MOVFF  03,54
16EC:  MOVFF  02,53
16F0:  MOVFF  01,52
16F4:  MOVFF  00,51
....................                  
....................                 if(Energia_Wms>=3600000){ 
16F8:  CLRF   x8B
16FA:  MOVLW  BA
16FC:  MOVWF  x8A
16FE:  MOVLW  5B
1700:  MOVWF  x89
1702:  MOVLW  94
1704:  MOVWF  x88
1706:  MOVFF  54,8F
170A:  MOVFF  53,8E
170E:  MOVFF  52,8D
1712:  MOVFF  51,8C
1716:  CALL   0A4E
171A:  BC    171E
171C:  BNZ   1756
....................                     Energia_Wh=Energia_Wh+1;  // rekacion watt ms a watt hora 
171E:  BCF    FD8.1
1720:  MOVFF  58,8F
1724:  MOVFF  57,8E
1728:  MOVFF  56,8D
172C:  MOVFF  55,8C
1730:  CLRF   x93
1732:  CLRF   x92
1734:  CLRF   x91
1736:  MOVLW  7F
1738:  MOVWF  x90
173A:  CALL   07E4
173E:  MOVFF  03,58
1742:  MOVFF  02,57
1746:  MOVFF  01,56
174A:  MOVFF  00,55
....................                     Energia_Wms=0;                 
174E:  CLRF   54
1750:  CLRF   53
1752:  CLRF   52
1754:  CLRF   51
....................                 } 
....................                  
....................                 if (Energia_Wh==1000){ 
1756:  MOVFF  58,8B
175A:  MOVFF  57,8A
175E:  MOVFF  56,89
1762:  MOVFF  55,88
1766:  CLRF   x8F
1768:  CLRF   x8E
176A:  MOVLW  7A
176C:  MOVWF  x8D
176E:  MOVLW  88
1770:  MOVWF  x8C
1772:  CALL   0A4E
1776:  BNZ   17B0
....................                     Energia_kWh=Energia_kWh+1; 
1778:  BCF    FD8.1
177A:  MOVFF  5C,8F
177E:  MOVFF  5B,8E
1782:  MOVFF  5A,8D
1786:  MOVFF  59,8C
178A:  CLRF   x93
178C:  CLRF   x92
178E:  CLRF   x91
1790:  MOVLW  7F
1792:  MOVWF  x90
1794:  CALL   07E4
1798:  MOVFF  03,5C
179C:  MOVFF  02,5B
17A0:  MOVFF  01,5A
17A4:  MOVFF  00,59
....................                     Energia_Wh=0; 
17A8:  CLRF   58
17AA:  CLRF   57
17AC:  CLRF   56
17AE:  CLRF   55
....................                 } 
....................                  
....................                  
....................                  
....................                 // Se reinicia timer 0 nuevamente, para volver a calcular energia 
....................                 set_timer0(0x0000); 
17B0:  CLRF   FD7
17B2:  CLRF   FD6
....................                  
.................... 					estado = MOSTRAR_DATOS; 
17B4:  MOVLW  04
17B6:  MOVWF  5D
.................... 				break; 
17B8:  BRA    18A6
....................                  
.................... //------------------------------------------------------------------------------------- 
....................                  
.................... 			case MOSTRAR_DATOS: 
....................                 //este estado solo muestra los datos en la pantalla LCD 
....................                 lcd_gotoxy(1,1); 
17BA:  MOVLW  01
17BC:  MOVWF  x6D
17BE:  MOVWF  x6E
17C0:  CALL   0282
....................                 printf(LCD_PUTC,"pot= \%f W",potencia_ins); 
17C4:  MOVLW  CC
17C6:  MOVWF  FF6
17C8:  MOVLW  00
17CA:  MOVWF  FF7
17CC:  MOVLW  05
17CE:  MOVWF  5E
17D0:  CALL   0F4E
17D4:  MOVLW  89
17D6:  MOVWF  FE9
17D8:  MOVFF  4C,61
17DC:  MOVFF  4B,60
17E0:  MOVFF  4A,5F
17E4:  MOVFF  49,5E
17E8:  MOVLW  02
17EA:  MOVWF  x62
17EC:  RCALL  103C
17EE:  MOVLW  20
17F0:  MOVWF  x6C
17F2:  CALL   02D8
17F6:  MOVLW  57
17F8:  MOVWF  x6C
17FA:  CALL   02D8
....................                 lcd_gotoxy(1,2); 
17FE:  MOVLW  01
1800:  MOVWF  x6D
1802:  MOVLW  02
1804:  MOVWF  x6E
1806:  CALL   0282
....................                 printf (LCD_PUTC, "T=\%f  I=\%f  ",tension_RMS,corriente_RMS); 
180A:  MOVLW  54
180C:  MOVWF  x6C
180E:  CALL   02D8
1812:  MOVLW  3D
1814:  MOVWF  x6C
1816:  CALL   02D8
181A:  MOVLW  89
181C:  MOVWF  FE9
181E:  MOVFF  40,61
1822:  MOVFF  3F,60
1826:  MOVFF  3E,5F
182A:  MOVFF  3D,5E
182E:  MOVLW  02
1830:  MOVWF  x62
1832:  RCALL  103C
1834:  MOVLW  DA
1836:  MOVWF  FF6
1838:  MOVLW  00
183A:  MOVWF  FF7
183C:  MOVLW  04
183E:  MOVWF  5E
1840:  CALL   0F4E
1844:  MOVLW  89
1846:  MOVWF  FE9
1848:  MOVFF  44,61
184C:  MOVFF  43,60
1850:  MOVFF  42,5F
1854:  MOVFF  41,5E
1858:  MOVLW  02
185A:  MOVWF  x62
185C:  CALL   103C
1860:  MOVLW  20
1862:  MOVWF  x6C
1864:  CALL   02D8
1868:  MOVLW  20
186A:  MOVWF  x6C
186C:  CALL   02D8
....................                 delay_ms(1000); 
1870:  MOVLW  04
1872:  MOVWF  5E
1874:  MOVLW  FA
1876:  MOVWF  x6D
1878:  CALL   00E4
187C:  DECFSZ 5E,F
187E:  BRA    1874
....................                 enable_interrupts(INT_TIMER1); 
1880:  BSF    F9D.0
....................                 enable_interrupts(GLOBAL); 
1882:  MOVLW  C0
1884:  IORWF  FF2,F
....................                 pulso_timer=0; 
1886:  CLRF   25
....................                 set_timer1(carga);    
1888:  MOVLW  E8
188A:  MOVWF  FCF
188C:  MOVLW  AB
188E:  MOVWF  FCE
.................... 				//reinicia todo 
....................                 corriente_RMS=0; 
1890:  CLRF   44
1892:  CLRF   43
1894:  CLRF   42
1896:  CLRF   41
....................                 tension_RMS=0; 
1898:  CLRF   40
189A:  CLRF   3F
189C:  CLRF   3E
189E:  CLRF   3D
....................                  
.................... 				estado = PUNTO_TENS_CORR; 
18A0:  CLRF   5D
.................... 		 
....................  
.................... 				break; 
18A2:  BRA    18A6
.................... 			 
.................... 			default: estado = PUNTO_TENS_CORR; 
18A4:  CLRF   5D
.................... 		} 
18A6:  GOTO   1946 (RETURN)
....................  
....................  
.................... } 
....................  
.................... //Funciones asociadas a los eventos 
....................  
.................... /** 
.................... *	\fn int -(void) 
.................... *	\brief Resumen 
.................... *	\details Detalles 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 4C07   PLL12 CPUDIV1 NOUSBDIV HS FCMEN NOIESO
   Word  2: 1E39   NOPUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0000   NOSTVREN NOLVP ICSP1 NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
