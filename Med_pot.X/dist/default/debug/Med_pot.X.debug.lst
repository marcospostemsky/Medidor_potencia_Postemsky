CCS PCH C Compiler, Version 5.048, 5967               03-nov-16 10:04

               Filename:   C:\Users\MARCOS\Proyecto_final\Med_pot.X\dist\default\debug\Med_pot.X.debug.lst

               ROM used:   5978 bytes (18%)
                           Largest free fragment is 26786
               RAM used:   84 (4%) at main() level
                           146 (7%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   1720
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   00AE
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #import(file="build/default/debug/main.o") 
.................... #import(file="build/default/debug/funciones.o") 
.................... /** 
.................... *	\file main.c 
.................... *	\brief Resumen del contenido del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
02C0:  MOVLW  8E
02C2:  MOVWF  00
02C4:  MOVFF  83,01
02C8:  MOVFF  82,02
02CC:  CLRF   03
02CE:  MOVF   01,F
02D0:  BNZ   02E4
02D2:  MOVFF  02,01
02D6:  CLRF   02
02D8:  MOVLW  08
02DA:  SUBWF  00,F
02DC:  MOVF   01,F
02DE:  BNZ   02E4
02E0:  CLRF   00
02E2:  BRA    02F4
02E4:  BCF    FD8.0
02E6:  BTFSC  01.7
02E8:  BRA    02F2
02EA:  RLCF   02,F
02EC:  RLCF   01,F
02EE:  DECF   00,F
02F0:  BRA    02E4
02F2:  BCF    01.7
02F4:  RETURN 0
02F6:  MOVF   x82,W
02F8:  BTFSC  FD8.2
02FA:  BRA    03DE
02FC:  MOVWF  00
02FE:  MOVF   x86,W
0300:  BTFSC  FD8.2
0302:  BRA    03DE
0304:  ADDWF  00,F
0306:  BNC   0310
0308:  MOVLW  81
030A:  ADDWF  00,F
030C:  BC    03DE
030E:  BRA    0318
0310:  MOVLW  7F
0312:  SUBWF  00,F
0314:  BNC   03DE
0316:  BZ    03DE
0318:  MOVFF  83,8A
031C:  MOVF   x87,W
031E:  XORWF  x8A,F
0320:  BSF    x83.7
0322:  BSF    x87.7
0324:  MOVF   x85,W
0326:  MULWF  x89
0328:  MOVFF  FF4,8C
032C:  MOVF   x84,W
032E:  MULWF  x88
0330:  MOVFF  FF4,03
0334:  MOVFF  FF3,8B
0338:  MULWF  x89
033A:  MOVF   FF3,W
033C:  ADDWF  x8C,F
033E:  MOVF   FF4,W
0340:  ADDWFC x8B,F
0342:  MOVLW  00
0344:  ADDWFC 03,F
0346:  MOVF   x85,W
0348:  MULWF  x88
034A:  MOVF   FF3,W
034C:  ADDWF  x8C,F
034E:  MOVF   FF4,W
0350:  ADDWFC x8B,F
0352:  MOVLW  00
0354:  CLRF   02
0356:  ADDWFC 03,F
0358:  ADDWFC 02,F
035A:  MOVF   x83,W
035C:  MULWF  x89
035E:  MOVF   FF3,W
0360:  ADDWF  x8B,F
0362:  MOVF   FF4,W
0364:  ADDWFC 03,F
0366:  MOVLW  00
0368:  ADDWFC 02,F
036A:  MOVF   x83,W
036C:  MULWF  x88
036E:  MOVF   FF3,W
0370:  ADDWF  03,F
0372:  MOVF   FF4,W
0374:  ADDWFC 02,F
0376:  MOVLW  00
0378:  CLRF   01
037A:  ADDWFC 01,F
037C:  MOVF   x85,W
037E:  MULWF  x87
0380:  MOVF   FF3,W
0382:  ADDWF  x8B,F
0384:  MOVF   FF4,W
0386:  ADDWFC 03,F
0388:  MOVLW  00
038A:  ADDWFC 02,F
038C:  ADDWFC 01,F
038E:  MOVF   x84,W
0390:  MULWF  x87
0392:  MOVF   FF3,W
0394:  ADDWF  03,F
0396:  MOVF   FF4,W
0398:  ADDWFC 02,F
039A:  MOVLW  00
039C:  ADDWFC 01,F
039E:  MOVF   x83,W
03A0:  MULWF  x87
03A2:  MOVF   FF3,W
03A4:  ADDWF  02,F
03A6:  MOVF   FF4,W
03A8:  ADDWFC 01,F
03AA:  INCF   00,F
03AC:  BTFSC  01.7
03AE:  BRA    03BA
03B0:  RLCF   x8B,F
03B2:  RLCF   03,F
03B4:  RLCF   02,F
03B6:  RLCF   01,F
03B8:  DECF   00,F
03BA:  MOVLW  00
03BC:  BTFSS  x8B.7
03BE:  BRA    03D4
03C0:  INCF   03,F
03C2:  ADDWFC 02,F
03C4:  ADDWFC 01,F
03C6:  MOVF   01,W
03C8:  BNZ   03D4
03CA:  MOVF   02,W
03CC:  BNZ   03D4
03CE:  MOVF   03,W
03D0:  BNZ   03D4
03D2:  INCF   00,F
03D4:  BTFSC  x8A.7
03D6:  BSF    01.7
03D8:  BTFSS  x8A.7
03DA:  BCF    01.7
03DC:  BRA    03E6
03DE:  CLRF   00
03E0:  CLRF   01
03E2:  CLRF   02
03E4:  CLRF   03
03E6:  RETURN 0
03E8:  MOVF   x66,W
03EA:  BTFSC  FD8.2
03EC:  BRA    0538
03EE:  MOVWF  x72
03F0:  MOVF   x6A,W
03F2:  BTFSC  FD8.2
03F4:  BRA    0538
03F6:  SUBWF  x72,F
03F8:  BNC   0404
03FA:  MOVLW  7F
03FC:  ADDWF  x72,F
03FE:  BTFSC  FD8.0
0400:  BRA    0538
0402:  BRA    0410
0404:  MOVLW  81
0406:  SUBWF  x72,F
0408:  BTFSS  FD8.0
040A:  BRA    0538
040C:  BTFSC  FD8.2
040E:  BRA    0538
0410:  MOVFF  72,00
0414:  CLRF   01
0416:  CLRF   02
0418:  CLRF   03
041A:  CLRF   x71
041C:  MOVFF  67,70
0420:  BSF    x70.7
0422:  MOVFF  68,6F
0426:  MOVFF  69,6E
042A:  MOVLW  19
042C:  MOVWF  x72
042E:  MOVF   x6D,W
0430:  SUBWF  x6E,F
0432:  BC    044E
0434:  MOVLW  01
0436:  SUBWF  x6F,F
0438:  BC    044E
043A:  SUBWF  x70,F
043C:  BC    044E
043E:  SUBWF  x71,F
0440:  BC    044E
0442:  INCF   x71,F
0444:  INCF   x70,F
0446:  INCF   x6F,F
0448:  MOVF   x6D,W
044A:  ADDWF  x6E,F
044C:  BRA    049E
044E:  MOVF   x6C,W
0450:  SUBWF  x6F,F
0452:  BC    0478
0454:  MOVLW  01
0456:  SUBWF  x70,F
0458:  BC    0478
045A:  SUBWF  x71,F
045C:  BC    0478
045E:  INCF   x71,F
0460:  INCF   x70,F
0462:  MOVF   x6C,W
0464:  ADDWF  x6F,F
0466:  MOVF   x6D,W
0468:  ADDWF  x6E,F
046A:  BNC   049E
046C:  INCF   x6F,F
046E:  BNZ   049E
0470:  INCF   x70,F
0472:  BNZ   049E
0474:  INCF   x71,F
0476:  BRA    049E
0478:  MOVF   x6B,W
047A:  IORLW  80
047C:  SUBWF  x70,F
047E:  BC    049C
0480:  MOVLW  01
0482:  SUBWF  x71,F
0484:  BC    049C
0486:  INCF   x71,F
0488:  MOVF   x6B,W
048A:  IORLW  80
048C:  ADDWF  x70,F
048E:  MOVF   x6C,W
0490:  ADDWF  x6F,F
0492:  BNC   0466
0494:  INCF   x70,F
0496:  BNZ   0466
0498:  INCF   x71,F
049A:  BRA    0466
049C:  BSF    03.0
049E:  DECFSZ x72,F
04A0:  BRA    04A4
04A2:  BRA    04BA
04A4:  BCF    FD8.0
04A6:  RLCF   x6E,F
04A8:  RLCF   x6F,F
04AA:  RLCF   x70,F
04AC:  RLCF   x71,F
04AE:  BCF    FD8.0
04B0:  RLCF   03,F
04B2:  RLCF   02,F
04B4:  RLCF   01,F
04B6:  RLCF   x73,F
04B8:  BRA    042E
04BA:  BTFSS  x73.0
04BC:  BRA    04CA
04BE:  BCF    FD8.0
04C0:  RRCF   01,F
04C2:  RRCF   02,F
04C4:  RRCF   03,F
04C6:  RRCF   x73,F
04C8:  BRA    04CE
04CA:  DECF   00,F
04CC:  BZ    0538
04CE:  BTFSC  x73.7
04D0:  BRA    050E
04D2:  BCF    FD8.0
04D4:  RLCF   x6E,F
04D6:  RLCF   x6F,F
04D8:  RLCF   x70,F
04DA:  RLCF   x71,F
04DC:  MOVF   x6D,W
04DE:  SUBWF  x6E,F
04E0:  BC    04F0
04E2:  MOVLW  01
04E4:  SUBWF  x6F,F
04E6:  BC    04F0
04E8:  SUBWF  x70,F
04EA:  BC    04F0
04EC:  SUBWF  x71,F
04EE:  BNC   0524
04F0:  MOVF   x6C,W
04F2:  SUBWF  x6F,F
04F4:  BC    0500
04F6:  MOVLW  01
04F8:  SUBWF  x70,F
04FA:  BC    0500
04FC:  SUBWF  x71,F
04FE:  BNC   0524
0500:  MOVF   x6B,W
0502:  IORLW  80
0504:  SUBWF  x70,F
0506:  BC    050E
0508:  MOVLW  01
050A:  SUBWF  x71,F
050C:  BNC   0524
050E:  INCF   03,F
0510:  BNZ   0524
0512:  INCF   02,F
0514:  BNZ   0524
0516:  INCF   01,F
0518:  BNZ   0524
051A:  INCF   00,F
051C:  BZ    0538
051E:  RRCF   01,F
0520:  RRCF   02,F
0522:  RRCF   03,F
0524:  MOVFF  67,72
0528:  MOVF   x6B,W
052A:  XORWF  x72,F
052C:  BTFSS  x72.7
052E:  BRA    0534
0530:  BSF    01.7
0532:  BRA    0540
0534:  BCF    01.7
0536:  BRA    0540
0538:  CLRF   00
053A:  CLRF   01
053C:  CLRF   02
053E:  CLRF   03
0540:  RETURN 0
0542:  MOVLW  80
0544:  BTFSC  FD8.1
0546:  XORWF  x87,F
0548:  CLRF   x8C
054A:  CLRF   x8D
054C:  MOVFF  83,8B
0550:  MOVF   x87,W
0552:  XORWF  x8B,F
0554:  MOVF   x82,W
0556:  BTFSC  FD8.2
0558:  BRA    0712
055A:  MOVWF  x8A
055C:  MOVWF  00
055E:  MOVF   x86,W
0560:  BTFSC  FD8.2
0562:  BRA    0724
0564:  SUBWF  x8A,F
0566:  BTFSC  FD8.2
0568:  BRA    066C
056A:  BNC   05E6
056C:  MOVFF  87,90
0570:  BSF    x90.7
0572:  MOVFF  88,8F
0576:  MOVFF  89,8E
057A:  CLRF   x8D
057C:  BCF    FD8.0
057E:  RRCF   x90,F
0580:  RRCF   x8F,F
0582:  RRCF   x8E,F
0584:  RRCF   x8D,F
0586:  DECFSZ x8A,F
0588:  BRA    057A
058A:  BTFSS  x8B.7
058C:  BRA    0594
058E:  BSF    x8C.0
0590:  BRA    074C
0592:  BCF    x8C.0
0594:  BCF    x8A.0
0596:  BSF    x8C.4
0598:  CLRF   FEA
059A:  MOVLW  85
059C:  MOVWF  FE9
059E:  BRA    0772
05A0:  BCF    x8C.4
05A2:  BTFSC  x8B.7
05A4:  BRA    05BA
05A6:  BTFSS  x8A.0
05A8:  BRA    05D0
05AA:  RRCF   x90,F
05AC:  RRCF   x8F,F
05AE:  RRCF   x8E,F
05B0:  RRCF   x8D,F
05B2:  INCF   00,F
05B4:  BTFSC  FD8.2
05B6:  BRA    0742
05B8:  BRA    05D0
05BA:  BTFSC  x90.7
05BC:  BRA    05D6
05BE:  BCF    FD8.0
05C0:  RLCF   x8D,F
05C2:  RLCF   x8E,F
05C4:  RLCF   x8F,F
05C6:  RLCF   x90,F
05C8:  DECF   00,F
05CA:  BTFSC  FD8.2
05CC:  BRA    0742
05CE:  BRA    05BA
05D0:  BSF    x8C.6
05D2:  BRA    06AA
05D4:  BCF    x8C.6
05D6:  MOVFF  83,8B
05DA:  BTFSS  x83.7
05DC:  BRA    05E2
05DE:  BSF    x90.7
05E0:  BRA    0734
05E2:  BCF    x90.7
05E4:  BRA    0734
05E6:  MOVFF  86,8A
05EA:  MOVFF  86,00
05EE:  MOVF   x82,W
05F0:  SUBWF  x8A,F
05F2:  MOVFF  83,90
05F6:  BSF    x90.7
05F8:  MOVFF  84,8F
05FC:  MOVFF  85,8E
0600:  CLRF   x8D
0602:  BCF    FD8.0
0604:  RRCF   x90,F
0606:  RRCF   x8F,F
0608:  RRCF   x8E,F
060A:  RRCF   x8D,F
060C:  DECFSZ x8A,F
060E:  BRA    0600
0610:  BTFSS  x8B.7
0612:  BRA    061A
0614:  BSF    x8C.1
0616:  BRA    074C
0618:  BCF    x8C.1
061A:  BCF    x8A.0
061C:  BSF    x8C.5
061E:  CLRF   FEA
0620:  MOVLW  89
0622:  MOVWF  FE9
0624:  BRA    0772
0626:  BCF    x8C.5
0628:  BTFSC  x8B.7
062A:  BRA    0640
062C:  BTFSS  x8A.0
062E:  BRA    0656
0630:  RRCF   x90,F
0632:  RRCF   x8F,F
0634:  RRCF   x8E,F
0636:  RRCF   x8D,F
0638:  INCF   00,F
063A:  BTFSC  FD8.2
063C:  BRA    0742
063E:  BRA    0656
0640:  BTFSC  x90.7
0642:  BRA    065C
0644:  BCF    FD8.0
0646:  RLCF   x8D,F
0648:  RLCF   x8E,F
064A:  RLCF   x8F,F
064C:  RLCF   x90,F
064E:  DECF   00,F
0650:  BTFSC  FD8.2
0652:  BRA    0742
0654:  BRA    0640
0656:  BSF    x8C.7
0658:  BRA    06AA
065A:  BCF    x8C.7
065C:  MOVFF  87,8B
0660:  BTFSS  x87.7
0662:  BRA    0668
0664:  BSF    x90.7
0666:  BRA    0734
0668:  BCF    x90.7
066A:  BRA    0734
066C:  MOVFF  87,90
0670:  BSF    x90.7
0672:  MOVFF  88,8F
0676:  MOVFF  89,8E
067A:  BTFSS  x8B.7
067C:  BRA    0686
067E:  BCF    x90.7
0680:  BSF    x8C.2
0682:  BRA    074C
0684:  BCF    x8C.2
0686:  CLRF   x8D
0688:  BCF    x8A.0
068A:  CLRF   FEA
068C:  MOVLW  85
068E:  MOVWF  FE9
0690:  BRA    0772
0692:  BTFSC  x8B.7
0694:  BRA    06CE
0696:  MOVFF  83,8B
069A:  BTFSS  x8A.0
069C:  BRA    06AA
069E:  RRCF   x90,F
06A0:  RRCF   x8F,F
06A2:  RRCF   x8E,F
06A4:  RRCF   x8D,F
06A6:  INCF   00,F
06A8:  BZ    0742
06AA:  BTFSS  x8D.7
06AC:  BRA    06C4
06AE:  INCF   x8E,F
06B0:  BNZ   06C4
06B2:  INCF   x8F,F
06B4:  BNZ   06C4
06B6:  INCF   x90,F
06B8:  BNZ   06C4
06BA:  RRCF   x90,F
06BC:  RRCF   x8F,F
06BE:  RRCF   x8E,F
06C0:  INCF   00,F
06C2:  BZ    0742
06C4:  BTFSC  x8C.6
06C6:  BRA    05D4
06C8:  BTFSC  x8C.7
06CA:  BRA    065A
06CC:  BRA    0706
06CE:  MOVLW  80
06D0:  XORWF  x90,F
06D2:  BTFSS  x90.7
06D4:  BRA    06DE
06D6:  BRA    074C
06D8:  MOVFF  87,8B
06DC:  BRA    06F2
06DE:  MOVFF  83,8B
06E2:  MOVF   x90,F
06E4:  BNZ   06F2
06E6:  MOVF   x8F,F
06E8:  BNZ   06F2
06EA:  MOVF   x8E,F
06EC:  BNZ   06F2
06EE:  CLRF   00
06F0:  BRA    0734
06F2:  BTFSC  x90.7
06F4:  BRA    0706
06F6:  BCF    FD8.0
06F8:  RLCF   x8D,F
06FA:  RLCF   x8E,F
06FC:  RLCF   x8F,F
06FE:  RLCF   x90,F
0700:  DECFSZ 00,F
0702:  BRA    06F2
0704:  BRA    0742
0706:  BTFSS  x8B.7
0708:  BRA    070E
070A:  BSF    x90.7
070C:  BRA    0734
070E:  BCF    x90.7
0710:  BRA    0734
0712:  MOVFF  86,00
0716:  MOVFF  87,90
071A:  MOVFF  88,8F
071E:  MOVFF  89,8E
0722:  BRA    0734
0724:  MOVFF  82,00
0728:  MOVFF  83,90
072C:  MOVFF  84,8F
0730:  MOVFF  85,8E
0734:  MOVFF  90,01
0738:  MOVFF  8F,02
073C:  MOVFF  8E,03
0740:  BRA    07AA
0742:  CLRF   00
0744:  CLRF   01
0746:  CLRF   02
0748:  CLRF   03
074A:  BRA    07AA
074C:  CLRF   x8D
074E:  COMF   x8E,F
0750:  COMF   x8F,F
0752:  COMF   x90,F
0754:  COMF   x8D,F
0756:  INCF   x8D,F
0758:  BNZ   0764
075A:  INCF   x8E,F
075C:  BNZ   0764
075E:  INCF   x8F,F
0760:  BNZ   0764
0762:  INCF   x90,F
0764:  BTFSC  x8C.0
0766:  BRA    0592
0768:  BTFSC  x8C.1
076A:  BRA    0618
076C:  BTFSC  x8C.2
076E:  BRA    0684
0770:  BRA    06D8
0772:  MOVF   FEF,W
0774:  ADDWF  x8E,F
0776:  BNC   0782
0778:  INCF   x8F,F
077A:  BNZ   0782
077C:  INCF   x90,F
077E:  BTFSC  FD8.2
0780:  BSF    x8A.0
0782:  MOVF   FED,F
0784:  MOVF   FEF,W
0786:  ADDWF  x8F,F
0788:  BNC   0790
078A:  INCF   x90,F
078C:  BTFSC  FD8.2
078E:  BSF    x8A.0
0790:  MOVF   FED,F
0792:  MOVF   FEF,W
0794:  BTFSC  FEF.7
0796:  BRA    079A
0798:  XORLW  80
079A:  ADDWF  x90,F
079C:  BTFSC  FD8.0
079E:  BSF    x8A.0
07A0:  BTFSC  x8C.4
07A2:  BRA    05A0
07A4:  BTFSC  x8C.5
07A6:  BRA    0626
07A8:  BRA    0692
07AA:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
*
0E0A:  CLRF   FEA
0E0C:  MOVLW  63
0E0E:  MOVWF  FE9
0E10:  MOVF   FEF,W
0E12:  BZ    0E30
0E14:  MOVLW  0F
0E16:  MOVWF  01
0E18:  CLRF   00
0E1A:  DECFSZ 00,F
0E1C:  BRA    0E1A
0E1E:  DECFSZ 01,F
0E20:  BRA    0E18
0E22:  MOVLW  8F
0E24:  MOVWF  00
0E26:  DECFSZ 00,F
0E28:  BRA    0E26
0E2A:  NOP   
0E2C:  DECFSZ FEF,F
0E2E:  BRA    0E14
0E30:  RETURN 0
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
*
0CAC:  MOVLW  08
0CAE:  MOVWF  01
0CB0:  MOVLW  11
0CB2:  MOVWF  00
0CB4:  DECFSZ 00,F
0CB6:  BRA    0CB4
0CB8:  BCF    F8C.7
0CBA:  BCF    F95.7
0CBC:  MOVLW  11
0CBE:  MOVWF  00
0CC0:  DECFSZ 00,F
0CC2:  BRA    0CC0
0CC4:  RLCF   x67,F
0CC6:  BCF    F8C.6
0CC8:  BTFSC  FD8.0
0CCA:  BSF    F95.6
0CCC:  BTFSS  FD8.0
0CCE:  BCF    F95.6
0CD0:  BSF    F95.7
0CD2:  BTFSS  F83.7
0CD4:  BRA    0CD2
0CD6:  DECFSZ 01,F
0CD8:  BRA    0CB0
0CDA:  MOVLW  11
0CDC:  MOVWF  00
0CDE:  DECFSZ 00,F
0CE0:  BRA    0CDE
0CE2:  BCF    F8C.7
0CE4:  BCF    F95.7
0CE6:  NOP   
0CE8:  BSF    F95.6
0CEA:  MOVLW  11
0CEC:  MOVWF  00
0CEE:  DECFSZ 00,F
0CF0:  BRA    0CEE
0CF2:  MOVLW  11
0CF4:  MOVWF  00
0CF6:  DECFSZ 00,F
0CF8:  BRA    0CF6
0CFA:  BSF    F95.7
0CFC:  BTFSS  F83.7
0CFE:  BRA    0CFC
0D00:  CLRF   01
0D02:  MOVLW  11
0D04:  MOVWF  00
0D06:  DECFSZ 00,F
0D08:  BRA    0D06
0D0A:  BTFSC  F83.6
0D0C:  BSF    01.0
0D0E:  BCF    F8C.7
0D10:  BCF    F95.7
0D12:  BCF    F8C.6
0D14:  BCF    F95.6
0D16:  RETURN 0
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
*
172C:  CLRF   19
172E:  CLRF   1A
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
*
173E:  CLRF   24
1740:  MOVF   FC1,W
1742:  ANDLW  C0
1744:  IORLW  0F
1746:  MOVWF  FC1
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
....................         delay_us(20); 
....................         i2c_write(LCD_ADDR); //the slave addresse 
....................         delay_us(20); 
....................         i2c_write(data); 
....................         delay_us(20); 
....................         i2c_stop(); 
....................         delay_us(20); 
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
....................         i2c_send_nibble(data); 
....................         data=data-4;       //toggle EN back to 0 
....................         i2c_send_nibble(data); 
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
....................     lcd_send_byte(0x10); 
....................     delay_ms(2); 
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x30); 
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x20); 
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
....................         lcd_send_byte(0x80); 
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0xC0); 
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x60); 
....................            //clears the display 
....................         lcd_clear(); 
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
*
1730:  CLRF   21
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
....................       case 2:  address= lcd_line_two;     break; 
....................       case 3:  address= lcd_line_three;   break; 
....................       case 4:  address= lcd_line_four;    break; 
....................       default: address= lcd_line_one;     break;  
....................    } 
....................   
....................    address+=x-1; 
....................    data=address&0xF0; 
....................    lcd_send_byte(data); 
....................    data=address&0x0F; 
....................    data=data<<4; 
....................    lcd_send_byte(data); 
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
....................      case '\1': lcd_gotoxy(1,1);  break; 
....................      case '\2': lcd_gotoxy(1,2);  break; 
....................      case '\3': lcd_gotoxy(1,3);  break; 
....................      case '\4': lcd_gotoxy(1,4);  break; 
....................  
....................      default: 
....................         data=in_data&0xF0; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................         data=in_data&0x0F; 
....................         data=data<<4; 
....................         data=data|RS; //set RS pin to 1 
....................         lcd_send_byte(data); 
....................      break; 
....................    } 
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
....................  
.................... const long carga= 0xE8AB; 
.................... extern int contador; 
.................... extern long pulso_timer; 
....................  
.................... void inicializar(); 
....................  
.................... void main() 
*
1720:  CLRF   FF8
1722:  BCF    FD0.7
1724:  BSF    07.7
1726:  BSF    20.0
1728:  BSF    20.0
172A:  BSF    20.0
*
1732:  CLRF   22
1734:  CLRF   23
1736:  BSF    20.0
1738:  MOVLW  14
173A:  MOVWF  32
173C:  CLRF   53
*
1748:  MOVLW  07
174A:  MOVWF  FB4
.................... { 
....................  
.................... //declaracion de variables 
.................... //inicializacion de perifericos 
....................  
.................... 	inicializar() ; 
174C:  GOTO   00DC
....................      
....................     set_timer1(carga); 
1750:  MOVLW  E8
1752:  MOVWF  FCF
1754:  MOVLW  AB
1756:  MOVWF  FCE
.................... 	while(1) 
.................... 	{ 
....................  
.................... 		maquina_estado(); 
1758:  BRA    111A
175A:  BRA    1758
....................  
.................... 	} 
.................... } 
....................  
175C:  SLEEP 
.................... void Inicializar(){ 
....................     setup_timer_1( T1_INTERNAL|T1_DIV_BY_2); 
*
00DC:  MOVLW  95
00DE:  MOVWF  FCD
....................     setup_timer_0(T0_INTERNAL |T0_DIV_32); 
00E0:  MOVLW  84
00E2:  MOVWF  FD5
....................     set_timer0(0x0000); 
00E4:  CLRF   FD7
00E6:  CLRF   FD6
....................     set_tris_a(0xE8);// configuracion portA necesaria para la libreria control_ADC 
00E8:  MOVLW  E8
00EA:  MOVWF  F92
....................     set_tris_b(0xFF); 
00EC:  MOVLW  FF
00EE:  MOVWF  F93
....................     contador=0; 
00F0:  CLRF   22
....................     /*lcd_init(); 
....................     lcd_gotoxy(1,1); 
....................     printf(LCD_PUTC,"Primer prueba"); 
....................     lcd_backlight=ON;*/ 
....................     enable_interrupts (INT_TIMER1); 
00F2:  BSF    F9D.0
....................     enable_interrupts (GLOBAL); 
00F4:  MOVLW  C0
00F6:  IORWF  FF2,F
....................     output_high (PIN_A0); //pone en alto el chipselect del AD7450 
00F8:  BSF    F89.0
....................     output_high (PIN_A1); // pone en alto el chipselect del MAX186 
00FA:  BSF    F89.1
00FC:  GOTO   1750 (RETURN)
.................... } 
....................  
....................  
.................... /** 
.................... *	\file funciones.c 
.................... *	\brief  
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
00BE:  DATA 50,6F
00C0:  DATA 74,65
00C2:  DATA 6E,63
00C4:  DATA 69,61
00C6:  DATA 3D,20
00C8:  DATA 25,66
00CA:  DATA 20,57
00CC:  DATA 00,00
00CE:  DATA 54,3D
00D0:  DATA 25,66
00D2:  DATA 20,20
00D4:  DATA 49,3D
00D6:  DATA 25,66
00D8:  DATA 20,20
00DA:  DATA 00,00
*
0276:  MOVLW  8E
0278:  MOVWF  00
027A:  MOVFF  55,01
027E:  MOVFF  54,02
0282:  CLRF   03
0284:  BTFSS  55.7
0286:  BRA    0292
0288:  COMF   01,F
028A:  COMF   02,F
028C:  INCF   02,F
028E:  BNZ   0292
0290:  INCF   01,F
0292:  MOVF   01,F
0294:  BNZ   02A8
0296:  MOVFF  02,01
029A:  CLRF   02
029C:  MOVLW  08
029E:  SUBWF  00,F
02A0:  MOVF   01,F
02A2:  BNZ   02A8
02A4:  CLRF   00
02A6:  BRA    02BC
02A8:  BCF    FD8.0
02AA:  BTFSC  01.7
02AC:  BRA    02B6
02AE:  RLCF   02,F
02B0:  RLCF   01,F
02B2:  DECF   00,F
02B4:  BRA    02A8
02B6:  BTFSC  55.7
02B8:  BRA    02BC
02BA:  BCF    01.7
02BC:  GOTO   115C (RETURN)
*
07AC:  MOVFF  7F,86
07B0:  MOVF   x83,W
07B2:  XORWF  x86,F
07B4:  BTFSS  x86.7
07B6:  BRA    07C2
07B8:  BCF    FD8.2
07BA:  BCF    FD8.0
07BC:  BTFSC  x7F.7
07BE:  BSF    FD8.0
07C0:  BRA    0820
07C2:  MOVFF  7F,86
07C6:  MOVFF  82,87
07CA:  MOVF   x7E,W
07CC:  SUBWF  x87,F
07CE:  BZ    07DC
07D0:  BTFSS  x86.7
07D2:  BRA    0820
07D4:  MOVF   FD8,W
07D6:  XORLW  01
07D8:  MOVWF  FD8
07DA:  BRA    0820
07DC:  MOVFF  83,87
07E0:  MOVF   x7F,W
07E2:  SUBWF  x87,F
07E4:  BZ    07F2
07E6:  BTFSS  x86.7
07E8:  BRA    0820
07EA:  MOVF   FD8,W
07EC:  XORLW  01
07EE:  MOVWF  FD8
07F0:  BRA    0820
07F2:  MOVFF  84,87
07F6:  MOVF   x80,W
07F8:  SUBWF  x87,F
07FA:  BZ    0808
07FC:  BTFSS  x86.7
07FE:  BRA    0820
0800:  MOVF   FD8,W
0802:  XORLW  01
0804:  MOVWF  FD8
0806:  BRA    0820
0808:  MOVFF  85,87
080C:  MOVF   x81,W
080E:  SUBWF  x87,F
0810:  BZ    081E
0812:  BTFSS  x86.7
0814:  BRA    0820
0816:  MOVF   FD8,W
0818:  XORLW  01
081A:  MOVWF  FD8
081C:  BRA    0820
081E:  BCF    FD8.0
0820:  RETURN 0
*
092C:  MOVLW  8E
092E:  MOVWF  00
0930:  MOVF   x7E,W
0932:  SUBWF  00,F
0934:  MOVFF  7F,02
0938:  MOVFF  80,01
093C:  BSF    02.7
093E:  MOVF   00,F
0940:  BZ    0954
0942:  BCF    FD8.0
0944:  MOVF   02,F
0946:  BNZ   094C
0948:  MOVF   01,F
094A:  BZ    0954
094C:  RRCF   02,F
094E:  RRCF   01,F
0950:  DECFSZ 00,F
0952:  BRA    0942
0954:  BTFSS  x7F.7
0956:  BRA    0962
0958:  COMF   01,F
095A:  COMF   02,F
095C:  INCF   01,F
095E:  BTFSC  FD8.2
0960:  INCF   02,F
0962:  GOTO   0A12 (RETURN)
*
0EB4:  TBLRD*+
0EB6:  MOVFF  FF6,55
0EBA:  MOVFF  FF7,56
0EBE:  MOVFF  FF5,62
0EC2:  RCALL  0E46
0EC4:  MOVFF  55,FF6
0EC8:  MOVFF  56,FF7
0ECC:  DECFSZ 54,F
0ECE:  BRA    0EB4
0ED0:  RETURN 0
0ED2:  MOVF   x61,W
0ED4:  SUBLW  B6
0ED6:  MOVWF  x61
0ED8:  CLRF   03
0EDA:  MOVFF  62,65
0EDE:  BSF    x62.7
0EE0:  BCF    FD8.0
0EE2:  RRCF   x62,F
0EE4:  RRCF   x63,F
0EE6:  RRCF   x64,F
0EE8:  RRCF   03,F
0EEA:  RRCF   02,F
0EEC:  RRCF   01,F
0EEE:  RRCF   00,F
0EF0:  DECFSZ x61,F
0EF2:  BRA    0EE0
0EF4:  BTFSS  x65.7
0EF6:  BRA    0F0E
0EF8:  COMF   00,F
0EFA:  COMF   01,F
0EFC:  COMF   02,F
0EFE:  COMF   03,F
0F00:  INCF   00,F
0F02:  BTFSC  FD8.2
0F04:  INCF   01,F
0F06:  BTFSC  FD8.2
0F08:  INCF   02,F
0F0A:  BTFSC  FD8.2
0F0C:  INCF   03,F
0F0E:  GOTO   0FF0 (RETURN)
0F12:  BTFSC  FD8.1
0F14:  BRA    0F1C
0F16:  CLRF   FEA
0F18:  MOVLW  69
0F1A:  MOVWF  FE9
0F1C:  CLRF   00
0F1E:  CLRF   01
0F20:  CLRF   02
0F22:  CLRF   03
0F24:  CLRF   x69
0F26:  CLRF   x6A
0F28:  CLRF   x6B
0F2A:  CLRF   x6C
0F2C:  MOVF   x68,W
0F2E:  IORWF  x67,W
0F30:  IORWF  x66,W
0F32:  IORWF  x65,W
0F34:  BZ    0F8E
0F36:  MOVLW  20
0F38:  MOVWF  x6D
0F3A:  BCF    FD8.0
0F3C:  RLCF   x61,F
0F3E:  RLCF   x62,F
0F40:  RLCF   x63,F
0F42:  RLCF   x64,F
0F44:  RLCF   x69,F
0F46:  RLCF   x6A,F
0F48:  RLCF   x6B,F
0F4A:  RLCF   x6C,F
0F4C:  MOVF   x68,W
0F4E:  SUBWF  x6C,W
0F50:  BNZ   0F62
0F52:  MOVF   x67,W
0F54:  SUBWF  x6B,W
0F56:  BNZ   0F62
0F58:  MOVF   x66,W
0F5A:  SUBWF  x6A,W
0F5C:  BNZ   0F62
0F5E:  MOVF   x65,W
0F60:  SUBWF  x69,W
0F62:  BNC   0F82
0F64:  MOVF   x65,W
0F66:  SUBWF  x69,F
0F68:  MOVF   x66,W
0F6A:  BTFSS  FD8.0
0F6C:  INCFSZ x66,W
0F6E:  SUBWF  x6A,F
0F70:  MOVF   x67,W
0F72:  BTFSS  FD8.0
0F74:  INCFSZ x67,W
0F76:  SUBWF  x6B,F
0F78:  MOVF   x68,W
0F7A:  BTFSS  FD8.0
0F7C:  INCFSZ x68,W
0F7E:  SUBWF  x6C,F
0F80:  BSF    FD8.0
0F82:  RLCF   00,F
0F84:  RLCF   01,F
0F86:  RLCF   02,F
0F88:  RLCF   03,F
0F8A:  DECFSZ x6D,F
0F8C:  BRA    0F3A
0F8E:  MOVFF  69,FEF
0F92:  MOVFF  6A,FEC
0F96:  MOVFF  6B,FEC
0F9A:  MOVFF  6C,FEC
0F9E:  RETURN 0
0FA0:  MOVF   FE9,W
0FA2:  MOVWF  59
0FA4:  MOVF   58,W
0FA6:  MOVWF  5B
0FA8:  BZ    0FDE
0FAA:  MOVFF  57,85
0FAE:  MOVFF  56,84
0FB2:  MOVFF  55,83
0FB6:  MOVFF  54,82
0FBA:  CLRF   x89
0FBC:  CLRF   x88
0FBE:  MOVLW  20
0FC0:  MOVWF  x87
0FC2:  MOVLW  82
0FC4:  MOVWF  x86
0FC6:  CALL   02F6
0FCA:  MOVFF  03,57
0FCE:  MOVFF  02,56
0FD2:  MOVFF  01,55
0FD6:  MOVFF  00,54
0FDA:  DECFSZ 5B,F
0FDC:  BRA    0FAA
0FDE:  MOVFF  57,64
0FE2:  MOVFF  56,63
0FE6:  MOVFF  55,62
0FEA:  MOVFF  54,61
0FEE:  BRA    0ED2
0FF0:  MOVFF  03,57
0FF4:  MOVFF  02,56
0FF8:  MOVFF  01,55
0FFC:  MOVFF  00,54
1000:  BTFSS  57.7
1002:  BRA    101E
1004:  DECF   59,F
1006:  BSF    59.5
1008:  COMF   54,F
100A:  COMF   55,F
100C:  COMF   56,F
100E:  COMF   57,F
1010:  INCF   54,F
1012:  BTFSC  FD8.2
1014:  INCF   55,F
1016:  BTFSC  FD8.2
1018:  INCF   56,F
101A:  BTFSC  FD8.2
101C:  INCF   57,F
101E:  MOVLW  3B
1020:  MOVWF  x60
1022:  MOVLW  9A
1024:  MOVWF  5F
1026:  MOVLW  CA
1028:  MOVWF  5E
102A:  CLRF   5D
102C:  MOVLW  0A
102E:  MOVWF  5B
1030:  MOVF   58,W
1032:  BTFSC  FD8.2
1034:  INCF   59,F
1036:  BSF    FD8.1
1038:  CLRF   FEA
103A:  MOVLW  54
103C:  MOVWF  FE9
103E:  MOVFF  57,64
1042:  MOVFF  56,63
1046:  MOVFF  55,62
104A:  MOVFF  54,61
104E:  MOVFF  60,68
1052:  MOVFF  5F,67
1056:  MOVFF  5E,66
105A:  MOVFF  5D,65
105E:  RCALL  0F12
1060:  MOVF   01,W
1062:  MOVF   00,F
1064:  BNZ   1084
1066:  INCF   58,W
1068:  SUBWF  5B,W
106A:  BZ    1084
106C:  MOVF   59,W
106E:  BZ    1088
1070:  ANDLW  0F
1072:  SUBWF  5B,W
1074:  BZ    1078
1076:  BC    10E6
1078:  BTFSC  59.7
107A:  BRA    10E6
107C:  BTFSC  59.6
107E:  BRA    1088
1080:  MOVLW  20
1082:  BRA    10DE
1084:  MOVLW  20
1086:  ANDWF  59,F
1088:  BTFSS  59.5
108A:  BRA    10A4
108C:  BCF    59.5
108E:  MOVF   58,W
1090:  BTFSS  FD8.2
1092:  DECF   59,F
1094:  MOVF   00,W
1096:  MOVWF  59
1098:  MOVLW  2D
109A:  MOVWF  x62
109C:  RCALL  0E46
109E:  MOVF   59,W
10A0:  MOVWF  00
10A2:  CLRF   59
10A4:  MOVF   58,W
10A6:  SUBWF  5B,W
10A8:  BNZ   10BE
10AA:  MOVF   00,W
10AC:  MOVWF  59
10AE:  MOVLW  2E
10B0:  MOVWF  x62
10B2:  RCALL  0E46
10B4:  MOVF   59,W
10B6:  MOVWF  00
10B8:  MOVLW  20
10BA:  ANDWF  59,F
10BC:  MOVLW  00
10BE:  MOVLW  30
10C0:  BTFSS  59.5
10C2:  BRA    10DE
10C4:  BCF    59.5
10C6:  MOVF   58,W
10C8:  BTFSS  FD8.2
10CA:  DECF   59,F
10CC:  MOVF   00,W
10CE:  MOVWF  59
10D0:  MOVLW  2D
10D2:  MOVWF  x62
10D4:  RCALL  0E46
10D6:  MOVF   59,W
10D8:  MOVWF  00
10DA:  CLRF   59
10DC:  MOVLW  30
10DE:  ADDWF  00,F
10E0:  MOVFF  00,62
10E4:  RCALL  0E46
10E6:  BCF    FD8.1
10E8:  MOVFF  60,64
10EC:  MOVFF  5F,63
10F0:  MOVFF  5E,62
10F4:  MOVFF  5D,61
10F8:  CLRF   x68
10FA:  CLRF   x67
10FC:  CLRF   x66
10FE:  MOVLW  0A
1100:  MOVWF  x65
1102:  RCALL  0F12
1104:  MOVFF  03,60
1108:  MOVFF  02,5F
110C:  MOVFF  01,5E
1110:  MOVFF  00,5D
1114:  DECFSZ 5B,F
1116:  BRA    1036
1118:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOWDT,MCLR,HS,NOUSBDIV,NOIESO,            //Selecciona el oscilador externo 
.................... #use delay(clock=48 Mhz, crystal= 48 MHz)   // Selecciona la velocidad del oscilador interno 
.................... #use i2c(Master,Fast=100000, sda=PIN_D6, scl=PIN_D7,force_sw) 
.................... int contador = 0 ;int pulso_timer = 0 ; 
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
0822:  MOVFF  5B,81
0826:  MOVFF  5A,80
082A:  MOVFF  59,7F
082E:  MOVFF  58,7E
0832:  CLRF   x85
0834:  CLRF   x84
0836:  CLRF   x83
0838:  CLRF   x82
083A:  RCALL  07AC
083C:  BC    0840
083E:  BNZ   084A
....................       return(0.0); 
0840:  CLRF   00
0842:  CLRF   01
0844:  CLRF   02
0846:  CLRF   03
0848:  BRA    092A
....................  
....................    y=x; 
084A:  MOVFF  5B,5F
084E:  MOVFF  5A,5E
0852:  MOVFF  59,5D
0856:  MOVFF  58,5C
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
085A:  CLRF   x65
085C:  MOVLW  5C
085E:  MOVWF  x64
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
0860:  MOVFF  64,FE9
0864:  MOVFF  65,FEA
0868:  MOVF   FEF,W
086A:  CLRF   x69
086C:  MOVWF  x68
086E:  MOVLW  7F
0870:  ADDWF  x68,F
0872:  MOVLW  00
0874:  ADDWFC x69,F
0876:  BCF    FD8.0
0878:  RRCF   x69,W
087A:  RRCF   x68,W
087C:  MOVFF  65,FEA
0880:  MOVFF  64,FE9
0884:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0886:  MOVFF  5F,63
088A:  MOVFF  5E,62
088E:  MOVFF  5D,61
0892:  MOVFF  5C,60
....................       y+=(x/y); 
0896:  MOVFF  5B,69
089A:  MOVFF  5A,68
089E:  MOVFF  59,67
08A2:  MOVFF  58,66
08A6:  MOVFF  5F,6D
08AA:  MOVFF  5E,6C
08AE:  MOVFF  5D,6B
08B2:  MOVFF  5C,6A
08B6:  RCALL  03E8
08B8:  BCF    FD8.1
08BA:  MOVFF  5F,85
08BE:  MOVFF  5E,84
08C2:  MOVFF  5D,83
08C6:  MOVFF  5C,82
08CA:  MOVFF  03,89
08CE:  MOVFF  02,88
08D2:  MOVFF  01,87
08D6:  MOVFF  00,86
08DA:  RCALL  0542
08DC:  MOVFF  03,5F
08E0:  MOVFF  02,5E
08E4:  MOVFF  01,5D
08E8:  MOVFF  00,5C
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
08EC:  MOVFF  64,FE9
08F0:  MOVFF  65,FEA
08F4:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
08F6:  MOVFF  63,81
08FA:  MOVFF  62,80
08FE:  MOVFF  61,7F
0902:  MOVFF  60,7E
0906:  MOVFF  5F,85
090A:  MOVFF  5E,84
090E:  MOVFF  5D,83
0912:  MOVFF  5C,82
0916:  RCALL  07AC
0918:  BNZ   0886
....................  
....................    return(res); 
091A:  MOVFF  60,00
091E:  MOVFF  61,01
0922:  MOVFF  62,02
0926:  MOVFF  63,03
092A:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
0966:  CLRF   x63
0968:  CLRF   x62
096A:  CLRF   x61
096C:  MOVLW  7F
096E:  MOVWF  x60
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
0970:  MOVLW  7E
0972:  MOVWF  x6A
0974:  MOVLW  80
0976:  MOVWF  x6B
0978:  CLRF   x6C
097A:  CLRF   x6D
097C:  MOVLW  7A
097E:  MOVWF  x6E
0980:  MOVLW  2A
0982:  MOVWF  x6F
0984:  MOVLW  AA
0986:  MOVWF  x70
0988:  MOVLW  A3
098A:  MOVWF  x71
098C:  MOVLW  75
098E:  MOVWF  x72
0990:  MOVLW  B6
0992:  MOVWF  x73
0994:  MOVLW  09
0996:  MOVWF  x74
0998:  MOVLW  B4
099A:  MOVWF  x75
099C:  MOVLW  6F
099E:  MOVWF  x76
09A0:  MOVLW  4F
09A2:  MOVWF  x77
09A4:  MOVLW  B6
09A6:  MOVWF  x78
09A8:  MOVLW  AA
09AA:  MOVWF  x79
09AC:  MOVLW  69
09AE:  MOVWF  x7A
09B0:  MOVLW  8B
09B2:  MOVWF  x7B
09B4:  MOVLW  F6
09B6:  MOVWF  x7C
09B8:  MOVLW  E8
09BA:  MOVWF  x7D
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
09BC:  MOVFF  57,81
09C0:  MOVFF  56,80
09C4:  MOVFF  55,7F
09C8:  MOVFF  54,7E
09CC:  CLRF   x85
09CE:  CLRF   x84
09D0:  CLRF   x83
09D2:  CLRF   x82
09D4:  RCALL  07AC
09D6:  BNC   09DE
09D8:  MOVF   55,W
09DA:  XORLW  80
09DC:  MOVWF  55
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
09DE:  MOVFF  57,85
09E2:  MOVFF  56,84
09E6:  MOVFF  55,83
09EA:  MOVFF  54,82
09EE:  MOVLW  83
09F0:  MOVWF  x89
09F2:  MOVLW  F9
09F4:  MOVWF  x88
09F6:  MOVLW  22
09F8:  MOVWF  x87
09FA:  MOVLW  7E
09FC:  MOVWF  x86
09FE:  RCALL  02F6
0A00:  MOVFF  03,81
0A04:  MOVFF  02,80
0A08:  MOVFF  01,7F
0A0C:  MOVFF  00,7E
0A10:  BRA    092C
0A12:  MOVFF  01,64
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0A16:  MOVFF  57,85
0A1A:  MOVFF  56,84
0A1E:  MOVFF  55,83
0A22:  MOVFF  54,82
0A26:  MOVLW  83
0A28:  MOVWF  x89
0A2A:  MOVLW  F9
0A2C:  MOVWF  x88
0A2E:  MOVLW  22
0A30:  MOVWF  x87
0A32:  MOVLW  7E
0A34:  MOVWF  x86
0A36:  RCALL  02F6
0A38:  MOVFF  03,81
0A3C:  MOVFF  02,80
0A40:  MOVFF  01,7F
0A44:  MOVFF  00,7E
0A48:  CLRF   x83
0A4A:  MOVFF  64,82
0A4E:  RCALL  02C0
0A50:  BSF    FD8.1
0A52:  MOVFF  81,85
0A56:  MOVFF  80,84
0A5A:  MOVFF  7F,83
0A5E:  MOVFF  7E,82
0A62:  MOVFF  03,89
0A66:  MOVFF  02,88
0A6A:  MOVFF  01,87
0A6E:  MOVFF  00,86
0A72:  RCALL  0542
0A74:  MOVFF  03,69
0A78:  MOVFF  02,68
0A7C:  MOVFF  01,67
0A80:  MOVFF  00,66
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0A84:  MOVLW  03
0A86:  ANDWF  x64,F
....................  
....................    if (quad == 0 || quad == 2) 
0A88:  MOVF   x64,F
0A8A:  BZ    0A92
0A8C:  MOVF   x64,W
0A8E:  SUBLW  02
0A90:  BNZ   0AC6
....................       t = frac * PI_DIV_BY_TWO; 
0A92:  MOVFF  69,85
0A96:  MOVFF  68,84
0A9A:  MOVFF  67,83
0A9E:  MOVFF  66,82
0AA2:  MOVLW  DB
0AA4:  MOVWF  x89
0AA6:  MOVLW  0F
0AA8:  MOVWF  x88
0AAA:  MOVLW  49
0AAC:  MOVWF  x87
0AAE:  MOVLW  7F
0AB0:  MOVWF  x86
0AB2:  RCALL  02F6
0AB4:  MOVFF  03,5F
0AB8:  MOVFF  02,5E
0ABC:  MOVFF  01,5D
0AC0:  MOVFF  00,5C
0AC4:  BRA    0B90
....................    else if (quad == 1) 
0AC6:  DECFSZ x64,W
0AC8:  BRA    0B2E
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0ACA:  BSF    FD8.1
0ACC:  CLRF   x85
0ACE:  CLRF   x84
0AD0:  CLRF   x83
0AD2:  MOVLW  7F
0AD4:  MOVWF  x82
0AD6:  MOVFF  69,89
0ADA:  MOVFF  68,88
0ADE:  MOVFF  67,87
0AE2:  MOVFF  66,86
0AE6:  RCALL  0542
0AE8:  MOVFF  03,81
0AEC:  MOVFF  02,80
0AF0:  MOVFF  01,7F
0AF4:  MOVFF  00,7E
0AF8:  MOVFF  03,85
0AFC:  MOVFF  02,84
0B00:  MOVFF  01,83
0B04:  MOVFF  00,82
0B08:  MOVLW  DB
0B0A:  MOVWF  x89
0B0C:  MOVLW  0F
0B0E:  MOVWF  x88
0B10:  MOVLW  49
0B12:  MOVWF  x87
0B14:  MOVLW  7F
0B16:  MOVWF  x86
0B18:  CALL   02F6
0B1C:  MOVFF  03,5F
0B20:  MOVFF  02,5E
0B24:  MOVFF  01,5D
0B28:  MOVFF  00,5C
0B2C:  BRA    0B90
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0B2E:  BSF    FD8.1
0B30:  MOVFF  69,85
0B34:  MOVFF  68,84
0B38:  MOVFF  67,83
0B3C:  MOVFF  66,82
0B40:  CLRF   x89
0B42:  CLRF   x88
0B44:  CLRF   x87
0B46:  MOVLW  7F
0B48:  MOVWF  x86
0B4A:  RCALL  0542
0B4C:  MOVFF  03,81
0B50:  MOVFF  02,80
0B54:  MOVFF  01,7F
0B58:  MOVFF  00,7E
0B5C:  MOVFF  03,85
0B60:  MOVFF  02,84
0B64:  MOVFF  01,83
0B68:  MOVFF  00,82
0B6C:  MOVLW  DB
0B6E:  MOVWF  x89
0B70:  MOVLW  0F
0B72:  MOVWF  x88
0B74:  MOVLW  49
0B76:  MOVWF  x87
0B78:  MOVLW  7F
0B7A:  MOVWF  x86
0B7C:  CALL   02F6
0B80:  MOVFF  03,5F
0B84:  MOVFF  02,5E
0B88:  MOVFF  01,5D
0B8C:  MOVFF  00,5C
....................  
....................    y = 1.0; 
0B90:  CLRF   5B
0B92:  CLRF   5A
0B94:  CLRF   59
0B96:  MOVLW  7F
0B98:  MOVWF  58
....................    t = t * t; 
0B9A:  MOVFF  5F,85
0B9E:  MOVFF  5E,84
0BA2:  MOVFF  5D,83
0BA6:  MOVFF  5C,82
0BAA:  MOVFF  5F,89
0BAE:  MOVFF  5E,88
0BB2:  MOVFF  5D,87
0BB6:  MOVFF  5C,86
0BBA:  CALL   02F6
0BBE:  MOVFF  03,5F
0BC2:  MOVFF  02,5E
0BC6:  MOVFF  01,5D
0BCA:  MOVFF  00,5C
....................    for (i = 0; i <= 4; i++) 
0BCE:  CLRF   x65
0BD0:  MOVF   x65,W
0BD2:  SUBLW  04
0BD4:  BNC   0C88
....................    { 
....................       t2 = t2 * t; 
0BD6:  MOVFF  63,85
0BDA:  MOVFF  62,84
0BDE:  MOVFF  61,83
0BE2:  MOVFF  60,82
0BE6:  MOVFF  5F,89
0BEA:  MOVFF  5E,88
0BEE:  MOVFF  5D,87
0BF2:  MOVFF  5C,86
0BF6:  CALL   02F6
0BFA:  MOVFF  03,63
0BFE:  MOVFF  02,62
0C02:  MOVFF  01,61
0C06:  MOVFF  00,60
....................       y = y + p[i] * t2; 
0C0A:  MOVF   x65,W
0C0C:  MULLW  04
0C0E:  MOVF   FF3,W
0C10:  CLRF   03
0C12:  ADDLW  6A
0C14:  MOVWF  FE9
0C16:  MOVLW  00
0C18:  ADDWFC 03,W
0C1A:  MOVWF  FEA
0C1C:  MOVFF  FEF,82
0C20:  MOVFF  FEC,83
0C24:  MOVFF  FEC,84
0C28:  MOVFF  FEC,85
0C2C:  MOVFF  63,89
0C30:  MOVFF  62,88
0C34:  MOVFF  61,87
0C38:  MOVFF  60,86
0C3C:  CALL   02F6
0C40:  MOVFF  FEA,7F
0C44:  MOVFF  FE9,7E
0C48:  BCF    FD8.1
0C4A:  MOVFF  5B,85
0C4E:  MOVFF  5A,84
0C52:  MOVFF  59,83
0C56:  MOVFF  58,82
0C5A:  MOVFF  03,89
0C5E:  MOVFF  02,88
0C62:  MOVFF  01,87
0C66:  MOVFF  00,86
0C6A:  RCALL  0542
0C6C:  MOVFF  7F,FEA
0C70:  MOVFF  7E,FE9
0C74:  MOVFF  03,5B
0C78:  MOVFF  02,5A
0C7C:  MOVFF  01,59
0C80:  MOVFF  00,58
0C84:  INCF   x65,F
0C86:  BRA    0BD0
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
0C88:  MOVF   x64,W
0C8A:  SUBLW  02
0C8C:  BZ    0C92
0C8E:  DECFSZ x64,W
0C90:  BRA    0C98
....................       y = -y;  // correct sign 
0C92:  MOVF   59,W
0C94:  XORLW  80
0C96:  MOVWF  59
....................  
....................    return (y); 
0C98:  MOVFF  58,00
0C9C:  MOVFF  59,01
0CA0:  MOVFF  5A,02
0CA4:  MOVFF  5B,03
0CA8:  GOTO   1526 (RETURN)
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "funciones.h" 
.................... /** 
.................... *	\file funciones.h 
.................... *	\brief Resumen del archivo 
.................... *	\details Descripcion detallada del archivo 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
.................... #include <i2c_Flex_LCD.h> 
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.0 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD dispay 
.................... //     \1 Set write position on LCD Line 1 
.................... //     \2 Set write position on LCD Line 2 
.................... //     \3 Set write position on LCD Line 3 
.................... //     \4 Set write position on LCD Line 4 
.................... // 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with 
.................... //              an EXPANDER of I/O with connection I2C. The tests of these 
.................... //              routines have been programmed using the IC PCF8574T of Phillips. 
.................... //              I used 4 bits mode programming. The 8 bits mode programming 
.................... //              is possible if you use 2 x PCF8574T. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... //For PCF8574T the addressing is: 
....................  
.................... //Jp3 Jp2 Jp1 
.................... //A2 A1 A0  Hex 
.................... //L L L  0x40 
.................... //L L H  0x42 
.................... //L H L  0x44 
.................... //L H H  0x46 
.................... //H L L  0x48 
.................... //H L H  0x4A 
.................... //H H L  0x4C 
.................... //H H H  0x4E 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define LCD_ADDR       0x4E //I2C slave address for LCD module 
....................  
.................... #define ON             1 
.................... #define OFF            0 
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1 
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2 
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3 
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4 
....................   
.................... byte address; 
.................... int1 lcd_backlight=ON; 
....................  
.................... void i2c_lcd_backlight_On(){ 
....................       lcd_backlight=ON; 
.................... } 
....................  
.................... void i2c_lcd_backlight_Off(){ 
....................       lcd_backlight=OFF; 
.................... } 
....................  
.................... void i2c_send_nibble(unsigned char data) 
....................    {    
....................         i2c_start(); 
*
0D18:  BSF    F95.6
0D1A:  MOVLW  11
0D1C:  MOVWF  00
0D1E:  DECFSZ 00,F
0D20:  BRA    0D1E
0D22:  BSF    F95.7
0D24:  MOVLW  11
0D26:  MOVWF  00
0D28:  DECFSZ 00,F
0D2A:  BRA    0D28
0D2C:  BCF    F8C.6
0D2E:  BCF    F95.6
0D30:  MOVLW  11
0D32:  MOVWF  00
0D34:  DECFSZ 00,F
0D36:  BRA    0D34
0D38:  BCF    F8C.7
0D3A:  BCF    F95.7
....................         delay_us(20); 
0D3C:  MOVLW  4F
0D3E:  MOVWF  00
0D40:  DECFSZ 00,F
0D42:  BRA    0D40
0D44:  BRA    0D46
....................         i2c_write(LCD_ADDR); //the slave addresse 
0D46:  MOVLW  4E
0D48:  MOVWF  x67
0D4A:  RCALL  0CAC
....................         delay_us(20); 
0D4C:  MOVLW  4F
0D4E:  MOVWF  00
0D50:  DECFSZ 00,F
0D52:  BRA    0D50
0D54:  BRA    0D56
....................         i2c_write(data); 
0D56:  MOVFF  66,67
0D5A:  RCALL  0CAC
....................         delay_us(20); 
0D5C:  MOVLW  4F
0D5E:  MOVWF  00
0D60:  DECFSZ 00,F
0D62:  BRA    0D60
0D64:  BRA    0D66
....................         i2c_stop(); 
0D66:  BCF    F95.6
0D68:  NOP   
0D6A:  BSF    F95.7
0D6C:  BTFSS  F83.7
0D6E:  BRA    0D6C
0D70:  MOVLW  11
0D72:  MOVWF  00
0D74:  DECFSZ 00,F
0D76:  BRA    0D74
0D78:  BRA    0D7A
0D7A:  NOP   
0D7C:  BSF    F95.6
0D7E:  MOVLW  11
0D80:  MOVWF  00
0D82:  DECFSZ 00,F
0D84:  BRA    0D82
....................         delay_us(20); 
0D86:  MOVLW  4F
0D88:  MOVWF  00
0D8A:  DECFSZ 00,F
0D8C:  BRA    0D8A
0D8E:  BRA    0D90
0D90:  RETURN 0
....................    } 
....................  
.................... void lcd_send_byte(unsigned char data) 
....................    { 
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN 
0D92:  BTFSS  20.0
0D94:  BRA    0DA0
0D96:  MOVF   x65,W
0D98:  IORLW  04
0D9A:  IORLW  08
0D9C:  MOVWF  x65
0D9E:  BRA    0DA2
0DA0:  BSF    x65.2
....................         i2c_send_nibble(data); 
0DA2:  MOVFF  65,66
0DA6:  RCALL  0D18
....................         data=data-4;       //toggle EN back to 0 
0DA8:  MOVLW  04
0DAA:  SUBWF  x65,F
....................         i2c_send_nibble(data); 
0DAC:  MOVFF  65,66
0DB0:  RCALL  0D18
0DB2:  RETURN 0
....................    } 
....................     
.................... void lcd_clear() 
.................... { 
....................     lcd_send_byte(0x00); 
*
0E32:  CLRF   x65
0E34:  RCALL  0D92
....................     lcd_send_byte(0x10); 
0E36:  MOVLW  10
0E38:  MOVWF  x65
0E3A:  RCALL  0D92
....................     delay_ms(2); 
0E3C:  MOVLW  02
0E3E:  MOVWF  x63
0E40:  RCALL  0E0A
0E42:  GOTO   0EB2 (RETURN)
.................... } 
....................  
.................... void lcd_init() 
.................... { 
....................     delay_ms(200); //LCD power up delay 
....................         
....................    //Request works on the command by set the RS = 0 R/W = 0 write 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x10); 
....................            //First state in 8 bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x30); 
....................            //Then set to 4-bit mode 
....................         lcd_send_byte(0x30); 
....................         lcd_send_byte(0x20); 
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h) 
....................         lcd_send_byte(0x20); 
....................         lcd_send_byte(0x80); 
....................            //no need cursor on (0Ch) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0xC0); 
....................            //the cursor moves to the left (06 h) 
....................         lcd_send_byte(0x00); 
....................         lcd_send_byte(0x60); 
....................            //clears the display 
....................         lcd_clear(); 
.................... } 
....................  
.................... void lcd_gotoxy( byte x, byte y) 
.................... {      
.................... static char data; 
....................       
....................    switch(y) 
*
0DB4:  MOVF   x64,W
0DB6:  XORLW  01
0DB8:  BZ    0DC8
0DBA:  XORLW  03
0DBC:  BZ    0DCE
0DBE:  XORLW  01
0DC0:  BZ    0DD4
0DC2:  XORLW  07
0DC4:  BZ    0DDA
0DC6:  BRA    0DE0
....................    { 
....................       case 1:  address= lcd_line_one;     break; 
0DC8:  MOVLW  80
0DCA:  MOVWF  1F
0DCC:  BRA    0DE4
....................       case 2:  address= lcd_line_two;     break; 
0DCE:  MOVLW  C0
0DD0:  MOVWF  1F
0DD2:  BRA    0DE4
....................       case 3:  address= lcd_line_three;   break; 
0DD4:  MOVLW  94
0DD6:  MOVWF  1F
0DD8:  BRA    0DE4
....................       case 4:  address= lcd_line_four;    break; 
0DDA:  MOVLW  D4
0DDC:  MOVWF  1F
0DDE:  BRA    0DE4
....................       default: address= lcd_line_one;     break;  
0DE0:  MOVLW  80
0DE2:  MOVWF  1F
....................    } 
....................   
....................    address+=x-1; 
0DE4:  MOVLW  01
0DE6:  SUBWF  x63,W
0DE8:  ADDWF  1F,F
....................    data=address&0xF0; 
0DEA:  MOVF   1F,W
0DEC:  ANDLW  F0
0DEE:  MOVWF  24
....................    lcd_send_byte(data); 
0DF0:  MOVFF  24,65
0DF4:  RCALL  0D92
....................    data=address&0x0F; 
0DF6:  MOVF   1F,W
0DF8:  ANDLW  0F
0DFA:  MOVWF  24
....................    data=data<<4; 
0DFC:  SWAPF  24,F
0DFE:  MOVLW  F0
0E00:  ANDWF  24,F
....................    lcd_send_byte(data); 
0E02:  MOVFF  24,65
0E06:  RCALL  0D92
0E08:  RETURN 0
.................... } 
....................  
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... { 
....................  char data;      
....................   switch(in_data) 
*
0E46:  MOVF   x62,W
0E48:  XORLW  0C
0E4A:  BZ    0E5E
0E4C:  XORLW  0D
0E4E:  BZ    0E62
0E50:  XORLW  03
0E52:  BZ    0E6C
0E54:  XORLW  01
0E56:  BZ    0E78
0E58:  XORLW  07
0E5A:  BZ    0E84
0E5C:  BRA    0E90
....................    {  
....................      case '\f': lcd_clear()    ;  break;                
0E5E:  BRA    0E32
0E60:  BRA    0EB2
....................      case '\1': lcd_gotoxy(1,1);  break; 
0E62:  MOVLW  01
0E64:  MOVWF  x63
0E66:  MOVWF  x64
0E68:  RCALL  0DB4
0E6A:  BRA    0EB2
....................      case '\2': lcd_gotoxy(1,2);  break; 
0E6C:  MOVLW  01
0E6E:  MOVWF  x63
0E70:  MOVLW  02
0E72:  MOVWF  x64
0E74:  RCALL  0DB4
0E76:  BRA    0EB2
....................      case '\3': lcd_gotoxy(1,3);  break; 
0E78:  MOVLW  01
0E7A:  MOVWF  x63
0E7C:  MOVLW  03
0E7E:  MOVWF  x64
0E80:  RCALL  0DB4
0E82:  BRA    0EB2
....................      case '\4': lcd_gotoxy(1,4);  break; 
0E84:  MOVLW  01
0E86:  MOVWF  x63
0E88:  MOVLW  04
0E8A:  MOVWF  x64
0E8C:  RCALL  0DB4
0E8E:  BRA    0EB2
....................  
....................      default: 
....................         data=in_data&0xF0; 
0E90:  MOVF   x62,W
0E92:  ANDLW  F0
0E94:  MOVWF  x63
....................         data=data|RS; //set RS pin to 1 
0E96:  BSF    x63.0
....................         lcd_send_byte(data); 
0E98:  MOVFF  63,65
0E9C:  RCALL  0D92
....................         data=in_data&0x0F; 
0E9E:  MOVF   x62,W
0EA0:  ANDLW  0F
0EA2:  MOVWF  x63
....................         data=data<<4; 
0EA4:  SWAPF  x63,F
0EA6:  MOVLW  F0
0EA8:  ANDWF  x63,F
....................         data=data|RS; //set RS pin to 1 
0EAA:  BSF    x63.0
....................         lcd_send_byte(data); 
0EAC:  MOVFF  63,65
0EB0:  RCALL  0D92
....................      break; 
....................    } 
0EB2:  RETURN 0
.................... }  
....................  
....................  
....................  
.................... #ifndef FUNCIONES_H 
.................... #define FUNCIONES_H 
.................... //Declaracion de estados 
....................  
.................... #define 	PUNTO_TENS_CORR	0 
.................... #define 	CONVERSION_DESFASE	1 
.................... #define 	TENS_CORR_RMS	2 
.................... #define 	CALCULO_POT_ENER	3 
.................... #define 	MOSTRAR_DATOS	4 
....................  
.................... //Prototipos de los eventos 
.................... void maquina_estado(void); 
....................  
.................... #endif 
....................  
.................... #include <Control_ADCs.h> 
.................... /*  
....................  * File:   MAX191.h 
....................  * Author: MARCOS 
....................  * 
....................  * Created on 23 de septiembre de 2016, 08:14 
....................  */ 
....................  
.................... #ifndef Control_ADCs_H 
.................... #define Control_ADCs_H 
....................  
.................... #define ADC_CSCorriente PIN_A0  // salida 
.................... #define ADC_CSTension PIN_A1 // salida 
.................... #define ADC_SCLK PIN_A2 // salida clock tension 
.................... #define ADC_SCLKcorr PIN_B1 
.................... #define ADC_DOUT PIN_B0  // entrada, por aqui ingresa la info del MAX186 
.................... #define ADC_DIN PIN_A4 //salida, se envia la informacion al MAX186 
.................... #define ADC_SSTRB PIN_A5//entrada 
.................... #define ADC_SDATA PIN_A3//entrada SDATA en AD7450 
....................  
.................... //control AD7450 
.................... signed long leer_Tension(){ 
*
0100:  CLRF   55
0102:  CLRF   54
....................     signed long dato=0,dato_t; 
....................     int i; 
....................     output_low (ADC_CSTension); 
0104:  BCF    F92.1
0106:  BCF    F89.1
....................     delay_us(1); 
0108:  MOVLW  03
010A:  MOVWF  00
010C:  DECFSZ 00,F
010E:  BRA    010C
0110:  BRA    0112
....................     output_low (ADC_SCLK); 
0112:  BCF    F92.2
0114:  BCF    F89.2
....................     delay_us(1); 
0116:  MOVLW  03
0118:  MOVWF  00
011A:  DECFSZ 00,F
011C:  BRA    011A
011E:  BRA    0120
....................     output_high (ADC_SCLK); 
0120:  BCF    F92.2
0122:  BSF    F89.2
....................     delay_us(1); 
0124:  MOVLW  03
0126:  MOVWF  00
0128:  DECFSZ 00,F
012A:  BRA    0128
012C:  BRA    012E
....................      
....................         for(i=0;i<15;i++){ 
012E:  CLRF   58
0130:  MOVF   58,W
0132:  SUBLW  0E
0134:  BNC   0166
....................           shift_left(&dato,2,input(ADC_SDATA)); 
0136:  BSF    F92.3
0138:  BTFSC  F80.3
013A:  BRA    0140
013C:  BCF    FD8.0
013E:  BRA    0142
0140:  BSF    FD8.0
0142:  RLCF   54,F
0144:  RLCF   55,F
....................           output_low(ADC_SCLK); 
0146:  BCF    F92.2
0148:  BCF    F89.2
....................           delay_us(1);  
014A:  MOVLW  03
014C:  MOVWF  00
014E:  DECFSZ 00,F
0150:  BRA    014E
0152:  BRA    0154
....................           output_high(ADC_SCLK);  
0154:  BCF    F92.2
0156:  BSF    F89.2
....................           delay_us(1); 
0158:  MOVLW  03
015A:  MOVWF  00
015C:  DECFSZ 00,F
015E:  BRA    015C
0160:  BRA    0162
0162:  INCF   58,F
0164:  BRA    0130
....................         } 
....................  
....................        // output_high (ADC_SCLK); 
....................        // delay_us(1); 
....................         output_high (ADC_CSTension); 
0166:  BCF    F92.1
0168:  BSF    F89.1
....................          
....................        dato_t=(dato&0x0800); 
016A:  CLRF   56
016C:  MOVF   55,W
016E:  ANDLW  08
0170:  MOVWF  57
....................          
....................       if (dato_t==0x0800){ 
0172:  MOVF   56,F
0174:  BNZ   0190
0176:  MOVF   57,W
0178:  SUBLW  08
017A:  BNZ   0190
....................             dato=-2048+(dato&0xF7FF); 
017C:  MOVFF  54,00
0180:  MOVF   55,W
0182:  ANDLW  F7
0184:  MOVWF  03
0186:  MOVFF  54,54
018A:  MOVLW  F8
018C:  ADDWF  03,W
018E:  MOVWF  55
....................       } 
....................     return(dato); 
0190:  MOVFF  54,01
0194:  MOVFF  55,02
0198:  GOTO   113C (RETURN)
.................... } 
....................  
.................... //control MAX186 
.................... long leer_Corriente(){ 
019C:  CLRF   55
019E:  CLRF   54
01A0:  MOVLW  8E
01A2:  MOVWF  56
....................     long dato=0; 
....................     BYTE config= 0b10001110; 
....................     int i; 
....................     output_low (ADC_CSCorriente); 
01A4:  BCF    F92.0
01A6:  BCF    F89.0
....................     output_low (ADC_DIN); 
01A8:  BCF    F92.4
01AA:  BCF    F89.4
....................     delay_us(1); 
01AC:  MOVLW  03
01AE:  MOVWF  00
01B0:  DECFSZ 00,F
01B2:  BRA    01B0
01B4:  BRA    01B6
....................      
....................     for(i=0; i<8; i++) { 
01B6:  CLRF   57
01B8:  MOVF   57,W
01BA:  SUBLW  07
01BC:  BNC   01EC
....................       output_bit(ADC_DIN, shift_left(&config,1,0)); 
01BE:  BCF    FD8.0
01C0:  RLCF   56,F
01C2:  BC    01C8
01C4:  BCF    F89.4
01C6:  BRA    01CA
01C8:  BSF    F89.4
01CA:  BCF    F92.4
....................       output_high(ADC_SCLKcorr); 
01CC:  BCF    F93.1
01CE:  BSF    F8A.1
....................       delay_us(1); 
01D0:  MOVLW  03
01D2:  MOVWF  00
01D4:  DECFSZ 00,F
01D6:  BRA    01D4
01D8:  BRA    01DA
....................       output_low(ADC_SCLKcorr);	 
01DA:  BCF    F93.1
01DC:  BCF    F8A.1
....................       delay_us(1); 
01DE:  MOVLW  03
01E0:  MOVWF  00
01E2:  DECFSZ 00,F
01E4:  BRA    01E2
01E6:  BRA    01E8
01E8:  INCF   57,F
01EA:  BRA    01B8
....................    } 
....................  
....................     output_high(ADC_CSCorriente); 
01EC:  BCF    F92.0
01EE:  BSF    F89.0
....................      
....................     while(input(ADC_SSTRB)=='0');    
....................          
....................         output_low (ADC_CSCorriente); 
01F0:  BCF    F92.0
01F2:  BCF    F89.0
....................         output_high (ADC_SCLKcorr); 
01F4:  BCF    F93.1
01F6:  BSF    F8A.1
....................         delay_us(1); 
01F8:  MOVLW  03
01FA:  MOVWF  00
01FC:  DECFSZ 00,F
01FE:  BRA    01FC
0200:  BRA    0202
....................         output_low (ADC_SCLKcorr); 
0202:  BCF    F93.1
0204:  BCF    F8A.1
....................         delay_us(1); 
0206:  MOVLW  03
0208:  MOVWF  00
020A:  DECFSZ 00,F
020C:  BRA    020A
020E:  BRA    0210
....................          
....................         for(i=0;i<15;i++){ 
0210:  CLRF   57
0212:  MOVF   57,W
0214:  SUBLW  0E
0216:  BNC   0248
....................           output_high(ADC_SCLKcorr); 
0218:  BCF    F93.1
021A:  BSF    F8A.1
....................           delay_us(1); 
021C:  MOVLW  03
021E:  MOVWF  00
0220:  DECFSZ 00,F
0222:  BRA    0220
0224:  BRA    0226
....................           shift_left(&dato,2,input(ADC_DOUT));  
0226:  BSF    F93.0
0228:  BTFSC  F81.0
022A:  BRA    0230
022C:  BCF    FD8.0
022E:  BRA    0232
0230:  BSF    FD8.0
0232:  RLCF   54,F
0234:  RLCF   55,F
....................           output_low(ADC_SCLKcorr); 
0236:  BCF    F93.1
0238:  BCF    F8A.1
....................           delay_us(1); 
023A:  MOVLW  03
023C:  MOVWF  00
023E:  DECFSZ 00,F
0240:  BRA    023E
0242:  BRA    0244
0244:  INCF   57,F
0246:  BRA    0212
....................         } 
....................   
....................          
....................         output_high (ADC_CSCorriente); 
0248:  BCF    F92.0
024A:  BSF    F89.0
....................      
....................        
....................     dato= (dato>>3)& 0x0FFF; 
024C:  RRCF   55,W
024E:  MOVWF  59
0250:  RRCF   54,W
0252:  MOVWF  58
0254:  RRCF   59,F
0256:  RRCF   58,F
0258:  RRCF   59,F
025A:  RRCF   58,F
025C:  MOVLW  1F
025E:  ANDWF  59,F
0260:  MOVFF  58,54
0264:  MOVF   59,W
0266:  ANDLW  0F
0268:  MOVWF  55
....................     return(dato); 
026A:  MOVFF  54,01
026E:  MOVFF  55,02
0272:  GOTO   1148 (RETURN)
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //Implementacion Switch-Case 
....................  
.................... /** 
.................... *	\fn void maquina_estado() 
.................... *	\brief Implementacion Switch-Case 
.................... *	\details  
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
....................  **/ 
.................... signed long punto1; 
.................... long punto2; 
.................... int16 tiempo_potencia; 
.................... BYTE pos_V,pos_I,pos_V_A,pos_I_A; 
.................... int control_V; 
.................... int control_I; 
.................... int desfase; 
.................... int puntos=20;//puntos por periodo 
.................... float tension, corriente, tension_RMS,corriente_RMS, t_desfase, potencia_ins,angulo; 
.................... float Energia_Wms; 
....................  
.................... const long carga= 0xE8AB; 
....................  
.................... #INT_TIMER1               // interrupcion para demora de 1 ms 
.................... void interrtimer_1(){ 
....................     set_timer1(carga);   // interrupcion cada 1 ms 
*
00AE:  MOVLW  E8
00B0:  MOVWF  FCF
00B2:  MOVLW  AB
00B4:  MOVWF  FCE
....................     pulso_timer++; 
00B6:  INCF   23,F
....................  
00B8:  BCF    F9E.0
00BA:  GOTO   0060
....................    } 
....................  
.................... void maquina_estado() 
.................... { 
.................... 		static int estado = PUNTO_TENS_CORR; 
....................  
.................... 		switch(estado) 
*
111A:  MOVF   53,W
111C:  XORLW  00
111E:  BZ    1138
1120:  XORLW  01
1122:  BZ    1190
1124:  XORLW  03
1126:  BTFSC  FD8.2
1128:  BRA    130A
112A:  XORLW  01
112C:  BTFSC  FD8.2
112E:  BRA    13DC
1130:  XORLW  07
1132:  BTFSC  FD8.2
1134:  BRA    1634
1136:  BRA    171A
.................... 		{ 
.................... 			case PUNTO_TENS_CORR: 
....................                 punto1= leer_Tension(); 
1138:  GOTO   0100
113C:  MOVFF  02,26
1140:  MOVFF  01,25
....................                 punto2= leer_Corriente(); // comprobar si funciona con el tiempo de demora de la lectura del externo 
1144:  GOTO   019C
1148:  MOVFF  02,28
114C:  MOVFF  01,27
....................                 // convierte los valores de long a float 
....................                 tension=punto1; 
1150:  MOVFF  26,55
1154:  MOVFF  25,54
1158:  GOTO   0276
115C:  MOVFF  03,36
1160:  MOVFF  02,35
1164:  MOVFF  01,34
1168:  MOVFF  00,33
....................                 corriente=punto2; 
116C:  MOVFF  28,83
1170:  MOVFF  27,82
1174:  CALL   02C0
1178:  MOVFF  03,3A
117C:  MOVFF  02,39
1180:  MOVFF  01,38
1184:  MOVFF  00,37
....................                 contador++; 
1188:  INCF   22,F
.................... 					estado = CONVERSION_DESFASE; 
118A:  MOVLW  01
118C:  MOVWF  53
....................  
.................... 				break; 
118E:  BRA    171C
.................... 			 
.................... 			case CONVERSION_DESFASE: 
....................                 tension= (tension)*2.5/2048; 
1190:  MOVFF  36,85
1194:  MOVFF  35,84
1198:  MOVFF  34,83
119C:  MOVFF  33,82
11A0:  CLRF   x89
11A2:  CLRF   x88
11A4:  MOVLW  20
11A6:  MOVWF  x87
11A8:  MOVLW  80
11AA:  MOVWF  x86
11AC:  CALL   02F6
11B0:  MOVFF  03,57
11B4:  MOVFF  02,56
11B8:  MOVFF  01,55
11BC:  MOVFF  00,54
11C0:  MOVFF  03,69
11C4:  MOVFF  02,68
11C8:  MOVFF  01,67
11CC:  MOVFF  00,66
11D0:  CLRF   x6D
11D2:  CLRF   x6C
11D4:  CLRF   x6B
11D6:  MOVLW  8A
11D8:  MOVWF  x6A
11DA:  CALL   03E8
11DE:  MOVFF  03,36
11E2:  MOVFF  02,35
11E6:  MOVFF  01,34
11EA:  MOVFF  00,33
....................                 corriente= (corriente)/1000-2.510; 
11EE:  MOVFF  3A,69
11F2:  MOVFF  39,68
11F6:  MOVFF  38,67
11FA:  MOVFF  37,66
11FE:  CLRF   x6D
1200:  CLRF   x6C
1202:  MOVLW  7A
1204:  MOVWF  x6B
1206:  MOVLW  88
1208:  MOVWF  x6A
120A:  CALL   03E8
120E:  MOVFF  03,57
1212:  MOVFF  02,56
1216:  MOVFF  01,55
121A:  MOVFF  00,54
121E:  BSF    FD8.1
1220:  MOVFF  03,85
1224:  MOVFF  02,84
1228:  MOVFF  01,83
122C:  MOVFF  00,82
1230:  MOVLW  D7
1232:  MOVWF  x89
1234:  MOVLW  A3
1236:  MOVWF  x88
1238:  MOVLW  20
123A:  MOVWF  x87
123C:  MOVLW  80
123E:  MOVWF  x86
1240:  CALL   0542
1244:  MOVFF  03,3A
1248:  MOVFF  02,39
124C:  MOVFF  01,38
1250:  MOVFF  00,37
....................                 //se convierte a la tension y corriente real 
....................                 tension= tension*155.57; // conversion con 2 V igual a 311.13 V 
1254:  MOVFF  36,85
1258:  MOVFF  35,84
125C:  MOVFF  34,83
1260:  MOVFF  33,82
1264:  MOVLW  EC
1266:  MOVWF  x89
1268:  MOVLW  91
126A:  MOVWF  x88
126C:  MOVLW  1B
126E:  MOVWF  x87
1270:  MOVLW  86
1272:  MOVWF  x86
1274:  CALL   02F6
1278:  MOVFF  03,36
127C:  MOVFF  02,35
1280:  MOVFF  01,34
1284:  MOVFF  00,33
....................                 corriente= corriente*12; // 2.5 V es igual a +30 A (recordar que el sensor mide ±30A) 
1288:  MOVFF  3A,85
128C:  MOVFF  39,84
1290:  MOVFF  38,83
1294:  MOVFF  37,82
1298:  CLRF   x89
129A:  CLRF   x88
129C:  MOVLW  40
129E:  MOVWF  x87
12A0:  MOVLW  82
12A2:  MOVWF  x86
12A4:  CALL   02F6
12A8:  MOVFF  03,3A
12AC:  MOVFF  02,39
12B0:  MOVFF  01,38
12B4:  MOVFF  00,37
....................                  
....................                 // Analisis del punto POSITVO O NEGATIVO 
....................                 // valor positivo estado=0-- valor negativo estado=1 
....................                  
....................                 //TENSION 
....................                 #asm 
....................                 clrf &pos_V; 
12B8:  CLRF   2B
....................                 btfsc (&tension + 0x01), 7; 
12BA:  BTFSC  34.7
....................                 bsf &pos_V,0; 
12BC:  BSF    2B.0
....................                 #endasm 
.................... 				 
....................                 //CORRIENTE 
....................                 #asm 
....................                 clrf &pos_I; 
12BE:  CLRF   2C
....................                 btfsc (&corriente + 0x01), 7; // comprueba signo en un bit de los 4 byte del float 
12C0:  BTFSC  38.7
....................                 bsf &pos_I,0; 
12C2:  BSF    2C.0
....................                 #endasm 
....................  
....................                  
....................                  
.................... 				 
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contador distinto de cero) 
....................                 if (pos_V==1 && contador>=2 && pos_V_A==0 && desfase!=1){  
12C4:  DECFSZ 2B,W
12C6:  BRA    12E0
12C8:  MOVF   22,W
12CA:  SUBLW  01
12CC:  BC    12E0
12CE:  MOVF   2D,F
12D0:  BNZ   12E0
12D2:  DECFSZ 31,W
12D4:  BRA    12D8
12D6:  BRA    12E0
....................                  control_V= contador; // tiempo en el que cruzó la tension  
12D8:  MOVFF  22,2F
....................                  desfase=1; 
12DC:  MOVLW  01
12DE:  MOVWF  31
....................                 } 
....................                  
....................                 // si el punto actual de tension es positivo, el anterior es negativo  
....................                 //y se tiene mas de un punto (contaodr distinto de cero) 
....................                 if (pos_I==1 && contador>=2 && pos_I_A==0 && desfase!=2){ 
12E0:  DECFSZ 2C,W
12E2:  BRA    12FC
12E4:  MOVF   22,W
12E6:  SUBLW  01
12E8:  BC    12FC
12EA:  MOVF   2E,F
12EC:  BNZ   12FC
12EE:  MOVF   31,W
12F0:  SUBLW  02
12F2:  BZ    12FC
....................                      
....................                  control_I= contador; // tiempo en el que cruzó la corriente 
12F4:  MOVFF  22,30
....................                  desfase=2; 
12F8:  MOVLW  02
12FA:  MOVWF  31
....................                 } 
....................                 // guarda el signo de los puntos anteriores 
....................                 pos_V_A=pos_V; 
12FC:  MOVFF  2B,2D
....................                 pos_I_A=pos_I; 
1300:  MOVFF  2C,2E
....................                  
....................                  
.................... 					estado = TENS_CORR_RMS; 
1304:  MOVLW  02
1306:  MOVWF  53
.................... 		 
.................... 				 
....................  
.................... 				break; 
1308:  BRA    171C
.................... //---------------------------------------------------------------------------------------------------- 
....................                  
.................... 			case TENS_CORR_RMS: 
.................... 			 
.................... 				if((contador<30)&& (pulso_timer==1)) 
130A:  MOVF   22,W
130C:  SUBLW  1D
130E:  BNC   13DA
1310:  DECFSZ 23,W
1312:  BRA    13DA
.................... 				{ 
.................... 					tension_RMS=tension_RMS+ tension * tension;       //calcula tension eficaz 
1314:  MOVFF  36,85
1318:  MOVFF  35,84
131C:  MOVFF  34,83
1320:  MOVFF  33,82
1324:  MOVFF  36,89
1328:  MOVFF  35,88
132C:  MOVFF  34,87
1330:  MOVFF  33,86
1334:  CALL   02F6
1338:  BCF    FD8.1
133A:  MOVFF  3E,85
133E:  MOVFF  3D,84
1342:  MOVFF  3C,83
1346:  MOVFF  3B,82
134A:  MOVFF  03,89
134E:  MOVFF  02,88
1352:  MOVFF  01,87
1356:  MOVFF  00,86
135A:  CALL   0542
135E:  MOVFF  03,3E
1362:  MOVFF  02,3D
1366:  MOVFF  01,3C
136A:  MOVFF  00,3B
....................                     corriente_RMS= corriente_RMS+ corriente * corriente; // calcula corriente eficaz 
136E:  MOVFF  3A,85
1372:  MOVFF  39,84
1376:  MOVFF  38,83
137A:  MOVFF  37,82
137E:  MOVFF  3A,89
1382:  MOVFF  39,88
1386:  MOVFF  38,87
138A:  MOVFF  37,86
138E:  CALL   02F6
1392:  BCF    FD8.1
1394:  MOVFF  42,85
1398:  MOVFF  41,84
139C:  MOVFF  40,83
13A0:  MOVFF  3F,82
13A4:  MOVFF  03,89
13A8:  MOVFF  02,88
13AC:  MOVFF  01,87
13B0:  MOVFF  00,86
13B4:  CALL   0542
13B8:  MOVFF  03,42
13BC:  MOVFF  02,41
13C0:  MOVFF  01,40
13C4:  MOVFF  00,3F
....................                     pulso_timer=0; 
13C8:  CLRF   23
....................                      
.................... 					estado = PUNTO_TENS_CORR; 
13CA:  CLRF   53
....................                      
....................                     if((contador== 29)){ 
13CC:  MOVF   22,W
13CE:  SUBLW  1D
13D0:  BNZ   13DA
.................... 					disable_interrupts(INT_TIMER1);// deshabilita la interrupcion para no entrar al timer 
13D2:  BCF    F9D.0
....................                     contador=0; //se reinicia el contador, para comenzar nuevamente  
13D4:  CLRF   22
.................... 					estado = CALCULO_POT_ENER; 
13D6:  MOVLW  03
13D8:  MOVWF  53
.................... 				} 
.................... 				} 
.................... 				 
....................  
.................... 				break; 
13DA:  BRA    171C
....................                  
.................... //--------------------------------------------------------------------------------------------------------------------                 
.................... 			 
.................... 			case CALCULO_POT_ENER: // falta calculo de energia 
....................                 //calcula las raices para completar el calculo RMS 
.................... 				tension_RMS= sqrt(tension_RMS/30); 
13DC:  MOVFF  3E,69
13E0:  MOVFF  3D,68
13E4:  MOVFF  3C,67
13E8:  MOVFF  3B,66
13EC:  CLRF   x6D
13EE:  CLRF   x6C
13F0:  MOVLW  70
13F2:  MOVWF  x6B
13F4:  MOVLW  83
13F6:  MOVWF  x6A
13F8:  CALL   03E8
13FC:  MOVFF  03,57
1400:  MOVFF  02,56
1404:  MOVFF  01,55
1408:  MOVFF  00,54
140C:  MOVFF  03,5B
1410:  MOVFF  02,5A
1414:  MOVFF  01,59
1418:  MOVFF  00,58
141C:  CALL   0822
1420:  MOVFF  03,3E
1424:  MOVFF  02,3D
1428:  MOVFF  01,3C
142C:  MOVFF  00,3B
....................                 corriente_RMS= sqrt(corriente_RMS/30); 
1430:  MOVFF  42,69
1434:  MOVFF  41,68
1438:  MOVFF  40,67
143C:  MOVFF  3F,66
1440:  CLRF   x6D
1442:  CLRF   x6C
1444:  MOVLW  70
1446:  MOVWF  x6B
1448:  MOVLW  83
144A:  MOVWF  x6A
144C:  CALL   03E8
1450:  MOVFF  03,57
1454:  MOVFF  02,56
1458:  MOVFF  01,55
145C:  MOVFF  00,54
1460:  MOVFF  03,5B
1464:  MOVFF  02,5A
1468:  MOVFF  01,59
146C:  MOVFF  00,58
1470:  CALL   0822
1474:  MOVFF  03,42
1478:  MOVFF  02,41
147C:  MOVFF  01,40
1480:  MOVFF  00,3F
....................                  
....................                 // se controla si se pudo calcular desfase en el estado anterior  
....................                 // se realiza las diferencia de cruce por cero y se convierte de tiempo a radianes 
....................                 angulo=0; 
1484:  CLRF   4E
1486:  CLRF   4D
1488:  CLRF   4C
148A:  CLRF   4B
....................                 if (desfase==2){ 
148C:  MOVF   31,W
148E:  SUBLW  02
1490:  BNZ   1512
....................                     t_desfase= (control_I-control_V); 
1492:  MOVF   2F,W
1494:  SUBWF  30,W
1496:  CLRF   x83
1498:  MOVWF  x82
149A:  CALL   02C0
149E:  MOVFF  03,46
14A2:  MOVFF  02,45
14A6:  MOVFF  01,44
14AA:  MOVFF  00,43
....................                     angulo= (t_desfase*pi)/10;      // angulo de desfase en radianes. 20 puntos por periodo 
14AE:  MOVFF  46,85
14B2:  MOVFF  45,84
14B6:  MOVFF  44,83
14BA:  MOVFF  43,82
14BE:  MOVLW  DB
14C0:  MOVWF  x89
14C2:  MOVLW  0F
14C4:  MOVWF  x88
14C6:  MOVLW  49
14C8:  MOVWF  x87
14CA:  MOVLW  80
14CC:  MOVWF  x86
14CE:  CALL   02F6
14D2:  MOVFF  03,57
14D6:  MOVFF  02,56
14DA:  MOVFF  01,55
14DE:  MOVFF  00,54
14E2:  MOVFF  03,69
14E6:  MOVFF  02,68
14EA:  MOVFF  01,67
14EE:  MOVFF  00,66
14F2:  CLRF   x6D
14F4:  CLRF   x6C
14F6:  MOVLW  20
14F8:  MOVWF  x6B
14FA:  MOVLW  82
14FC:  MOVWF  x6A
14FE:  CALL   03E8
1502:  MOVFF  03,4E
1506:  MOVFF  02,4D
150A:  MOVFF  01,4C
150E:  MOVFF  00,4B
....................                    /*  lcd_gotoxy(1,1); 
....................                      printf(LCD_PUTC,"desfase= %f       ",t_desfase); 
....................                      lcd_gotoxy(1,2); 
....................                      printf(LCD_PUTC,"angulo=%f        ",angulo); 
....................                      delay_ms(1000);*/ 
....................                 }                 
....................                  
....................                 angulo=cos(angulo); 
1512:  MOVFF  4E,57
1516:  MOVFF  4D,56
151A:  MOVFF  4C,55
151E:  MOVFF  4B,54
1522:  GOTO   0966
1526:  MOVFF  03,4E
152A:  MOVFF  02,4D
152E:  MOVFF  01,4C
1532:  MOVFF  00,4B
....................                // calculo de potencia  
....................                 potencia_ins= tension_RMS*corriente_RMS*angulo; 
1536:  MOVFF  3E,85
153A:  MOVFF  3D,84
153E:  MOVFF  3C,83
1542:  MOVFF  3B,82
1546:  MOVFF  42,89
154A:  MOVFF  41,88
154E:  MOVFF  40,87
1552:  MOVFF  3F,86
1556:  CALL   02F6
155A:  MOVFF  03,57
155E:  MOVFF  02,56
1562:  MOVFF  01,55
1566:  MOVFF  00,54
156A:  MOVFF  03,85
156E:  MOVFF  02,84
1572:  MOVFF  01,83
1576:  MOVFF  00,82
157A:  MOVFF  4E,89
157E:  MOVFF  4D,88
1582:  MOVFF  4C,87
1586:  MOVFF  4B,86
158A:  CALL   02F6
158E:  MOVFF  03,4A
1592:  MOVFF  02,49
1596:  MOVFF  01,48
159A:  MOVFF  00,47
....................                 //se limpian las variables para la próxima etapa de muestreo 
....................                 control_V=0;       
159E:  CLRF   2F
....................                 control_I=0; 
15A0:  CLRF   30
....................                 angulo=0; 
15A2:  CLRF   4E
15A4:  CLRF   4D
15A6:  CLRF   4C
15A8:  CLRF   4B
....................                 desfase=0;  
15AA:  CLRF   31
....................                  
....................                 //Calculo de Energia 
....................                 tiempo_potencia=65536 - get_timer0();    //variable para calcular energia segun tiempo de potencia 
15AC:  MOVF   FD6,W
15AE:  XORLW  FF
15B0:  ADDLW  01
15B2:  MOVWF  29
15B4:  MOVLW  00
15B6:  SUBFWB FD7,W
15B8:  MOVWF  2A
....................                 Energia_Wms=potencia_ins*tiempo_potencia/37500000;             //Energia en Watt por milisegundo 
15BA:  MOVFF  2A,83
15BE:  MOVFF  29,82
15C2:  CALL   02C0
15C6:  MOVFF  4A,85
15CA:  MOVFF  49,84
15CE:  MOVFF  48,83
15D2:  MOVFF  47,82
15D6:  MOVFF  03,89
15DA:  MOVFF  02,88
15DE:  MOVFF  01,87
15E2:  MOVFF  00,86
15E6:  CALL   02F6
15EA:  MOVFF  03,57
15EE:  MOVFF  02,56
15F2:  MOVFF  01,55
15F6:  MOVFF  00,54
15FA:  MOVFF  03,69
15FE:  MOVFF  02,68
1602:  MOVFF  01,67
1606:  MOVFF  00,66
160A:  MOVLW  18
160C:  MOVWF  x6D
160E:  MOVLW  0D
1610:  MOVWF  x6C
1612:  MOVLW  0F
1614:  MOVWF  x6B
1616:  MOVLW  98
1618:  MOVWF  x6A
161A:  CALL   03E8
161E:  MOVFF  03,52
1622:  MOVFF  02,51
1626:  MOVFF  01,50
162A:  MOVFF  00,4F
....................                  
....................                  
.................... 					estado = MOSTRAR_DATOS; 
162E:  MOVLW  04
1630:  MOVWF  53
.................... 				break; 
1632:  BRA    171C
....................                  
.................... //------------------------------------------------------------------------------------- 
....................                  
.................... 			case MOSTRAR_DATOS: 
....................                 //este estado solo muestra los datos en la pantalla LCD 
....................                 lcd_gotoxy(1,1); 
1634:  MOVLW  01
1636:  MOVWF  x63
1638:  MOVWF  x64
163A:  CALL   0DB4
....................                 printf(LCD_PUTC,"Potencia= \%f W",potencia_ins); 
163E:  MOVLW  BE
1640:  MOVWF  FF6
1642:  MOVLW  00
1644:  MOVWF  FF7
1646:  MOVLW  0A
1648:  MOVWF  54
164A:  RCALL  0EB4
164C:  MOVLW  89
164E:  MOVWF  FE9
1650:  MOVFF  4A,57
1654:  MOVFF  49,56
1658:  MOVFF  48,55
165C:  MOVFF  47,54
1660:  MOVLW  02
1662:  MOVWF  58
1664:  RCALL  0FA0
1666:  MOVLW  20
1668:  MOVWF  x62
166A:  CALL   0E46
166E:  MOVLW  57
1670:  MOVWF  x62
1672:  CALL   0E46
....................                 lcd_gotoxy(1,2); 
1676:  MOVLW  01
1678:  MOVWF  x63
167A:  MOVLW  02
167C:  MOVWF  x64
167E:  CALL   0DB4
....................                 printf (LCD_PUTC, "T=\%f  I=\%f  ",tension_RMS,corriente_RMS); 
1682:  MOVLW  54
1684:  MOVWF  x62
1686:  CALL   0E46
168A:  MOVLW  3D
168C:  MOVWF  x62
168E:  CALL   0E46
1692:  MOVLW  89
1694:  MOVWF  FE9
1696:  MOVFF  3E,57
169A:  MOVFF  3D,56
169E:  MOVFF  3C,55
16A2:  MOVFF  3B,54
16A6:  MOVLW  02
16A8:  MOVWF  58
16AA:  RCALL  0FA0
16AC:  MOVLW  D2
16AE:  MOVWF  FF6
16B0:  MOVLW  00
16B2:  MOVWF  FF7
16B4:  MOVLW  04
16B6:  MOVWF  54
16B8:  CALL   0EB4
16BC:  MOVLW  89
16BE:  MOVWF  FE9
16C0:  MOVFF  42,57
16C4:  MOVFF  41,56
16C8:  MOVFF  40,55
16CC:  MOVFF  3F,54
16D0:  MOVLW  02
16D2:  MOVWF  58
16D4:  RCALL  0FA0
16D6:  MOVLW  20
16D8:  MOVWF  x62
16DA:  CALL   0E46
16DE:  MOVLW  20
16E0:  MOVWF  x62
16E2:  CALL   0E46
....................                 delay_ms(1000); 
16E6:  MOVLW  04
16E8:  MOVWF  54
16EA:  MOVLW  FA
16EC:  MOVWF  x63
16EE:  CALL   0E0A
16F2:  DECFSZ 54,F
16F4:  BRA    16EA
....................                 enable_interrupts(INT_TIMER1); 
16F6:  BSF    F9D.0
....................                 enable_interrupts(GLOBAL); 
16F8:  MOVLW  C0
16FA:  IORWF  FF2,F
....................                 pulso_timer=0; 
16FC:  CLRF   23
....................                 set_timer1(carga);    
16FE:  MOVLW  E8
1700:  MOVWF  FCF
1702:  MOVLW  AB
1704:  MOVWF  FCE
.................... 				//reinicia todo 
....................                 corriente_RMS=0; 
1706:  CLRF   42
1708:  CLRF   41
170A:  CLRF   40
170C:  CLRF   3F
....................                 tension_RMS=0; 
170E:  CLRF   3E
1710:  CLRF   3D
1712:  CLRF   3C
1714:  CLRF   3B
....................                  
.................... 				estado = PUNTO_TENS_CORR; 
1716:  CLRF   53
.................... 		 
....................  
.................... 				break; 
1718:  BRA    171C
.................... 			 
.................... 			default: estado = PUNTO_TENS_CORR; 
171A:  CLRF   53
.................... 		} 
171C:  GOTO   175A (RETURN)
....................  
....................  
.................... } 
....................  
.................... //Funciones asociadas a los eventos 
....................  
.................... /** 
.................... *	\fn int -(void) 
.................... *	\brief Resumen 
.................... *	\details Detalles 
.................... *	\author Postemsky Marcos 
.................... *	\date 17-09-2016 11:39:08 
.................... */ 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 4C07   PLL12 CPUDIV1 NOUSBDIV HS FCMEN NOIESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
